diff --git a/kernel/kernel/arch/arm64/configs/defconfig b/kernel/kernel/arch/arm64/configs/defconfig
index 9b4b26388..32bee7250 100644
--- a/kernel/kernel/arch/arm64/configs/defconfig
+++ b/kernel/kernel/arch/arm64/configs/defconfig
@@ -906,6 +906,7 @@ CONFIG_NV_DESER_MAX96712=m
 CONFIG_NV_VIDEO_AR0234=m
 CONFIG_NV_VIDEO_HAWK_OWL=m
 CONFIG_NV_VIRTUAL_I2C_MUX=m
+CONFIG_NV_VIDEO_ISX031=y
 # CONFIG_CXD2880_SPI_DRV is not set
 CONFIG_MEDIA_TUNER_SIMPLE=y
 # CONFIG_MEDIA_TUNER_TDA18250 is not set
diff --git a/kernel/kernel/arch/arm64/configs/defconfig.orig b/kernel/kernel/arch/arm64/configs/defconfig.orig
new file mode 100644
index 000000000..9b4b26388
--- /dev/null
+++ b/kernel/kernel/arch/arm64/configs/defconfig.orig
@@ -0,0 +1,1397 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_WATCH_QUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB_FREELIST_RANDOM=y
+CONFIG_SLAB_FREELIST_HARDENED=y
+CONFIG_SHUFFLE_PAGE_ALLOCATOR=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_TEGRA=y
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_PARAVIRT=y
+CONFIG_KEXEC=y
+CONFIG_KEXEC_FILE=y
+CONFIG_CRASH_DUMP=y
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
+CONFIG_COMPAT=y
+CONFIG_ARMV8_DEPRECATED=y
+CONFIG_SWP_EMULATION=y
+CONFIG_CP15_BARRIER_EMULATION=y
+CONFIG_SETEND_EMULATION=y
+# CONFIG_ARM64_HW_AFDBM is not set
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_IDLE_TEGRA_AUTO=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ACPI_CPPC_CPUFREQ=m
+CONFIG_ARM_TEGRA186_CPUFREQ=y
+CONFIG_ARM_SCPI_PROTOCOL=m
+CONFIG_DMI_SYSFS=y
+# CONFIG_EFI_VARS_PSTORE is not set
+# CONFIG_DMI is not set
+CONFIG_EFI_CAPSULE_LOADER=y
+CONFIG_EFI_TEST=m
+CONFIG_ACPI=y
+CONFIG_ACPI_APEI=y
+CONFIG_ACPI_APEI_GHES=y
+CONFIG_ACPI_APEI_MEMORY_FAILURE=y
+CONFIG_ACPI_APEI_EINJ=y
+CONFIG_KVM=y
+CONFIG_TEGRA_DTC_SUPPRESS_WARNINGS=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=m
+CONFIG_CRYPTO_SHA2_ARM64_CE=m
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=m
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=m
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=m
+CONFIG_ARCH_TEGRA_23x_SOC=y
+CONFIG_ARCH_TEGRA_239_SOC=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SIG=y
+CONFIG_MODULE_SIG_SHA512=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_MISC=m
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_MEMORY_FAILURE=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_ZSMALLOC=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_ESP=m
+CONFIG_INET_DIAG=m
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NETFILTER_NETLINK_ACCT=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=y
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_NET_DSA=m
+CONFIG_NET_DSA_TAG_OCELOT=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_CBS=y
+CONFIG_NET_SCH_ETF=m
+CONFIG_NET_SCH_TAPRIO=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_U32=y
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_CLS_FLOWER=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_GATE=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_BPF_JIT=y
+CONFIG_CAN=m
+CONFIG_CAN_VCAN=m
+CONFIG_CAN_SLCAN=m
+CONFIG_CAN_C_CAN=m
+CONFIG_CAN_CC770=m
+CONFIG_CAN_CC770_ISA=m
+CONFIG_CAN_CC770_PLATFORM=m
+CONFIG_CAN_M_CAN=m
+CONFIG_CAN_SJA1000=m
+CONFIG_CAN_EMS_PCI=m
+CONFIG_CAN_KVASER_PCI=m
+CONFIG_CAN_PLX_PCI=m
+CONFIG_CAN_SJA1000_ISA=m
+CONFIG_CAN_SJA1000_PLATFORM=m
+CONFIG_CAN_SOFTING=m
+CONFIG_CAN_MCP251X=m
+CONFIG_CAN_8DEV_USB=m
+CONFIG_CAN_EMS_USB=m
+CONFIG_CAN_ESD_USB2=m
+CONFIG_CAN_GS_USB=m
+CONFIG_CAN_KVASER_USB=m
+CONFIG_CAN_PEAK_USB=m
+CONFIG_MTTCAN=m
+CONFIG_TEGRA_HV_SECCAN=m
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_HIDP=y
+# CONFIG_BT_LE is not set
+CONFIG_BT_LEDS=y
+# CONFIG_BT_DEBUGFS is not set
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_INTEL=y
+CONFIG_BT_HCIUART_BCM=y
+CONFIG_BT_HCIUART_QCA=y
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_HCIVHCI=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_ATH3K=m
+CONFIG_AF_RXRPC=m
+CONFIG_AF_KCM=m
+CONFIG_CFG80211=m
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+# CONFIG_CFG80211_REQUIRE_SIGNED_REGDB is not set
+CONFIG_MAC80211=m
+CONFIG_RFKILL=y
+CONFIG_NET_9P=y
+CONFIG_NFC=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCIE_ECRC=y
+CONFIG_PCIEASPM_POWER_SUPERSAVE=y
+CONFIG_PCI_STUB=m
+CONFIG_PCI_IOV=y
+CONFIG_PCIE_BUS_SAFE=y
+CONFIG_PCI_TEGRA=y
+CONFIG_PCIE_TEGRA194_EP=y
+CONFIG_PCIE_LAYERSCAPE_GEN4=y
+CONFIG_PCIE_TEGRA_VF=y
+CONFIG_PCI_ENDPOINT=y
+CONFIG_PCI_ENDPOINT_CONFIGFS=y
+CONFIG_PCI_EPF_TEST=y
+CONFIG_PCIE_EPF_NV_TEST=y
+CONFIG_PCIE_EPF_TEGRA_VNET=y
+CONFIG_PCI_SERIAL_CH384=m
+CONFIG_UEVENT_HELPER=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_BRCMSTB_GISB_ARB=y
+CONFIG_SIMPLE_PM_BUS=y
+CONFIG_TEGRA_ACONNECT=y
+CONFIG_VEXPRESS_CONFIG=y
+CONFIG_MTD=m
+CONFIG_MTD_CMDLINE_PARTS=m
+CONFIG_MTD_BLOCK=m
+CONFIG_MTD_QSPI_FLASH=m
+CONFIG_MTD_TEGRA_VIRT=m
+CONFIG_MTD_RAW_NAND=m
+CONFIG_MTD_SPI_NOR=m
+CONFIG_MTD_UBI=m
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+CONFIG_ZRAM=m
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_VIRTIO_BLK=y
+CONFIG_TEGRA_HV_BLKDEV=y
+CONFIG_TEGRA_HV_BLKDEV_OOPS=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_NVME_RDMA=m
+CONFIG_NVME_FC=m
+CONFIG_TIFM_CORE=m
+CONFIG_SRAM=y
+CONFIG_PCI_ENDPOINT_TEST=m
+CONFIG_EEPROM_AT24=m
+CONFIG_EEPROM_AT25=m
+CONFIG_CB710_CORE=m
+CONFIG_MODS=m
+CONFIG_SENSORS_F75308=m
+CONFIG_SENSORS_NCT1008=m
+CONFIG_SENSORS_PEX9749=y
+CONFIG_FAN_THERM_EST=y
+CONFIG_EQOS_APE_HWDEP=m
+CONFIG_TEGRA_ACSL=m
+CONFIG_TEGRA_PCIE_EP_MEM=y
+CONFIG_NVS_LIGHT=m
+CONFIG_NVS_PROXIMITY=y
+CONFIG_NVS_GTE=m
+CONFIG_TEGRA_PROFILER=y
+CONFIG_NVSCIC2C_PCIE=m
+CONFIG_NVSCIIPC=y
+CONFIG_BLUEDROID_PM=m
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_HISI_SAS=m
+CONFIG_SCSI_HISI_SAS_PCI=m
+CONFIG_SCSI_MPT3SAS=m
+CONFIG_SCSI_UFSHCD=y
+CONFIG_SCSI_UFSHCD_PLATFORM=y
+CONFIG_SCSI_UFSHCD_TEGRA=y
+CONFIG_ATA=m
+# CONFIG_ATA_ACPI is not set
+CONFIG_SATA_AHCI=m
+CONFIG_SATA_AHCI_PLATFORM=m
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_CRYPT=y
+CONFIG_DM_UEVENT=y
+CONFIG_DM_VERITY=y
+CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG=y
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_IPVLAN=m
+CONFIG_VXLAN=y
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=y
+CONFIG_TYPHOON=m
+CONFIG_ET131X=m
+CONFIG_SLICOSS=m
+CONFIG_ACENIC=m
+CONFIG_ALTERA_TSE=m
+CONFIG_AQTION=m
+CONFIG_ATL2=m
+CONFIG_ATL1=m
+CONFIG_ATL1E=m
+CONFIG_ATL1C=m
+CONFIG_ALX=m
+# CONFIG_NET_VENDOR_AURORA is not set
+CONFIG_B44=m
+CONFIG_CNIC=m
+CONFIG_TIGON3=y
+CONFIG_BNX2X=m
+CONFIG_BNXT=m
+CONFIG_BNA=m
+CONFIG_MACB=y
+CONFIG_THUNDER_NIC_PF=m
+CONFIG_THUNDER_NIC_VF=m
+# CONFIG_CAVIUM_PTP is not set
+CONFIG_LIQUIDIO=m
+CONFIG_LIQUIDIO_VF=m
+CONFIG_CHELSIO_T1=m
+CONFIG_CHELSIO_T1_1G=y
+CONFIG_CHELSIO_T3=m
+CONFIG_CHELSIO_T4=m
+CONFIG_CHELSIO_T4VF=m
+CONFIG_ENIC=m
+CONFIG_DL2K=m
+CONFIG_BE2NET=m
+CONFIG_HNS_DSAF=y
+CONFIG_HNS_ENET=y
+CONFIG_HNS3=y
+# CONFIG_HNS3_HCLGE is not set
+CONFIG_HNS3_ENET=y
+CONFIG_HINIC=m
+CONFIG_E100=m
+CONFIG_E1000=m
+CONFIG_E1000E=y
+CONFIG_IGB=y
+CONFIG_IGBVF=m
+CONFIG_IXGB=m
+CONFIG_IXGBE=m
+# CONFIG_IXGBE_HWMON is not set
+CONFIG_IXGBEVF=m
+CONFIG_I40E=m
+CONFIG_I40EVF=m
+CONFIG_ICE=m
+CONFIG_FM10K=m
+CONFIG_IGC=m
+CONFIG_JME=m
+CONFIG_SKGE=m
+CONFIG_SKY2=m
+CONFIG_SKY2_DEBUG=y
+CONFIG_OAK=m
+CONFIG_MLX4_EN=m
+CONFIG_MLX5_CORE=m
+CONFIG_MLX5_CORE_EN=y
+CONFIG_MLX5_CORE_IPOIB=y
+CONFIG_MLX5_CORE_THERMAL=y
+CONFIG_MLXSW_CORE=y
+CONFIG_MLX_MFT=m
+CONFIG_LAN743X=m
+CONFIG_NATSEMI=m
+CONFIG_NS83820=m
+CONFIG_S2IO=m
+CONFIG_VXGE=m
+CONFIG_NFP=m
+CONFIG_NFP_DEBUG=y
+CONFIG_NI_XGE_MANAGEMENT_ENET=m
+CONFIG_NE2K_PCI=m
+CONFIG_FORCEDETH=y
+CONFIG_PCIE_TEGRA_VNET=y
+CONFIG_HAMACHI=m
+CONFIG_YELLOWFIN=m
+CONFIG_IONIC=m
+CONFIG_QLA3XXX=m
+CONFIG_QLCNIC=m
+CONFIG_NETXEN_NIC=m
+CONFIG_QCA7000_SPI=m
+CONFIG_QCOM_EMAC=m
+CONFIG_8139CP=m
+CONFIG_8139TOO=m
+CONFIG_R8168=m
+CONFIG_SXGBE_ETH=m
+CONFIG_SFC=m
+CONFIG_SMC91X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=m
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_NVETHERNET=y
+CONFIG_NVETHERNET_SELFTESTS=y
+CONFIG_AQUANTIA_PHY=y
+CONFIG_BROADCOM_PHY=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MARVELL_10G_PHY=m
+CONFIG_MICREL_PHY=m
+CONFIG_MDIO_BITBANG=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=y
+CONFIG_USB_LAN78XX=m
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_CDC_MBIM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SR9700=m
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_AQC111=y
+CONFIG_ATH9K=m
+CONFIG_ATH9K_DEBUGFS=y
+CONFIG_ATH9K_STATION_STATISTICS=y
+CONFIG_ATH9K_WOW=y
+CONFIG_ATH9K_HTC=m
+CONFIG_ATH9K_HTC_DEBUGFS=y
+CONFIG_CARL9170=m
+CONFIG_CARL9170_DEBUGFS=y
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_SDIO=m
+CONFIG_ATH6KL_USB=m
+CONFIG_AR5523=m
+CONFIG_WIL6210=m
+CONFIG_ATH10K=m
+CONFIG_ATH10K_PCI=m
+CONFIG_ATH10K_AHB=y
+CONFIG_ATH10K_SDIO=m
+CONFIG_ATH10K_USB=m
+CONFIG_ATH10K_DEBUGFS=y
+CONFIG_WCN36XX=m
+CONFIG_WCN36XX_DEBUGFS=y
+CONFIG_ATMEL=m
+CONFIG_AT76C50X_USB=m
+CONFIG_B43=m
+CONFIG_B43_SDIO=y
+CONFIG_B43LEGACY=m
+CONFIG_BRCMFMAC=m
+# CONFIG_BRCMFMAC_SDIO is not set
+CONFIG_BRCMFMAC_PCIE=y
+CONFIG_IPW2100=m
+CONFIG_IPW2200=m
+CONFIG_IWL3945=m
+CONFIG_IWLWIFI=m
+CONFIG_IWLDVM=m
+CONFIG_IWLMVM=m
+CONFIG_IWLWIFI_BCAST_FILTERING=y
+CONFIG_IWLWIFI_DEBUG=y
+CONFIG_IWLWIFI_DEBUGFS=y
+CONFIG_HERMES=m
+CONFIG_HERMES_PRISM=y
+CONFIG_PLX_HERMES=m
+CONFIG_TMD_HERMES=m
+CONFIG_NORTEL_HERMES=m
+CONFIG_ORINOCO_USB=m
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+CONFIG_P54_PCI=m
+CONFIG_P54_SPI=m
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_THINFIRM=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_MWIFIEX_PCIE=m
+CONFIG_MWIFIEX_USB=m
+CONFIG_MWL8K=m
+CONFIG_MT7601U=m
+CONFIG_MT76x0U=m
+CONFIG_MT76x0E=m
+CONFIG_MT76x2E=m
+CONFIG_MT76x2U=m
+CONFIG_MT7603E=m
+CONFIG_MT7615E=m
+CONFIG_MT7663U=m
+CONFIG_MT7915E=m
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+CONFIG_RT2X00=m
+CONFIG_RT2800PCI=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT3573=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RT2X00_LIB_DEBUGFS=y
+CONFIG_RTL8187=m
+CONFIG_RTL8192CE=m
+CONFIG_RTL8192SE=m
+CONFIG_RTL8192DE=m
+CONFIG_RTL8723AE=m
+CONFIG_RTL8723BE=m
+CONFIG_RTL8188EE=m
+CONFIG_RTL8192EE=m
+CONFIG_RTL8821AE=m
+CONFIG_RTL8192CU=m
+CONFIG_RTL8XXXU=m
+CONFIG_RTL8XXXU_UNTESTED=y
+CONFIG_RSI_91X=m
+# CONFIG_RSI_COEX is not set
+CONFIG_CW1200=m
+CONFIG_CW1200_WLAN_SDIO=m
+CONFIG_WL1251=m
+CONFIG_WL1251_SDIO=m
+CONFIG_WL12XX=m
+CONFIG_WL18XX=m
+CONFIG_WLCORE_SDIO=m
+CONFIG_USB_ZD1201=m
+CONFIG_ZD1211RW=m
+CONFIG_BCMDHD=m
+CONFIG_BCM4354=y
+CONFIG_BCMDHD_HW_OOB=y
+CONFIG_DHD_USE_SCHED_SCAN=y
+CONFIG_BCMDHD_DISABLE_MCC=y
+CONFIG_RTL8822CE=m
+CONFIG_TEGRA_HV_NET=y
+CONFIG_INPUT_LEDS=m
+CONFIG_INPUT_POLLDEV=m
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADP5588=m
+CONFIG_KEYBOARD_ADP5589=m
+CONFIG_KEYBOARD_ATKBD=m
+CONFIG_KEYBOARD_QT1070=m
+CONFIG_KEYBOARD_QT2160=m
+CONFIG_KEYBOARD_LKKBD=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=m
+CONFIG_KEYBOARD_TCA6416=m
+CONFIG_KEYBOARD_TCA8418=m
+CONFIG_KEYBOARD_MATRIX=m
+CONFIG_KEYBOARD_LM8323=m
+CONFIG_KEYBOARD_LM8333=m
+CONFIG_KEYBOARD_MAX7359=m
+CONFIG_KEYBOARD_MCS=m
+CONFIG_KEYBOARD_MPR121=m
+CONFIG_KEYBOARD_NEWTON=m
+CONFIG_KEYBOARD_TEGRA=m
+CONFIG_KEYBOARD_OPENCORES=m
+CONFIG_KEYBOARD_SAMSUNG=m
+CONFIG_KEYBOARD_STOWAWAY=m
+CONFIG_KEYBOARD_OMAP4=m
+CONFIG_KEYBOARD_XTKBD=m
+CONFIG_KEYBOARD_CAP11XX=m
+CONFIG_KEYBOARD_BCM=m
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_SERIAL=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
+CONFIG_MOUSE_CYAPA=m
+CONFIG_MOUSE_VSXXXAA=m
+CONFIG_MOUSE_GPIO=m
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+CONFIG_MOUSE_SYNAPTICS_USB=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_INPUT_TABLET=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_SERIO_SERPORT=m
+CONFIG_SERIO_AMBAKMI=m
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DW=m
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_SERIAL_TEGRA=y
+CONFIG_SERIAL_TEGRA_TCU=y
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_TEGRA_COMBINED_UART_EARLY=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_FTPM_TEE=m
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_GPIO=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_ALI1535=m
+CONFIG_I2C_ALI1563=m
+CONFIG_I2C_ALI15X3=m
+CONFIG_I2C_AMD756=m
+CONFIG_I2C_AMD8111=m
+CONFIG_I2C_I801=m
+CONFIG_I2C_ISCH=m
+CONFIG_I2C_PIIX4=m
+CONFIG_I2C_NFORCE2=m
+CONFIG_I2C_SIS630=m
+CONFIG_I2C_VIAPRO=m
+CONFIG_I2C_CADENCE=m
+CONFIG_I2C_CBUS_GPIO=m
+CONFIG_I2C_DESIGNWARE_PLATFORM=m
+CONFIG_I2C_DESIGNWARE_PCI=m
+CONFIG_I2C_EMEV2=m
+CONFIG_I2C_GPIO=m
+CONFIG_I2C_NOMADIK=m
+CONFIG_I2C_OCORES=m
+CONFIG_I2C_PCA_PLATFORM=m
+CONFIG_I2C_RK3X=m
+CONFIG_I2C_SIMTEC=m
+CONFIG_I2C_TEGRA=y
+CONFIG_I2C_DIOLAN_U2C=m
+CONFIG_I2C_NVVRS11=m
+CONFIG_I2C_TEGRA_CAMRTC=y
+CONFIG_I2C_TEGRA_SLAVE=m
+CONFIG_I2C_TEGRA194_SLAVE=m
+CONFIG_I2C_STUB=m
+CONFIG_I2C_SLAVE_EEPROM=m
+CONFIG_SPI=y
+CONFIG_SPI_CADENCE=m
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_SPI_NXP_FLEXSPI=y
+CONFIG_SPI_PXA2XX=m
+CONFIG_SPI_SC18IS602=m
+CONFIG_SPI_TEGRA114=m
+CONFIG_SPI_TEGRA124_SLAVE=y
+CONFIG_SPI_TEGRA194_SLAVE=y
+CONFIG_QSPI_TEGRA23x=y
+CONFIG_QSPI_TEGRA210=m
+CONFIG_SPI_XCOMM=m
+CONFIG_SPI_ZYNQMP_GQSPI=m
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPI_TLE62X0=m
+CONFIG_SPMI=m
+CONFIG_PPS_CLIENT_KTIMER=y
+CONFIG_PPS_CLIENT_LDISC=y
+CONFIG_PPS_CLIENT_GPIO=y
+CONFIG_PINCTRL_TEGRA186_DPAUX=y
+CONFIG_PINCTRL_TEGRA234_DPAUX=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MAX77620=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MB86S7X=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_BD9571MWV=m
+CONFIG_GPIO_MAX77620=y
+CONFIG_GPIO_TMPM32X_I2C=y
+CONFIG_POWER_RESET_MAX77620=y
+CONFIG_BATTERY_SBS=m
+CONFIG_BATTERY_BQ27XXX=y
+CONFIG_SENSORS_PWM_FAN=m
+CONFIG_SENSORS_INA2XX=m
+CONFIG_SENSORS_INA3221=m
+CONFIG_GPIO_TACHOMETER=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_MAX77620_THERMAL=m
+CONFIG_TEGRA_SOCTHERM=y
+CONFIG_TEGRA_BPMP_THERMAL=m
+CONFIG_TEGRA_AOTAG=y
+CONFIG_TEGRA_TJ_THERMAL=y
+CONFIG_TEGRA_CORE_CAPS=y
+CONFIG_TEGRA_DFLL_CAPS=y
+CONFIG_THERMAL_GOV_PID=y
+CONFIG_USERSPACE_THERM_ALERT=m
+CONFIG_TEGRA23X_OC_EVENT=y
+CONFIG_TEGRA19X_OC_EVENT=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_MAX77620_WATCHDOG=y
+CONFIG_ARM_SMC_WATCHDOG=y
+CONFIG_TEGRA21X_WATCHDOG=y
+CONFIG_TEGRA18X_WATCHDOG=y
+CONFIG_TEGRA_HV_WATCHDOG=y
+CONFIG_MFD_BD9571MWV=y
+CONFIG_MFD_HI6421_PMIC=y
+CONFIG_MFD_MAX77620=y
+CONFIG_MFD_RK808=y
+CONFIG_MFD_SEC_CORE=y
+CONFIG_MFD_ROHM_BD718XX=y
+CONFIG_MFD_NVVRS_PSEQ=y
+CONFIG_NVVRS_PSEQ_RTC=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MAX77620=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_TPS65132=y
+CONFIG_REGULATOR_PMIC_OTP=y
+CONFIG_REGULATOR_NCP81599=y
+CONFIG_RC_CORE=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_SUPPORT_FILTER=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_MEDIA_TEST_SUPPORT=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_DTCS033=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_JL2005BCD=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STK1135=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TOPRO=m
+CONFIG_USB_GSPCA_TOUPTEK=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_USB_PWC=m
+CONFIG_VIDEO_CPIA2=m
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+CONFIG_VIDEO_USBTV=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_CAMERA=y
+CONFIG_VIDEO_ISC=m
+CONFIG_VIDEO_CDI=m
+CONFIG_V4L_TEST_DRIVERS=y
+CONFIG_VIDEO_ECAM=m
+CONFIG_NV_VIDEO_IMX185=m
+CONFIG_NV_VIDEO_IMX219=m
+CONFIG_NV_VIDEO_IMX477=m
+CONFIG_NV_VIDEO_IMX268=m
+CONFIG_NV_VIDEO_IMX274=m
+CONFIG_NV_VIDEO_IMX318=m
+CONFIG_NV_VIDEO_LC898212=m
+CONFIG_NV_VIDEO_OV5693=m
+CONFIG_NV_VIDEO_OV9281=m
+CONFIG_NV_VIDEO_OV10823=m
+CONFIG_NV_VIDEO_OV23850=m
+CONFIG_I2C_IOEXPANDER_PCA9570=m
+CONFIG_VIDEO_TC358840=m
+CONFIG_VIDEO_LT6911UXC=m
+CONFIG_I2C_IOEXPANDER_SER_MAX9295=y
+CONFIG_I2C_IOEXPANDER_DESER_MAX9296=y
+CONFIG_NV_VIDEO_IMX390=y
+CONFIG_NV_DESER_MAX96712=m
+CONFIG_NV_VIDEO_AR0234=m
+CONFIG_NV_VIDEO_HAWK_OWL=m
+CONFIG_NV_VIRTUAL_I2C_MUX=m
+# CONFIG_CXD2880_SPI_DRV is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+CONFIG_MEDIA_TUNER_TDA8290=y
+# CONFIG_MEDIA_TUNER_TDA18272 is not set
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_XC4000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_VGA_ARB is not set
+CONFIG_DRM=y
+CONFIG_DRM_I2C_NXP_TDA998X=m
+CONFIG_DRM_RCAR_DW_HDMI=m
+CONFIG_DRM_RCAR_LVDS=m
+CONFIG_DRM_PANEL_LVDS=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_SII902X=m
+CONFIG_DRM_HISI_HIBMC=m
+CONFIG_DRM_HISI_KIRIN=m
+CONFIG_DRM_TEGRA_UDRM=m
+CONFIG_FB_MODE_PIXCLOCK_HZ=y
+CONFIG_FB_EFI=y
+CONFIG_FB_SIMPLE=y
+CONFIG_LCD_CLASS_DEVICE=m
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_LP855X=y
+CONFIG_TEGRA_GRHOST=y
+CONFIG_TEGRA_GRHOST_NVCSI=y
+CONFIG_TEGRA_GR_VIRTUALIZATION=y
+CONFIG_TEGRA_DC=y
+CONFIG_TEGRA_DC_SCREEN_CAPTURE=y
+CONFIG_TEGRA_DSI=y
+CONFIG_MAXIM_GMSL_DP_SERIALIZER=y
+CONFIG_TEGRA_HDMI2_0=y
+CONFIG_TEGRA_HDMIHDCP=y
+CONFIG_TEGRA_DPHDCP=y
+CONFIG_TEGRA_CEC_SUPPORT=y
+CONFIG_TEGRA_GRHOST_SLVSEC=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_ALOOP=m
+CONFIG_SND_HDA_INTEL=m
+CONFIG_SND_HDA_TEGRA=m
+CONFIG_SND_HDA_CODEC_HDMI=m
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=1
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_TEGRA=m
+CONFIG_SND_SOC_TEGRA210_AHUB=m
+CONFIG_SND_SOC_TEGRA210_DMIC=m
+CONFIG_SND_SOC_TEGRA210_I2S=m
+CONFIG_SND_SOC_TEGRA186_DSPK=m
+CONFIG_SND_SOC_TEGRA210_ADMAIF=m
+CONFIG_SND_SOC_TEGRA186_ARAD=m
+CONFIG_SND_SOC_TEGRA186_ASRC=m
+CONFIG_SND_SOC_TEGRA210_AMX=m
+CONFIG_SND_SOC_TEGRA210_ADX=m
+CONFIG_SND_SOC_TEGRA210_MIXER=m
+CONFIG_SND_SOC_TEGRA210_SFC=m
+CONFIG_SND_SOC_TEGRA210_MVC=m
+CONFIG_SND_SOC_TEGRA210_AFC=m
+CONFIG_SND_SOC_TEGRA210_IQC=m
+CONFIG_SND_SOC_TEGRA210_OPE=m
+CONFIG_SND_SOC_TEGRA210_ADSP=m
+CONFIG_SND_SOC_TEGRA210_AUDIO=m
+CONFIG_SND_SOC_TEGRA_AUDIO_GRAPH_CARD=m
+CONFIG_SND_SOC_AK4613=m
+CONFIG_SND_SOC_ES7134=m
+CONFIG_SND_SOC_MAX98927=m
+CONFIG_SND_SOC_PCM3168A_I2C=m
+CONFIG_SND_SOC_RT5640=m
+CONFIG_SND_SOC_SPDIF=m
+CONFIG_SND_SOC_TAS571X=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SND_AUDIO_GRAPH_CARD=m
+CONFIG_SND_SOC_TEGRA210_ADSP_VIRT_ALT=m
+CONFIG_SND_SOC_TEGRA_VIRT_T210REF_PCM=m
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_A4TECH=m
+CONFIG_HID_ACRUX=y
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_APPLEIR=m
+CONFIG_HID_ASUS=m
+CONFIG_HID_AUREAL=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_BETOP_FF=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CORSAIR=m
+CONFIG_HID_PRODIKEYS=m
+CONFIG_HID_CMEDIA=m
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=y
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_ELECOM=m
+CONFIG_HID_ELO=m
+CONFIG_HID_EZKEY=m
+CONFIG_HID_GEMBIRD=m
+CONFIG_HID_GFRM=m
+CONFIG_HID_HOLTEK=y
+CONFIG_HID_GT683R=m
+CONFIG_HID_KEYTOUCH=y
+CONFIG_HID_KYE=y
+CONFIG_HID_UCLOGIC=y
+CONFIG_HID_WALTOP=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_ICADE=m
+CONFIG_HID_ITE=m
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=m
+CONFIG_HID_LCPOWER=y
+CONFIG_HID_LENOVO=m
+CONFIG_HID_LOGITECH=m
+CONFIG_HID_LOGITECH_DJ=m
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+CONFIG_HID_MULTITOUCH=y
+CONFIG_HID_NTI=m
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PENMOUNT=m
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_BACKLIGHT=y
+CONFIG_HID_PLANTRONICS=m
+CONFIG_HID_PRIMAX=m
+CONFIG_HID_RETRODE=m
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_SAITEK=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_STEELSERIES=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_RMI=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=m
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THINGM=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_HID_UDRAW_PS3=m
+CONFIG_HID_WACOM=m
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_XINMO=m
+CONFIG_HID_ZEROPLUS=m
+CONFIG_HID_ZYDACRON=m
+CONFIG_HID_SENSOR_HUB=m
+CONFIG_HID_SENSOR_CUSTOM_SENSOR=m
+CONFIG_HID_ALPS=m
+CONFIG_USB_HIDDEV=y
+CONFIG_HID_SHIELD_REMOTE=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_OTG=y
+CONFIG_USB_MON=m
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_TEGRA=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=m
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_ENE_UB6250=m
+CONFIG_USB_UAS=y
+CONFIG_USB_MDC800=m
+CONFIG_USB_CHIPIDEA=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_XSENS_MT=m
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_LCD=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_LD=m
+CONFIG_USB_TEST=m
+CONFIG_USB_EHSET_TEST_FIXTURE=m
+CONFIG_USB_YUREX=m
+CONFIG_USB_HSIC_USB4604=m
+CONFIG_USB_GADGET=y
+CONFIG_USB_TEGRA_XUDC=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_ACC=y
+CONFIG_TYPEC=m
+CONFIG_TYPEC_FUSB301=m
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_CCG=m
+CONFIG_TYPEC_STUSB160X=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=m
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_STM32_SDMMC is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_TEGRA=y
+CONFIG_MMC_SPI=m
+CONFIG_MMC_DW=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=m
+CONFIG_LEDS_PWM=m
+CONFIG_LEDS_BD2802=m
+CONFIG_LEDS_IS31FL319X=m
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_MLX4_INFINIBAND=m
+CONFIG_MLX5_INFINIBAND=m
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_INFINIBAND_IPOIB_CM=y
+CONFIG_INFINIBAND_SRP=m
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc1"
+# CONFIG_RTC_NVMEM is not set
+CONFIG_RTC_DRV_MAX77686=y
+CONFIG_RTC_DRV_RX8025=m
+CONFIG_DMADEVICES=y
+CONFIG_DMA_BCM2835=y
+CONFIG_DMA_SUN6I=m
+CONFIG_IMX_SDMA=m
+CONFIG_K3_DMA=y
+CONFIG_MV_XOR=y
+CONFIG_MV_XOR_V2=y
+CONFIG_OWL_DMA=y
+CONFIG_PL330_DMA=y
+CONFIG_TEGRA20_APB_DMA=y
+CONFIG_TEGRA210_ADMA=m
+CONFIG_TEGRA_GPC_DMA=y
+CONFIG_DMATEST=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_VFIO=m
+CONFIG_VFIO_PCI=m
+CONFIG_VIRT_DRIVERS=y
+CONFIG_VIRTIO_PCI=m
+CONFIG_VIRTIO_BALLOON=m
+CONFIG_VIRTIO_MMIO=m
+CONFIG_PRISM2_USB=m
+CONFIG_RTL8192U=m
+CONFIG_RTLLIB=m
+CONFIG_RTL8192E=m
+CONFIG_R8712U=m
+CONFIG_R8188EU=m
+CONFIG_QLGE=m
+CONFIG_TEGRA_HTS_GTE=y
+CONFIG_DENVER_CPU=y
+CONFIG_TEGRA_AON=y
+CONFIG_TEGRA_BWMGR=y
+CONFIG_TEGRA_CAMERA_RTCPU=y
+CONFIG_TEGRA_CAMERA_HSP_MBOX_CLIENT=y
+CONFIG_TEGRA_FSICOM=y
+CONFIG_TEGRA_EPL=y
+CONFIG_TEGRA_DCE=y
+CONFIG_TEGRA_ISOMGR=y
+CONFIG_TEGRA_ISOMGR_SYSFS=y
+CONFIG_TEGRA_SPE=y
+CONFIG_TEGRA_SPE_HSP_MBOX_CLIENT=y
+CONFIG_TEGRA_CENTRAL_ACTMON=y
+CONFIG_TEGRA_BOOTLOADER_DEBUG=m
+CONFIG_TEGRA_CLOCKS_CONFIGURE=y
+CONFIG_TEGRA_USS_IO_PROXY=y
+CONFIG_TEGRA_SAFETY=y
+CONFIG_TEGRA_NVADSP=m
+CONFIG_TEGRA_NVADSP_ON_SMMU=y
+CONFIG_TEGRA_ADSP_FILEIO=y
+CONFIG_TEGRA_ADSP_LPTHREAD=y
+CONFIG_TEGRA_VIRT_AUDIO_IVC=y
+CONFIG_COMMON_CLK_FREQ_STATS_ACCOUNTING=y
+CONFIG_CLK_SRC_TEGRA18_TIMER=y
+CONFIG_ARM_MHU=m
+CONFIG_TEGRA_IOMMU_SMMU=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_DEBUG=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_SOUNDWIRE=m
+CONFIG_ARCH_TEGRA_210_SOC=y
+CONFIG_ARCH_TEGRA_186_SOC=y
+CONFIG_ARCH_TEGRA_194_SOC=y
+CONFIG_ARCH_TEGRA_234_SOC=y
+CONFIG_TEGRA_KFUSE=y
+CONFIG_TEGRA_FUSE_BURN=y
+CONFIG_TEGRA_210_DVFS=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_POD_SCALING_V2=y
+CONFIG_DEVFREQ_GOV_WMARK_ACTIVE=y
+CONFIG_EXTCON_GPIO=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_MEMORY=y
+CONFIG_IIO=y
+CONFIG_HID_SENSOR_ACCEL_3D=m
+CONFIG_QCOM_SPMI_ADC5=m
+CONFIG_DS4424=m
+CONFIG_HID_SENSOR_GYRO_3D=m
+CONFIG_BMI088_IIO=m
+CONFIG_BMC150_MAGN=m
+CONFIG_BMC150_MAGN_I2C=m
+CONFIG_BMC150_MAGN_SPI=m
+CONFIG_NTB=m
+CONFIG_NTB_SWITCHTEC=m
+CONFIG_NTB_PINGPONG=m
+CONFIG_NTB_TOOL=m
+CONFIG_NTB_PERF=m
+CONFIG_NTB_TRANSPORT=m
+CONFIG_PWM=y
+CONFIG_PWM_TEGRA=y
+CONFIG_PWM_TEGRA_PMC_BLINK=m
+CONFIG_PWM_TEGRA_TACHOMETER=y
+CONFIG_PWM_TEGRA_DFLL=y
+CONFIG_PHY_FSL_IMX8MQ_USB=y
+CONFIG_PHY_TEGRA_XUSB=y
+CONFIG_ARM_SMMU_V3_PMU=m
+CONFIG_ARM_DSU_PMU=y
+CONFIG_ARM_SPE_PMU=y
+CONFIG_DAX=y
+CONFIG_FPGA=y
+CONFIG_FPGA_BRIDGE=m
+CONFIG_FPGA_REGION=m
+CONFIG_OF_FPGA_REGION=m
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_INTERCONNECT=y
+CONFIG_INTERCONNECT_TEGRA=y
+CONFIG_RTK_BTUSB=m
+CONFIG_NVPMODEL_EMC=y
+CONFIG_TEGRA_RDMA=m
+CONFIG_NVPPS=m
+CONFIG_TEGRA_HV_PM_CTL=y
+CONFIG_TEGRA_HV_MANAGER=y
+CONFIG_TEGRA_VIRTUALIZATION=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_QFMT_V2=m
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_ISO9660_FS=y
+CONFIG_OVERLAY_FS=m
+# CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW is not set
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_RAM=m
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_DISABLE_UDP_SUPPORT is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_CIFS=m
+CONFIG_9P_FS=m
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=m
+CONFIG_SECURITY_DMESG_RESTRICT=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_NETWORK=y
+CONFIG_HARDENED_USERCOPY=y
+CONFIG_FORTIFY_SOURCE=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_YAMA=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity,selinux,bpf"
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_DH=y
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_DEV_CCREE=m
+CONFIG_TEGRA_CRYPTO_DEV=y
+CONFIG_CRYPTO_DEV_TEGRA_SE=y
+CONFIG_CRYPTO_DEV_TEGRA_ELLIPTIC_SE=y
+CONFIG_CRYPTO_DEV_TEGRA_SE_USE_HOST1X_INTERFACE=y
+CONFIG_CRYPTO_DEV_TEGRA_VIRTUAL_SE_INTERFACE=y
+CONFIG_CRYPTO_DEV_TEGRA_SE_NVRNG=y
+CONFIG_CRYPTO_DEV_TEGRA_NVVSE=y
+CONFIG_CRYPTO_DEV_TEGRA_FDE=m
+# CONFIG_RAID6_PQ_BENCHMARK is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_CMA_ALIGNMENT=9
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG_CORE=y
+# CONFIG_SYMBOLIC_ERRNAME is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_FRAME_WARN=4096
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_WQ_WATCHDOG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DYNAMIC_FTRACE is not set
+CONFIG_STACK_TRACER=y
+# CONFIG_UPROBE_EVENTS is not set
+CONFIG_PID_IN_CONTEXTIDR=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 5ec3c683c..5ac7c6d4e 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -210,6 +210,13 @@ config NV_VIRTUAL_I2C_MUX
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called virtual_i2c_mux.
+
+config NV_VIDEO_ISX031
+	tristate "ISX031 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && I2C_IOEXPANDER_SER_MAX9295 && I2C_IOEXPANDER_DESER_MAX9296
+	help
+	  Video4Linux2 sensor-level driver for the Sony ISX031 camera sensor
+
 endmenu
 
 endif
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig.orig b/kernel/nvidia/drivers/media/i2c/Kconfig.orig
new file mode 100644
index 000000000..7f288faf7
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig.orig
@@ -0,0 +1,236 @@
+if VIDEO_V4L2
+
+menu "NVIDIA overlay Encoders, decoders, sensors and other helper chips"
+	visible if !MEDIA_SUBDRV_AUTOSELECT || COMPILE_TEST
+
+config NV_VIDEO_IMX185
+	tristate "IMX185 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	This is a Video4Linux2 sensor-level driver for the Sony
+	IMX185 camera sensor
+
+	To compile this driver as a module, choose M here: the module
+	will be called imx185.
+
+config NV_VIDEO_IMX477
+        tristate "IMX477 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports IMX477 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx477.
+
+config VIDEO_ECAM
+        tristate "ECAM camera sensor support"
+        depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+        help
+          This driver supports ECAM camera sensor from ECON
+
+          To compile this driver as a module, choose M here: the module
+          will be called ar1335.
+
+config NV_VIDEO_IMX219
+        tristate "IMX219 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports IMX219 camera sensor from Sony
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx219.
+
+config NV_VIDEO_IMX268
+	tristate "IMX268 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor-level driver for the Sony
+	  IMX268 camera sensor
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx268.
+
+config NV_VIDEO_IMX274
+	tristate "IMX274 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor-level driver for the Sony
+	  IMX274 camera sensor
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx274.
+
+config NV_VIDEO_IMX318
+	tristate "IMX318 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor-level driver for the Sony
+	  IMX318 camera sensor
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx318.
+
+config NV_VIDEO_LC898212
+	tristate "LC898212 focuser support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports LC898212 camera focuser
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called lc898212.
+
+config NV_VIDEO_OV5693
+	tristate "OV5693 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV5693 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov5693.
+
+config NV_VIDEO_OV9281
+	tristate "OmniVision OV9281 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor driver for the OmniVision
+	  OV9281 camera sensor, for use with the tegra isp.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov9281.
+
+config NV_VIDEO_OV10823
+	tristate "OmniVision OV10823 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor driver for the OmniVision
+	  OV10823 camera sensor, for use with the tegra isp.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov10823.
+
+config NV_VIDEO_OV23850
+	tristate "OmniVision OV23850 sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports OmniVision OV23850 camera sensor
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ov23850.
+
+config I2C_IOEXPANDER_PCA9570
+	tristate "nxp PCA9570 I2C IO Expander"
+	help
+	  If you say yes here you get support for the nxp PCA9570
+	  I2C IO Expander devices.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pca9570.
+
+config VIDEO_TC358840
+	tristate "Toshiba TC358840 decoder"
+	depends on VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API
+	select HDMI
+	help
+	  Support for the Toshiba TC358840 HDMI to MIPI CSI-2 bridge.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tc358840.
+
+config VIDEO_LT6911UXC
+        tristate "Lontium LTX6911UXC HDMI to CSI bridge"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports LT6911UXC bridge from Lontium
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called lt6911uxc.
+
+config I2C_IOEXPANDER_SER_MAX9295
+	tristate "MAX9295 Serializer I2C IO Expander"
+	help
+	  If you say yes here you get support for the MAX9295 serializer
+	  I2C IO Expander.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called max9295.
+
+config I2C_IOEXPANDER_DESER_MAX9296
+	tristate "MAX9296 Deserializer I2C IO Expander"
+	help
+	  If you say yes here you get support for the MAX9296 deserializer
+	  I2C IO Expander.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called max9296.
+
+config NV_VIDEO_IMX390
+	tristate "IMX390 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && I2C_IOEXPANDER_SER_MAX9295 && I2C_IOEXPANDER_DESER_MAX9296
+	help
+	  This is a Video4Linux2 sensor-level driver for the Sony
+	  IMX390 camera sensor
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called imx390.
+
+config NV_DESER_MAX96712
+
+	tristate "MAX92712 Deserializer"
+	help
+	  If you say yes here you get support for the MAX96712 deserializer.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called max96712.
+
+config NV_VIDEO_AR0234
+	tristate "AR0234 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor-level driver for the OnSemi
+	  AR0234 camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ar0234.
+
+config NV_VIDEO_HAWK_OWL
+	tristate "Hawk & Owl camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This is a Video4Linux2 sensor-level driver for the Hawk
+	   and Owl camera.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called hawk_owl.
+
+config NV_VIRTUAL_I2C_MUX
+	tristate "Virtual i2c mux support"
+	help
+	  This is a virtual i2c mux driver support for P3762/P3783.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called virtual_i2c_mux.
+
+config VIDEO_D4XX
+	tristate "D4XX camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+		This is a Video4Linux2 sensor-level driver for the Intel
+		D4XX depth camera sensor
+
+		To compile this driver as a module, choose M here: the module
+		will be called d4xx.
+
+config VIDEO_D4XX_SERDES
+	bool "D4XX camera sensor setup with Maxim Serdes"
+	depends on VIDEO_D4XX
+        default y
+	help
+		This is a Video4Linux2 sensor-level driver for the Intel
+		D4XX depth camera sensor
+
+                This option is for setup with Maxim Serdes.
+
+endmenu
+
+endif
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index c4708d8c7..8cdf742ac 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -27,3 +27,4 @@ obj-$(CONFIG_NV_VIDEO_HAWK_OWL) += nv_hawk_owl.o
 obj-$(CONFIG_NV_DESER_MAX96712) += max96712.o
 obj-$(CONFIG_VIDEO_ECAM) += ar1335.o
 ar1335-objs :=  ar1335_common.o
+obj-$(CONFIG_NV_VIDEO_ISX031) += isx031/
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile.orig b/kernel/nvidia/drivers/media/i2c/Makefile.orig
new file mode 100644
index 000000000..e11e8ad39
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/Makefile.orig
@@ -0,0 +1,30 @@
+subdir-ccflags-y += -Werror
+
+ccflags-y += -I$(srctree)/drivers/media/platform/tegra
+ccflags-y += -I$(srctree)/drivers/video/tegra/camera
+
+obj-$(CONFIG_NV_VIDEO_IMX185) += nv_imx185.o
+obj-$(CONFIG_NV_VIDEO_IMX185) += nv_imx185_v1.o
+obj-$(CONFIG_NV_VIDEO_IMX477) += nv_imx477.o
+obj-$(CONFIG_NV_VIDEO_IMX219) += nv_imx219.o
+obj-$(CONFIG_NV_VIDEO_IMX268) += nv_imx268.o
+obj-$(CONFIG_NV_VIDEO_IMX274) += nv_imx274.o
+obj-$(CONFIG_NV_VIDEO_IMX318) += nv_imx318.o
+obj-$(CONFIG_NV_VIDEO_LC898212) += nv_lc898212.o
+obj-$(CONFIG_NV_VIDEO_OV5693) += nv_ov5693.o
+obj-$(CONFIG_NV_VIDEO_OV9281) += nv_ov9281.o
+obj-$(CONFIG_NV_VIDEO_OV10823) += nv_ov10823.o
+obj-$(CONFIG_NV_VIDEO_OV23850) += nv_ov23850.o
+obj-$(CONFIG_I2C_IOEXPANDER_PCA9570) += pca9570.o
+obj-$(CONFIG_VIDEO_TC358840) += tc358840.o
+obj-$(CONFIG_VIDEO_LT6911UXC) +=lt6911uxc.o
+obj-$(CONFIG_I2C_IOEXPANDER_SER_MAX9295) += max9295.o
+obj-$(CONFIG_I2C_IOEXPANDER_DESER_MAX9296) += max9296.o
+obj-$(CONFIG_NV_VIDEO_IMX390) += nv_imx390.o
+obj-$(CONFIG_NV_VIDEO_AR0234) += nv_ar0234.o
+obj-$(CONFIG_NV_VIRTUAL_I2C_MUX) += virtual_i2c_mux.o
+obj-$(CONFIG_NV_VIDEO_HAWK_OWL) += nv_hawk_owl.o
+obj-$(CONFIG_NV_DESER_MAX96712) += max96712.o
+obj-$(CONFIG_VIDEO_ECAM) += ar1335.o
+ar1335-objs :=  ar1335_common.o
+obj-$(CONFIG_VIDEO_D4XX) += d4xx.o
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/Makefile b/kernel/nvidia/drivers/media/i2c/isx031/Makefile
new file mode 100644
index 000000000..526951283
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/Makefile
@@ -0,0 +1,8 @@
+subdir-ccflags-y += -Werror
+
+ccflags-y += -I$(srctree)/drivers/media/platform/tegra
+ccflags-y += -I$(srctree)/drivers/video/tegra/camera
+
+obj-y += serdes.o serdesa.o
+obj-m += fzcam.o
+obj-m += fzcama.o
\ No newline at end of file
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c b/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
new file mode 100644
index 000000000..89a5dc277
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
@@ -0,0 +1,819 @@
+/*
+ * sgcam.c - sgcam sensor driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include "fzcam_mode_tbls.h"
+
+//#define USE_RESET_GPIO
+#define SGCAM_DEFAULT_MODE		SGCAM_MODE_1920X1536_CROP_30FPS
+#define SGCAM_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_1X16
+
+
+#define SGCAM_DEFAULT_WIDTH		1920
+#define SGCAM_DEFAULT_HEIGHT	1536
+#define SGCAM_DEFAULT_CLK_FREQ	37125000
+
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define sgcam_subdev camera_common_data
+#else
+struct sgcam_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct sgcam {
+	int 	channel;
+	u32					sensor_def_addr;
+	u32					sensor_map_addr;
+	struct 	camera_common_power_rail	power;
+	int		numctrls;
+	struct 	v4l2_ctrl_handler	ctrl_handler;
+	struct 	i2c_client	*i2c_client;
+	struct 	v4l2_subdev	*subdev;
+	struct 	sgcam_subdev sd;
+	struct 	media_pad	pad;
+	u32				frame_length;
+	s32		group_hold_prev;
+	bool	group_hold_en;
+	s64 	last_wdr_et_val;
+	struct regmap	*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	.use_single_rw = true,
+#else
+	.use_single_read = true,
+	.use_single_write = true,
+#endif
+};
+
+static int sgcam_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int sgcam_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static const struct v4l2_ctrl_ops sgcam_ctrl_ops = {
+	.g_volatile_ctrl = sgcam_g_volatile_ctrl,
+	.s_ctrl = sgcam_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+};
+
+static inline void sgcam_get_frame_length_regs(sgcam_reg *regs,
+				u32 frame_length)
+{
+	return;
+}
+
+static inline void sgcam_get_coarse_time_regs_shs1(sgcam_reg *regs,
+				u32 coarse_time)
+{
+	return ;
+}
+
+static inline void sgcam_get_coarse_time_regs_shs2(sgcam_reg *regs,
+				u32 coarse_time)
+{
+	return; 
+}
+
+static inline void sgcam_get_gain_reg(sgcam_reg *regs,
+				u8 gain)
+{
+
+}
+
+static inline int sgcam_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int sgcam_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct device *dev = &priv->i2c_client->dev;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int sgcam_write_table(struct sgcam *priv,
+		const sgcam_reg table[])
+{		
+	return 0;
+	
+	/*
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 sgcam_TABLE_WAIT_MS,
+					 sgcam_TABLE_END);
+	*/
+}
+
+static int sgcam_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	
+#ifdef USE_RESET_GPIO
+	/*exit reset mode: XCLR */
+	if (pw->reset_gpio) {
+		gpio_set_value(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_set_value(pw->reset_gpio, 1);
+		usleep_range(30, 50);
+	}
+#endif
+
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int sgcam_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err)
+			goto power_off_done;
+		else
+			dev_err(dev, "%s failed.\n", __func__);
+		return err;
+	}
+#ifdef USE_RESET_GPIO
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_set_value(pw->reset_gpio, 0);
+#endif
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int sgcam_power_get(struct sgcam *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	#ifdef USE_RESET_GPIO
+	struct camera_common_pdata *pdata = priv->pdata;
+	#endif
+	struct device *dev = &priv->i2c_client->dev;
+	const char *mclk_name;
+	struct clk *parent;
+	int err = 0;
+
+	mclk_name = priv->pdata->mclk_name ?
+		    priv->pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
+
+#ifdef USE_RESET_GPIO
+	pw->reset_gpio = pdata->reset_gpio;
+#endif
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+static int sgcam_set_gain(struct sgcam *priv, s64 val);
+static int sgcam_set_frame_rate(struct sgcam *priv, s64 val);
+static int sgcam_set_exposure(struct sgcam *priv, s64 val);
+
+/* Video ops */
+static int sgcam_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static int sgcam_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+static int sgcam_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	int err = 0;
+
+	dev_dbg(dev, "%s++ enable %d\n", __func__, enable);
+
+	if (!enable) {
+		err = sgcam_write_table(priv, mode_table[SGCAM_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+		else 
+			return 0;
+	}
+
+	err = sgcam_write_table(priv, mode_table[SGCAM_MODE_START_STREAM]);
+	if (err)
+		return err;
+	else
+		return 0;
+}
+
+static int sgcam_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops sgcam_subdev_video_ops = {
+	.g_frame_interval	= sgcam_g_frame_interval,
+	.s_frame_interval	= sgcam_s_frame_interval,
+	.s_stream	= sgcam_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = sgcam_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops sgcam_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int sgcam_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int sgcam_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	int ret = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops sgcam_subdev_pad_ops = {
+	.set_fmt = sgcam_set_fmt,
+	.get_fmt = sgcam_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.get_mbus_config	= camera_common_get_mbus_config,
+#endif
+};
+
+static struct v4l2_subdev_ops sgcam_subdev_ops = {
+	.core	= &sgcam_subdev_core_ops,
+	.video	= &sgcam_subdev_video_ops,
+	.pad = &sgcam_subdev_pad_ops,
+};
+
+const static struct of_device_id sgcam_of_match[] = {
+	{ .compatible = "nvidia,fzcam",},
+	{ },
+};
+
+static struct camera_common_sensor_ops sgcam_common_ops = {
+	.power_on = sgcam_power_on,
+	.power_off = sgcam_power_off,
+	.write_reg = sgcam_write_reg,
+	.read_reg = sgcam_read_reg,
+};
+
+static int sgcam_set_group_hold(struct sgcam *priv, s32 val)
+{
+	return 0;
+}
+
+static int sgcam_set_gain(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcam_set_frame_rate(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcam_set_exposure(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+
+static int sgcam_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcam *priv =
+		container_of(ctrl->handler, struct sgcam, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+
+	default:
+			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcam_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcam *priv =
+		container_of(ctrl->handler, struct sgcam, ctrl_handler);
+	struct camera_common_data	*s_data = priv->s_data;
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = sgcam_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		err = sgcam_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		err = sgcam_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		err = sgcam_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		s_data->sensor_mode_id = (int) (*ctrl->p_new.p_s64);
+		break;
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcam_ctrls_init(struct sgcam *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err = 0;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = num_ctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, sgcam_of_match);
+
+static struct camera_common_pdata *sgcam_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err = 0;
+	const char *str;
+	
+	#ifdef USE_RESET_GPIO
+	int gpio;
+	#endif
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(sgcam_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(&client->dev, "mclk not in DT\n");
+
+#ifdef USE_RESET_GPIO
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+#endif
+
+	return board_priv_pdata;
+}
+
+static int sgcam_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops sgcam_subdev_internal_ops = {
+	.open = sgcam_open,
+};
+
+static const struct media_entity_operations sgcam_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int sgcam_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct sgcam *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "probing fzcam v4l2 sensor\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct sgcam) + sizeof(struct v4l2_ctrl *),
+			    GFP_KERNEL);
+
+	if (!priv) {
+		dev_err(&client->dev, "unable to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_dbg(&client->dev, "channel not found\n");
+		
+	err = device_property_read_u32(&client->dev, "reg", &priv->sensor_map_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "reg not found\n");
+		priv->sensor_map_addr = 0x00;
+	}
+
+	err = device_property_read_u32(&client->dev,  "def-addr", &priv->sensor_def_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "def-addr not found\n");
+		priv->sensor_def_addr = 0x00;
+	}
+	
+	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = sgcam_parse_dt(client, common_data);
+
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &sgcam_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &sgcam_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  SGCAM_DEFAULT_DATAFMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = (void *)priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(sgcam_frmfmt);
+	common_data->def_mode = SGCAM_DEFAULT_MODE;
+	common_data->def_width = SGCAM_DEFAULT_WIDTH;
+	common_data->def_height = SGCAM_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = SGCAM_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	priv->last_wdr_et_val = 0;
+
+	err = sgcam_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "sgcam");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize sgcam.\n");
+		return err;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &sgcam_subdev_ops);
+
+	err = sgcam_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &sgcam_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		     V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &sgcam_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1,
+				&priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_info(&client->dev, "Detected Sensor\n");
+
+	return 0;
+}
+
+static int
+sgcam_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+static const struct i2c_device_id sgcam_id[] = {
+	{ "fzcam", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sgcam_id);
+
+static struct i2c_driver sgcam_i2c_driver = {
+	.driver = {
+		.name = "fzcam",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(sgcam_of_match),
+	},
+	.probe = sgcam_probe,
+	.remove = sgcam_remove,
+	.id_table = sgcam_id,
+};
+
+module_i2c_driver(sgcam_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sensing-World MAXIM GMSL");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
new file mode 100644
index 000000000..a6f605a46
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
@@ -0,0 +1,78 @@
+/*
+ * SGCAM_mode_tbls.h - fzcam sensor mode tables
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __SGCAM_I2C_TABLES__
+#define __SGCAM_I2C_TABLES__
+
+#include <media/camera_common.h>
+#include <linux/miscdevice.h>
+
+#define SGCAM_TABLE_WAIT_MS	0
+#define SGCAM_TABLE_END		1
+#define SGCAM_MAX_RETRIES	3
+#define SGCAM_WAIT_MS_STOP	1
+#define SGCAM_WAIT_MS_START	30
+#define SGCAM_WAIT_MS_STREAM	210
+#define SGCAM_GAIN_TABLE_SIZE 255
+
+#define sgcam_reg struct reg_8
+
+static sgcam_reg SGCAM_start[] = {
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_START},
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_STREAM},
+	{SGCAM_TABLE_END, 0x00}
+};
+
+static sgcam_reg SGCAM_stop[] = {
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_STOP},
+	{SGCAM_TABLE_END, 0x00}
+};
+
+static sgcam_reg SGCAM_1920x1536_crop_30fps[] = {
+
+	{SGCAM_TABLE_END, 0x00},
+};
+
+enum {
+	SGCAM_MODE_1920X1536_CROP_30FPS,
+	SGCAM_MODE_START_STREAM,
+	SGCAM_MODE_STOP_STREAM,
+};
+
+static sgcam_reg *mode_table[] = {
+	[SGCAM_MODE_1920X1536_CROP_30FPS]
+		= SGCAM_1920x1536_crop_30fps,
+	[SGCAM_MODE_START_STREAM]
+		= SGCAM_start,
+	[SGCAM_MODE_STOP_STREAM]
+		= SGCAM_stop,
+};
+
+static const int SGCAM_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in device tree!
+ */
+static const struct camera_common_frmfmt sgcam_frmfmt[] = {
+	{{1920, 1536}, SGCAM_30fps, 1, 0, SGCAM_MODE_1920X1536_CROP_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __SGCAM_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c b/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
new file mode 100644
index 000000000..13d07833e
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
@@ -0,0 +1,819 @@
+/*
+ * sgcama.c - sgcama sensor driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include "fzcama_mode_tbls.h"
+
+//#define USE_RESET_GPIO
+#define SGCAMA_DEFAULT_MODE		SGCAMA_MODE_1920X1536_CROP_30FPS
+#define SGCAMA_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_1X16
+
+
+#define SGCAMA_DEFAULT_WIDTH	1920
+#define SGCAMA_DEFAULT_HEIGHT	1536
+#define SGCAMA_DEFAULT_CLK_FREQ	37125000
+
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define sgcama_subdev camera_common_data
+#else
+struct sgcama_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct sgcama {
+	int 	channel;
+	u32					sensor_def_addr;
+	u32					sensor_map_addr;
+	struct 	camera_common_power_rail	power;
+	int		numctrls;
+	struct 	v4l2_ctrl_handler	ctrl_handler;
+	struct 	i2c_client	*i2c_client;
+	struct 	v4l2_subdev	*subdev;
+	struct 	sgcama_subdev sd;
+	struct 	media_pad	pad;
+	u32				frame_length;
+	s32		group_hold_prev;
+	bool	group_hold_en;
+	s64 	last_wdr_et_val;
+	struct regmap	*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	.use_single_rw = true,
+#else
+	.use_single_read = true,
+	.use_single_write = true,
+#endif
+};
+
+static int sgcama_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int sgcama_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static const struct v4l2_ctrl_ops sgcama_ctrl_ops = {
+	.g_volatile_ctrl = sgcama_g_volatile_ctrl,
+	.s_ctrl = sgcama_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+};
+
+static inline void sgcama_get_frame_length_regs(sgcama_reg *regs,
+				u32 frame_length)
+{
+	return;
+}
+
+static inline void sgcama_get_coarse_time_regs_shs1(sgcama_reg *regs,
+				u32 coarse_time)
+{
+	return ;
+}
+
+static inline void sgcama_get_coarse_time_regs_shs2(sgcama_reg *regs,
+				u32 coarse_time)
+{
+	return; 
+}
+
+static inline void sgcama_get_gain_reg(sgcama_reg *regs,
+				u8 gain)
+{
+
+}
+
+static inline int sgcama_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int sgcama_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct device *dev = &priv->i2c_client->dev;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int sgcama_write_table(struct sgcama *priv,
+		const sgcama_reg table[])
+{		
+	return 0;
+	
+	/*
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 SGCAMAA_TABLE_WAIT_MS,
+					 SGCAMAA_TABLE_END);
+	*/
+}
+
+static int sgcama_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	
+#ifdef USE_RESET_GPIO
+	/*exit reset mode: XCLR */
+	if (pw->reset_gpio) {
+		gpio_set_value(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_set_value(pw->reset_gpio, 1);
+		usleep_range(30, 50);
+	}
+#endif
+
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int sgcama_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err)
+			goto power_off_done;
+		else
+			dev_err(dev, "%s failed.\n", __func__);
+		return err;
+	}
+#ifdef USE_RESET_GPIO
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_set_value(pw->reset_gpio, 0);
+#endif
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int sgcama_power_get(struct sgcama *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	#ifdef USE_RESET_GPIO
+	struct camera_common_pdata *pdata = priv->pdata;
+	#endif
+	struct device *dev = &priv->i2c_client->dev;
+	const char *mclk_name;
+	struct clk *parent;
+	int err = 0;
+
+	mclk_name = priv->pdata->mclk_name ?
+		    priv->pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
+
+#ifdef USE_RESET_GPIO
+	pw->reset_gpio = pdata->reset_gpio;
+#endif
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+static int sgcama_set_gain(struct sgcama *priv, s64 val);
+static int sgcama_set_frame_rate(struct sgcama *priv, s64 val);
+static int sgcama_set_exposure(struct sgcama *priv, s64 val);
+
+/* Video ops */
+static int sgcama_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static int sgcama_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+static int sgcama_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	int err = 0;
+
+	dev_dbg(dev, "%s++ enable %d\n", __func__, enable);
+
+	if (!enable) {
+		err = sgcama_write_table(priv, mode_table[SGCAMA_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+		else 
+			return 0;
+	}
+
+	err = sgcama_write_table(priv, mode_table[SGCAMA_MODE_START_STREAM]);
+	if (err)
+		return err;
+	else
+		return 0;
+}
+
+static int sgcama_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops sgcama_subdev_video_ops = {
+	.g_frame_interval	= sgcama_g_frame_interval,
+	.s_frame_interval	= sgcama_s_frame_interval,
+	.s_stream	= sgcama_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = sgcama_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops sgcama_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int sgcama_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int sgcama_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	int ret = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops sgcama_subdev_pad_ops = {
+	.set_fmt = sgcama_set_fmt,
+	.get_fmt = sgcama_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.get_mbus_config	= camera_common_get_mbus_config,
+#endif
+};
+
+static struct v4l2_subdev_ops sgcama_subdev_ops = {
+	.core	= &sgcama_subdev_core_ops,
+	.video	= &sgcama_subdev_video_ops,
+	.pad = &sgcama_subdev_pad_ops,
+};
+
+const static struct of_device_id sgcama_of_match[] = {
+	{ .compatible = "nvidia,fzcama",},
+	{ },
+};
+
+static struct camera_common_sensor_ops sgcama_common_ops = {
+	.power_on = sgcama_power_on,
+	.power_off = sgcama_power_off,
+	.write_reg = sgcama_write_reg,
+	.read_reg = sgcama_read_reg,
+};
+
+static int sgcama_set_group_hold(struct sgcama *priv, s32 val)
+{
+	return 0;
+}
+
+static int sgcama_set_gain(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcama_set_frame_rate(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcama_set_exposure(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+
+static int sgcama_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcama *priv =
+		container_of(ctrl->handler, struct sgcama, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+
+	default:
+			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcama_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcama *priv =
+		container_of(ctrl->handler, struct sgcama, ctrl_handler);
+	struct camera_common_data	*s_data = priv->s_data;
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = sgcama_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		err = sgcama_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		err = sgcama_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		err = sgcama_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		s_data->sensor_mode_id = (int) (*ctrl->p_new.p_s64);
+		break;
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcama_ctrls_init(struct sgcama *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err = 0;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = num_ctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, sgcama_of_match);
+
+static struct camera_common_pdata *sgcama_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err = 0;
+	const char *str;
+	
+	#ifdef USE_RESET_GPIO
+	int gpio;
+	#endif
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(sgcama_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(&client->dev, "mclk not in DT\n");
+
+#ifdef USE_RESET_GPIO
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+#endif
+
+	return board_priv_pdata;
+}
+
+static int sgcama_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops sgcama_subdev_internal_ops = {
+	.open = sgcama_open,
+};
+
+static const struct media_entity_operations sgcama_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int sgcama_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct sgcama *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "probing sgcama v4l2 sensor\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct sgcama) + sizeof(struct v4l2_ctrl *),
+			    GFP_KERNEL);
+
+	if (!priv) {
+		dev_err(&client->dev, "unable to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_dbg(&client->dev, "channel not found\n");
+		
+	err = device_property_read_u32(&client->dev, "reg", &priv->sensor_map_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "reg not found\n");
+		priv->sensor_map_addr = 0x00;
+	}
+
+	err = device_property_read_u32(&client->dev,  "def-addr", &priv->sensor_def_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "def-addr not found\n");
+		priv->sensor_def_addr = 0x00;
+	}
+	
+	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = sgcama_parse_dt(client, common_data);
+
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &sgcama_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &sgcama_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  SGCAMA_DEFAULT_DATAFMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = (void *)priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(sgcama_frmfmt);
+	common_data->def_mode = SGCAMA_DEFAULT_MODE;
+	common_data->def_width = SGCAMA_DEFAULT_WIDTH;
+	common_data->def_height = SGCAMA_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = SGCAMA_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	priv->last_wdr_et_val = 0;
+
+	err = sgcama_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "sgcama");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize sgcama.\n");
+		return err;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &sgcama_subdev_ops);
+
+	err = sgcama_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &sgcama_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		     V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &sgcama_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1,
+				&priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_info(&client->dev, "Detected Sensor\n");
+
+	return 0;
+}
+
+static int
+sgcama_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+static const struct i2c_device_id sgcama_id[] = {
+	{ "fzcama", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sgcama_id);
+
+static struct i2c_driver sgcama_i2c_driver = {
+	.driver = {
+		.name = "fzcama",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(sgcama_of_match),
+	},
+	.probe = sgcama_probe,
+	.remove = sgcama_remove,
+	.id_table = sgcama_id,
+};
+
+module_i2c_driver(sgcama_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sensing-World MAXIM GMSL");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
new file mode 100644
index 000000000..f93dd2365
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
@@ -0,0 +1,78 @@
+/*
+ * sgcama_mode_tbls.h - sgcama sensor mode tables
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __SGCAMA_I2C_TABLES__
+#define __SGCAMA_I2C_TABLES__
+
+#include <media/camera_common.h>
+#include <linux/miscdevice.h>
+
+#define SGCAMA_TABLE_WAIT_MS	0
+#define SGCAMA_TABLE_END		1
+#define SGCAMA_MAX_RETRIES	3
+#define SGCAMA_WAIT_MS_STOP	1
+#define SGCAMA_WAIT_MS_START	30
+#define SGCAMA_WAIT_MS_STREAM	210
+#define SGCAMA_GAIN_TABLE_SIZE 255
+
+#define sgcama_reg struct reg_8
+
+static sgcama_reg sgcama_start[] = {
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_START},
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_STREAM},
+	{SGCAMA_TABLE_END, 0x00}
+};
+
+static sgcama_reg sgcama_stop[] = {
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_STOP},
+	{SGCAMA_TABLE_END, 0x00}
+};
+
+static sgcama_reg sgcama_1920x1536_crop_30fps[] = {
+
+	{SGCAMA_TABLE_END, 0x00},
+};
+
+enum {
+	SGCAMA_MODE_1920X1536_CROP_30FPS,
+	SGCAMA_MODE_START_STREAM,
+	SGCAMA_MODE_STOP_STREAM,
+};
+
+static sgcama_reg *mode_table[] = {
+	[SGCAMA_MODE_1920X1536_CROP_30FPS]
+		= sgcama_1920x1536_crop_30fps,
+	[SGCAMA_MODE_START_STREAM]
+		= sgcama_start,
+	[SGCAMA_MODE_STOP_STREAM]
+		= sgcama_stop,
+};
+
+static const int sgcama_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in device tree!
+ */
+static const struct camera_common_frmfmt sgcama_frmfmt[] = {
+	{{1920, 1536}, sgcama_30fps, 1, 0, SGCAMA_MODE_1920X1536_CROP_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __SGCAMA_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdes.c b/kernel/nvidia/drivers/media/i2c/isx031/serdes.c
new file mode 100644
index 000000000..485c913fd
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdes.c
@@ -0,0 +1,369 @@
+/*
+ * serdes.c - serdes GMSL Expander driver
+ *
+ * Copyright (c) 2021, Fangzhu Tech Corp. All rights reserved.
+ * Based on Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include "serdes.h"
+
+#define SERDES_MODULE_VERSION "1.0.0.0"
+
+#define IS_LINK     (1)
+#define NO_LINK     (0)
+#define SENYUN_ISX031  (0)
+#define SENYUN_ISX031F (1)
+
+struct serdes {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct gpio_desc *pwdn_gpio;
+	int channel;
+	int camA_type, camB_type; //0=Senyun ISX031, 1=Senyun ISX031F(need mfp8 trigger)
+	unsigned char linka,linkb; //0x45, 0x46
+};
+struct serdes *global_priv[2];
+
+#define DBG
+//#define DBG_REG
+static int Deser_write_reg(int channel, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err;
+	int addr_bak;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priv[channel]->i2c_client;
+
+	if(slave_addr != DESERILIAER_ADDR) {
+		addr_bak = global_priv[channel]->i2c_client->addr;
+		global_priv[channel]->i2c_client->addr = slave_addr;
+	}
+	err = regmap_write(global_priv[channel]->regmap, reg, val);
+	#ifdef DBG_REG
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, reg, val);
+	#endif
+
+	if(slave_addr != DESERILIAER_ADDR)
+		global_priv[channel]->i2c_client->addr = addr_bak;
+	usleep_range(200, 500);
+	#ifdef DBG_REG
+	dev_info(&i2c_client->dev, "Serdes [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, slave_addr, reg, val );
+	#endif
+	return err;
+}
+
+int Deser_write_reg_list(int channel, struct deser_reg *table, int size)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err = 0, i;
+	u8 slave_addr;
+	u16 reg;
+	u16 val;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priv[channel]->i2c_client;
+	
+	for(i=0; i<size; i++)
+	{
+		slave_addr = table[i].slave_addr;
+		reg = table[i].reg;
+		val = table[i].val;
+		
+		if(global_priv[channel]->linka == IS_LINK && global_priv[channel]->linkb == NO_LINK){
+		    /* Only Port A Link */
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x21)
+		    {
+		        val = 0x31;
+		    }
+		    if(slave_addr == SERILIAER_ADDR && reg == 0x0000 && val == (SERILIAER_ADDR_B << 1))
+		    {
+		        continue;
+		    }
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x23)
+		    {
+		        /* disable split mode */
+		        continue;
+		    }
+		    if(slave_addr == SERILIAER_ADDR_B){
+		        /* skip configure port B */
+		        continue;
+		    }
+		}
+		else if(global_priv[channel]->linka == NO_LINK && global_priv[channel]->linkb == IS_LINK)
+		{
+		    /* Only Port B Link */
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x21)
+		    {
+		        val = 0x32;
+		    }
+		    if(slave_addr == SERILIAER_ADDR && reg == 0x0000 && val == (SERILIAER_ADDR_A << 1))
+		    {
+		        continue;
+		    }
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x23)
+		    {
+		        /* disable split mode */
+		        continue;
+		    }
+		    if(slave_addr == SERILIAER_ADDR_A){
+		        /* skip configure port A */
+		        continue;
+		    }
+		}
+		else if(global_priv[channel]->linka == NO_LINK && global_priv[channel]->linkb == NO_LINK)
+		{
+		    /* No Port Link */
+		    return 0;
+		}
+		if(slave_addr == GMSL_ADDR) {
+			//dev_info(&i2c_client->dev, "mdelay = %d(ms)\n", val);
+			msleep(val);
+		}
+        else if(slave_addr == SERILIAER_ADDR && reg == 0x0000)
+        {
+            err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+            if(err){
+                slave_addr = (val >> 1); 
+                err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+                if(err){
+                    dev_dbg(&i2c_client->dev, "MAX929x Write failed [0x%02x]:[0x%04x=0x%02x]\n", slave_addr, reg, val);
+                    return err;
+                }
+            }
+        }
+		else
+			err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+
+		if(err!=0)
+			break;
+	}
+
+	return err;
+}
+
+static  struct regmap_config deser_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int Deser_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device dev = client->dev;
+	struct serdes *priv;
+	int err;
+
+	dev_dbg(&dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &deser_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pwdn_gpio = devm_gpiod_get(&client->dev, "pwdn", GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwdn_gpio)) {
+		//dev_info(&dev, "get pwdn value :%d\n", gpiod_get_value(priv->pwdn_gpio));
+		//gpiod_set_value(priv->pwdn_gpio, false);
+		//msleep(200);
+		gpiod_set_value(priv->pwdn_gpio, true);
+		msleep(200);
+	}
+	
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_err(&dev, "channel not found\n");
+	
+	global_priv[priv->channel] = priv;
+	
+	//Set MAX9296 3Gbps
+	err = Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0313, 0x00); 	//disable csi output
+	if (err) {
+		dev_err(&dev, "%s: fail\n", __func__);
+		return 0;
+	}
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0005, 0x80); //LOCK output enabled, disable the others
+	
+	/*detect GMSL Link A */
+	priv->camA_type = SENYUN_ISX031;
+	priv->linka = IS_LINK;
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21);
+	mdelay(200);
+	err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_A<<1);
+	if (err) {
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0006, 0xDF);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x01);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21);
+
+		mdelay(200);
+		priv->camA_type = SENYUN_ISX031F;
+		err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_A<<1);
+		if (err) {
+			priv->camA_type = SENYUN_ISX031;
+			priv->linka = NO_LINK;
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*2);
+			#endif
+		}
+		else {
+			priv->linka = IS_LINK;
+			if(priv->camA_type == SENYUN_ISX031F)
+				err = Deser_write_reg_list(priv->channel, SG_linkA_SY_ISX031F_Ser_init,
+					sizeof(SG_linkA_SY_ISX031F_Ser_init)/sizeof(struct deser_reg));
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2, priv->camB_type);
+			#endif
+		}
+	}
+	else {
+		priv->linka = IS_LINK;
+			if(priv->camA_type == SENYUN_ISX031)
+				err = Deser_write_reg_list(priv->channel, SG_linkA_SY_ISX031_Ser_init,
+					sizeof(SG_linkA_SY_ISX031_Ser_init)/sizeof(struct deser_reg));
+		#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2, priv->camA_type);
+		#endif
+	}
+	
+	/*detect GMSL Link B */
+	priv->camB_type = SENYUN_ISX031;
+	priv->linkb = IS_LINK;
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x22);
+	mdelay(200);
+	err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_B<<1);
+	if (err) {
+		priv->camB_type = SENYUN_ISX031F;
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0006, 0xDF);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x01);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x22);
+		mdelay(200);
+		err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_B<<1);
+		if (err) {
+			priv->camB_type = SENYUN_ISX031;
+			priv->linkb = NO_LINK;
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21); //switch to linkA
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*2+1);
+			#endif
+		}
+		else {
+			priv->linkb = IS_LINK;
+			if(priv->camB_type == SENYUN_ISX031F)
+				err = Deser_write_reg_list(priv->channel, SG_linkB_SY_ISX031F_Ser_init,
+					sizeof(SG_linkB_SY_ISX031F_Ser_init)/sizeof(struct deser_reg));
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2+1, priv->camB_type);
+			#endif
+		}
+	}
+	else {
+		priv->linkb = IS_LINK;
+		if(priv->camB_type == SENYUN_ISX031)
+			err = Deser_write_reg_list(priv->channel, SG_linkB_SY_ISX031_Ser_init,
+				sizeof(SG_linkB_SY_ISX031_Ser_init)/sizeof(struct deser_reg));
+		#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2+1, priv->camA_type);
+		#endif
+	}
+	if(priv->linka == IS_LINK || priv->linkb == IS_LINK) {
+		err = Deser_write_reg_list(priv->channel, SG_Deser_MAX9296_init,
+				sizeof(SG_Deser_MAX9296_init)/sizeof(struct deser_reg));
+	}
+
+	return 0;
+}
+
+int Deser_lock(int channel)
+{
+	if(global_priv[channel]->linka == IS_LINK || global_priv[channel]->linkb == IS_LINK)
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(Deser_lock);
+
+static int Deser_remove(struct i2c_client *client)
+{
+	if (client != NULL) {
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id Deser_id[] = {
+	{ "serdes", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, Deser_id);
+
+const struct of_device_id Deser_of_match[] = {
+	{ .compatible = "nvidia,serdes", },
+	{ },
+};
+
+static struct i2c_driver Deser_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "serdes",
+		.of_match_table = of_match_ptr(Deser_of_match),
+	},
+	.probe = Deser_probe,
+	.remove = Deser_remove,
+	.id_table = Deser_id,
+};
+
+static int __init Deser_init(void)
+{
+	return i2c_add_driver(&Deser_i2c_driver);
+}
+
+static void __exit Deser_exit(void)
+{
+	i2c_del_driver(&Deser_i2c_driver);
+}
+
+module_init(Deser_init);
+module_exit(Deser_exit);
+
+MODULE_DESCRIPTION("IO Expander Driver MAX9296 Sensing-World");
+MODULE_AUTHOR("Sensing-World Tech Corporation");
+MODULE_VERSION(SERDES_MODULE_VERSION);
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdes.h b/kernel/nvidia/drivers/media/i2c/isx031/serdes.h
new file mode 100644
index 000000000..e4ae6ddd2
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdes.h
@@ -0,0 +1,196 @@
+#ifndef __SERDES_H__
+#define __SERDES_H__
+
+#define GMSL_TABLE_END 0xffff
+#define GMSL_WAIT_MS 0x55
+#define GMSL_ADDR 0x08
+
+struct deser_reg
+{
+	u16 slave_addr;
+	u16 reg;
+	u16 val;
+};
+
+#define DESERILIAER_ADDR    0x48
+#define SERILIAER_ADDR      0x62
+#define SERILIAER_ADDR_A    0x41
+#define SERILIAER_ADDR_B    0x42
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkA_SY_ISX031_Ser_init[] = {
+	{SERILIAER_ADDR_A, 0x0010, 0x21},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+
+	{SERILIAER_ADDR_A, 0x006b, 0x16},
+	{SERILIAER_ADDR_A, 0x0073, 0x17},
+	{SERILIAER_ADDR_A, 0x007b, 0x36},
+	{SERILIAER_ADDR_A, 0x0083, 0x36},
+	{SERILIAER_ADDR_A, 0x008b, 0x36},
+	{SERILIAER_ADDR_A, 0x0093, 0x36},
+	{SERILIAER_ADDR_A, 0x009b, 0x36},
+	{SERILIAER_ADDR_A, 0x00a3, 0x36},
+	{SERILIAER_ADDR_A, 0x00ab, 0x36},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x02be, 0x10},
+	{SERILIAER_ADDR_A, 0x02d3, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 500},
+
+	// {SERILIAER_ADDR_A, 0x02d3, 0x00},
+	{SERILIAER_ADDR_A, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 300},
+	{SERILIAER_ADDR_A, 0x0308, 0x62},
+	{SERILIAER_ADDR_A, 0x0311, 0xF0}, //Start Video Pipeline on CSI PortB
+	{SERILIAER_ADDR_A, 0x0316, 0x5E}, //Set DT
+	{SERILIAER_ADDR_A, 0x0318, 0x62},
+	{SERILIAER_ADDR_A, 0x0002, 0xF3}, //Turn on all pipeline
+	// {SERILIAER_ADDR_A, 0x02d3, 0x84},
+	// {SERILIAER_ADDR_A, 0x02d5, 0x07},
+	{SERILIAER_ADDR_A, 0x02d6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{SERILIAER_ADDR_A, 0x02d6, 0x84},
+	{SERILIAER_ADDR_A, 0x02d8, 0x07}, // mfp8 trigger
+
+};
+
+static struct deser_reg SG_linkA_SY_ISX031F_Ser_init[] = {
+	{SERILIAER_ADDR_A, 0x02d3, 0x00},
+	{SERILIAER_ADDR_A, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+	{SERILIAER_ADDR_A, 0x02d3, 0x10},
+	//{SERILIAER_ADDR_A, 0x02d3, 0x84},
+	{SERILIAER_ADDR_A, 0x02d5, 0x07}, // mfp7 trigger
+	{SERILIAER_ADDR_A, 0x02d6, 0x10},
+	//{SERILIAER_ADDR_A, 0x02d6, 0x84},
+	{SERILIAER_ADDR_A, 0x02d8, 0x07}, // mfp8 trigger
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x006b, 0x16},
+	{SERILIAER_ADDR_A, 0x0073, 0x17},
+	{SERILIAER_ADDR_A, 0x007b, 0x36},
+	{SERILIAER_ADDR_A, 0x0083, 0x36},
+	{SERILIAER_ADDR_A, 0x008b, 0x36},
+	{SERILIAER_ADDR_A, 0x0093, 0x36},
+	{SERILIAER_ADDR_A, 0x009b, 0x36},
+	{SERILIAER_ADDR_A, 0x00a3, 0x36},
+	{SERILIAER_ADDR_A, 0x00ab, 0x36},
+	{SERILIAER_ADDR_A, 0x0044, 0x36},
+	{SERILIAER_ADDR_A, 0x0045, 0x20},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x005B, 0x01}, // Stream ID
+	{SERILIAER_ADDR_A, 0x0318, 0x5e}, // Set DT YUV-422 8Bit
+	{SERILIAER_ADDR_A, 0x0331, 0x33}, // 4Lanes
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkB_SY_ISX031_Ser_init[] = {
+	{SERILIAER_ADDR_B, 0x0010, 0x22},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+
+	{SERILIAER_ADDR_B, 0x006b, 0x16},
+	{SERILIAER_ADDR_B, 0x0073, 0x17},
+	{SERILIAER_ADDR_B, 0x007b, 0x37},
+	{SERILIAER_ADDR_B, 0x0083, 0x37},
+	{SERILIAER_ADDR_B, 0x008b, 0x37},
+	{SERILIAER_ADDR_B, 0x0093, 0x37},
+	{SERILIAER_ADDR_B, 0x009b, 0x37},
+	{SERILIAER_ADDR_B, 0x00a3, 0x37},
+	{SERILIAER_ADDR_B, 0x00ab, 0x37},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x02be, 0x10},
+	{SERILIAER_ADDR_B, 0x02d3, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 500},
+
+	// {SERILIAER_ADDR_B, 0x02d3, 0x00},
+	{SERILIAER_ADDR_B, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 300},
+	{SERILIAER_ADDR_B, 0x0308, 0x64},
+	{SERILIAER_ADDR_B, 0x0311, 0xF0}, //Start Video Pipeline on CSI PortB
+	{SERILIAER_ADDR_B, 0x0316, 0x62},
+	{SERILIAER_ADDR_B, 0x0318, 0x5E}, //Set DT
+	{SERILIAER_ADDR_B, 0x0002, 0xF3}, //Turn on all pipeline
+	// {SERILIAER_ADDR_B, 0x02d3, 0x84},
+	// {SERILIAER_ADDR_B, 0x02d5, 0x07},
+	{SERILIAER_ADDR_B, 0x02d6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{SERILIAER_ADDR_B, 0x02d6, 0x84},
+	{SERILIAER_ADDR_B, 0x02d8, 0x07}, // mfp8 trigger
+};
+
+static struct deser_reg SG_linkB_SY_ISX031F_Ser_init[] = {
+	{SERILIAER_ADDR_B, 0x02d3, 0x00},
+	{SERILIAER_ADDR_B, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+	{SERILIAER_ADDR_B, 0x02d3, 0x10},
+	//{SERILIAER_ADDR_B, 0x02d3, 0x84},
+	{SERILIAER_ADDR_B, 0x02d5, 0x07}, // mfp7 trigger
+	{SERILIAER_ADDR_B, 0x02d6, 0x10},
+	//{SERILIAER_ADDR_B, 0x02d6, 0x84},
+	{SERILIAER_ADDR_B, 0x02d8, 0x07}, // mfp8 trigger
+
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x006b, 0x16},
+	{SERILIAER_ADDR_B, 0x0073, 0x17},
+	{SERILIAER_ADDR_B, 0x007b, 0x37},
+	{SERILIAER_ADDR_B, 0x0083, 0x37},
+	{SERILIAER_ADDR_B, 0x008b, 0x37},
+	{SERILIAER_ADDR_B, 0x0093, 0x37},
+	{SERILIAER_ADDR_B, 0x009b, 0x37},
+	{SERILIAER_ADDR_B, 0x00a3, 0x37},
+	{SERILIAER_ADDR_B, 0x00ab, 0x37},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x0318, 0x5e}, // Set DT YUV-422 8Bit
+	{SERILIAER_ADDR_B, 0x005B, 0x02}, // Stream ID
+	{SERILIAER_ADDR_B, 0x0331, 0x33}, // 4Lanes
+};
+
+static struct deser_reg SG_Deser_MAX9296_init[] = {
+	{DESERILIAER_ADDR, 0x0010, 0x23},
+	
+	{DESERILIAER_ADDR, 0x0320, 0x2F}, 
+	// Deserializer MIPI MAP SRC->DST three
+	{DESERILIAER_ADDR, 0x044B, 0x07}, // Pipe Y MAP enable - three
+	{DESERILIAER_ADDR, 0x048B, 0x07}, // Pipe Z MAP enable - three
+
+	{DESERILIAER_ADDR, 0x042D, 0x00},
+	{DESERILIAER_ADDR, 0x046D, 0x15}, // Pipe Y To MIPI port A -> 0X44B
+	{DESERILIAER_ADDR, 0x04AD, 0x15}, // Pipe Z To MIPI port A -> 0X48B
+	{DESERILIAER_ADDR, 0x04ED, 0x00},
+	// Pipeline Y -> VC=0, DT=1E
+	{DESERILIAER_ADDR, 0x044D, 0x1e}, // Pipeline Y mapping src (YUV422 8Bit) 
+	{DESERILIAER_ADDR, 0x044E, 0x1e}, // Pipeline Y YUV422 8Bit mapping
+	{DESERILIAER_ADDR, 0x044F, 0x00}, // Pipeline Y FS mapping
+	{DESERILIAER_ADDR, 0x0450, 0x00}, // Pipeline Y FS mapping
+	{DESERILIAER_ADDR, 0x0451, 0x01}, // Pipeline Y FE mapping
+	{DESERILIAER_ADDR, 0x0452, 0x01}, // Pipeline Y FE mapping
+	// Pipeline Z -> VC=1, DT=1E
+	{DESERILIAER_ADDR, 0x048D, 0x1e}, // Pipeline Z mapping src (YUV422 8Bit) 
+	{DESERILIAER_ADDR, 0x048E, 0x5e}, // Pipeline Z YUV422 8Bit mapping
+	{DESERILIAER_ADDR, 0x048F, 0x00}, // Pipeline Z FS mapping
+	{DESERILIAER_ADDR, 0x0490, 0x40}, // Pipeline Z FS mapping
+	{DESERILIAER_ADDR, 0x0491, 0x01}, // Pipeline Z FE mapping
+	{DESERILIAER_ADDR, 0x0492, 0x41}, // Pipeline Z FE mapping
+
+	{DESERILIAER_ADDR, 0x044A, 0xC0}, // four lane output from MIPI Port A
+	{DESERILIAER_ADDR, 0x048A, 0xC0}, // four lane output from MIPI Port A
+
+	{DESERILIAER_ADDR, 0x0003, 0x40}, // MFP6 used as GPI, disable UTART1 function
+	{DESERILIAER_ADDR, 0x0B08, 0x20}, // GPI-to-GPO
+	{DESERILIAER_ADDR, 0x02C2, 0x83}, // mfp6 config MAX9296->MAX9295 mfp8 passthrough
+	{DESERILIAER_ADDR, 0x02C3, 0xA7}, // mfp6 config
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{DESERILIAER_ADDR, 0x0313, 0x02}, // Enable MIPI output
+};
+
+#endif
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
new file mode 100644
index 000000000..cb08d226c
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
@@ -0,0 +1,325 @@
+/*
+ * serdesaa.c - serdesaa GMSL Expander driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include "serdesa.h"
+
+#define SERDESA_MODULE_VERSION "1.0.1.0"
+
+#define IS_LINK     (1)
+#define NO_LINK     (0)
+//MAX96712
+
+struct serdesa {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct gpio_desc *pwdn_gpio;
+	int channel;
+	unsigned char videoa,videob,videoc,videod; //0x41, 0x42, 0x43, 0x44
+};
+struct serdesa *global_priva[2];
+
+#define DBG
+//#define DBG_REG
+static int serdesa_write_reg(int channel, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err;
+	int addr_bak;
+
+	if(channel > 2 || channel < 0)
+		return -1;
+	
+
+	i2c_client = global_priva[channel]->i2c_client;
+	if(slave_addr != DESERILIAER_ADDR) {
+		addr_bak = global_priva[channel]->i2c_client->addr;
+		global_priva[channel]->i2c_client->addr = slave_addr;
+	}
+	err = regmap_write(global_priva[channel]->regmap, reg, val);
+	#ifdef DBG_REG
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, reg, val);
+	#endif
+
+	usleep_range(200, 500);
+	#ifdef DBG_REG
+	if(slave_addr != DESERILIAER_ADDR) 
+		dev_info(&i2c_client->dev, "serdesa: [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, global_priva[channel]->i2c_client->addr, reg, val );
+	else 
+		dev_info(&i2c_client->dev, "serdesa: [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, global_priva[channel]->i2c_client->addr, reg, val );
+	#endif
+
+	if(slave_addr != DESERILIAER_ADDR)
+		global_priva[channel]->i2c_client->addr = addr_bak;
+	
+	return err;
+}
+// static int serdesa_read_reg(int channel, u8 slave_addr, u16 reg, unsigned int *val)
+// {
+// 	struct i2c_client *i2c_client = NULL;
+// 	int err;
+// 	int addr_bak;
+// 	if(channel > 3 || channel < 0)
+// 		return -1;
+// 	i2c_client = global_priva[channel]->i2c_client;
+// 	addr_bak = global_priva[channel]->i2c_client->addr;
+// 	global_priva[channel]->i2c_client->addr = slave_addr;
+// 	err = regmap_read(global_priva[channel]->regmap, reg, val);
+// 	if (err)
+// 		dev_err(&i2c_client->dev, "%s:i2c read failed, 0x%x = %x\n",
+// 			__func__, reg, *val);
+// 	global_priva[channel]->i2c_client->addr = addr_bak;
+// 	#ifndef DBG_REG
+// 	dev_info(&i2c_client->dev, "MAX929x[%d-0x%02x]:[0x%04x=0x%02x]\n", channel, slave_addr, reg, *val);
+// 	#endif
+// 	if(err)
+// 		return 0;
+// 	return 1;
+// }
+
+int serdesa_write_reg_list(int channel, struct deser_reg *table, int size)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err = 0, i;
+	u8 slave_addr;
+	u16 reg;
+	u16 val;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priva[channel]->i2c_client;
+	
+	for(i=0; i<size; i++)
+	{
+		slave_addr = table[i].slave_addr;
+		reg = table[i].reg;
+		val = table[i].val;
+		
+		if(slave_addr == GMSL_ADDR) {
+			//dev_info(&i2c_client->dev, "mdelay = %d(ms)\n", val);
+			msleep(val);
+		}
+        else if(slave_addr == SERILIAER_ADDR && reg == 0x0000)
+        {
+            err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+            if(err){
+                slave_addr = (val >> 1); 
+                err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+                if(err){
+                    dev_dbg(&i2c_client->dev, "MAX929x Write failed [0x%02x]:[0x%04x=0x%02x]\n", slave_addr, reg, val);
+                    return err;
+                }
+            }
+        }
+		else
+			err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+
+		if(err!=0)
+			break;
+	}
+
+	return err;
+}
+
+static  struct regmap_config deser_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int serdesa_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device dev = client->dev;
+	struct serdesa *priv;
+	int err, cnt=0;//, tmp;
+
+	dev_dbg(&dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &deser_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pwdn_gpio = devm_gpiod_get(&client->dev, "pwdn", GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwdn_gpio)) {
+		//dev_info(&dev, "get pwdn value :%d\n", gpiod_get_value(priv->pwdn_gpio));
+		//gpiod_set_value(priv->pwdn_gpio, false);
+		//msleep(200);
+		gpiod_set_value(priv->pwdn_gpio, true);
+		msleep(200);
+	}
+	
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_err(&dev, "channel not found\n");
+	
+	global_priva[priv->channel] = priv;
+	
+	//sensing camera
+	// err = serdesa_write_reg_list(priv->channel, SG_Deser_6G_init,
+	// 		sizeof(SG_Deser_6G_init)/sizeof(struct deser_reg));
+	// err = serdesa_read_reg(priv->channel, SERILIAER_ADDR, 0x00, &tmp);
+	// if(tmp != 0x80)
+	// 	err = serdesa_write_reg_list(priv->channel, SG_Deser_3G_init,
+	// 		sizeof(SG_Deser_3G_init)/sizeof(struct deser_reg));
+	// err = serdesa_write_reg_list(priv->channel, SG_Deser_init,
+	// 		sizeof(SG_Deser_init)/sizeof(struct deser_reg));
+	//otobrite camera
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_6G_init,
+			sizeof(SG_Deser_6G_init)/sizeof(struct deser_reg));
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_init,
+			sizeof(SG_Deser_init)/sizeof(struct deser_reg));
+			
+	/*detect GMSL Link A */
+	priv->videoa = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkA_Dser_Ser_init,
+		sizeof(SG_linkA_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videoa = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4);
+		#endif
+	}
+	else {
+		priv->videoa = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4);
+		#endif
+	}
+	/*detect GMSL Link B */
+	priv->videob = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkB_Dser_Ser_init,
+		sizeof(SG_linkB_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videob = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+1);
+		#endif
+	}
+	else {
+		priv->videob = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+1);
+		#endif
+	}
+	/*detect GMSL Link C */
+	priv->videoc = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkC_Dser_Ser_init,
+		sizeof(SG_linkC_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videoc = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+2);
+		#endif
+	}
+	else {
+		priv->videoc = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+2);
+		#endif
+	}
+	/*detect GMSL Link D */
+	priv->videod = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkD_Dser_Ser_init,
+		sizeof(SG_linkD_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videod = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+3);
+		#endif
+	}
+	else {
+		priv->videod = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+3);
+		#endif
+	}
+
+	cnt = priv->videoa + priv->videob + priv->videoc + priv->videod;
+    if(cnt > 3)
+    {
+		serdesa_write_reg(priv->channel, DESERILIAER_ADDR, 0x0418, 0x33);
+    }
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_End_init,
+		sizeof(SG_Deser_End_init)/sizeof(struct deser_reg));
+	return 0;
+}
+
+static int serdesa_remove(struct i2c_client *client)
+{
+	if (client != NULL) {
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id serdesa_id[] = {
+	{ "serdesa", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, serdesa_id);
+
+const struct of_device_id serdesa_of_match[] = {
+	{ .compatible = "nvidia,serdesa", },
+	{ },
+};
+
+static struct i2c_driver serdesa_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "serdesa",
+		.of_match_table = of_match_ptr(serdesa_of_match),
+	},
+	.probe = serdesa_probe,
+	.remove = serdesa_remove,
+	.id_table = serdesa_id,
+};
+
+static int __init serdesa_init(void)
+{
+	return i2c_add_driver(&serdesa_i2c_driver);
+}
+
+static void __exit serdesa_exit(void)
+{
+	i2c_del_driver(&serdesa_i2c_driver);
+}
+
+module_init(serdesa_init);
+module_exit(serdesa_exit);
+
+MODULE_DESCRIPTION("IO Expander Driver MAX96712 Sensing-World");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_VERSION(SERDESA_MODULE_VERSION);
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h
new file mode 100644
index 000000000..c4479693d
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h
@@ -0,0 +1,239 @@
+#ifndef __SERDESA_H__
+#define __SERDESA_H__
+/*
+* 2023-02-12 4-IMX390 need set CSI Rate to 0x2F 
+* 0x2D3 Rising
+* 0x2D6 Rising
+*
+*/
+
+#define GMSL_TABLE_END  0xffff
+#define GMSL_WAIT_MS 	0x55
+#define GMSL_ADDR 		0x08
+
+struct deser_reg {
+	u16 slave_addr;
+	u16 reg;
+	u16 val;
+};
+
+#define DESERILIAER_ADDR    0x29
+#define SERILIAER_ADDR      0x62
+#define SERILIAER_ADDR_A    0x41
+#define SERILIAER_ADDR_B    0x42
+#define SERILIAER_ADDR_C    0x43
+#define SERILIAER_ADDR_D    0x44
+#define WR_PARAM
+
+// static struct deser_reg SG_Deser_3G_init[] = {
+// 	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+// 	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable link A
+// 	{DESERILIAER_ADDR, 0x0010, 0x11},
+// 	{DESERILIAER_ADDR, 0x0011, 0x11},
+// };
+static struct deser_reg SG_Deser_6G_init[] = {
+	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable link A
+	{DESERILIAER_ADDR, 0x0010, 0x22},
+	{DESERILIAER_ADDR, 0x0011, 0x22},
+};
+static struct deser_reg SG_Deser_init[] = {
+	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+	{DESERILIAER_ADDR, 0x0006, 0xF0}, // Enable link A
+	
+	//3G Settings
+
+	{DESERILIAER_ADDR, 0x00F0, 0x62},
+	{DESERILIAER_ADDR, 0x00F1, 0xEA},
+	{DESERILIAER_ADDR, 0x00F4, 0x0F},
+
+	// Video Pipe to MIPI Controller Mapping
+	// YUV422 8bit, video pipe 0, map FS/FE, Four pipiline in and PortA csi output
+	{DESERILIAER_ADDR, 0x090B, 0x07}, 
+	{DESERILIAER_ADDR, 0x092D, 0x15}, //map to MIPI Controller 0
+	{DESERILIAER_ADDR, 0x090D, 0x1E}, //map to VC0
+	{DESERILIAER_ADDR, 0x090E, 0x1E},
+	{DESERILIAER_ADDR, 0x090F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0910, 0x00},
+	{DESERILIAER_ADDR, 0x0911, 0x01},
+	{DESERILIAER_ADDR, 0x0912, 0x01},
+	
+	// YUV422 8bit, video pipe 1, map FS/FE
+	{DESERILIAER_ADDR, 0x094B, 0x07},
+	{DESERILIAER_ADDR, 0x096D, 0x15}, //map to MIPI Controller 1
+	{DESERILIAER_ADDR, 0x094D, 0x1E}, //map to VC1
+	{DESERILIAER_ADDR, 0x094E, 0x5E},
+	{DESERILIAER_ADDR, 0x094F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0950, 0x40},
+	{DESERILIAER_ADDR, 0x0951, 0x01},
+	{DESERILIAER_ADDR, 0x0952, 0x41},
+	
+	// YUV422 8bit, video pipe 2, map FS/FE
+	{DESERILIAER_ADDR, 0x098B, 0x07},
+	{DESERILIAER_ADDR, 0x09AD, 0x15}, //map to MIPI Controller 2
+	{DESERILIAER_ADDR, 0x098D, 0x1E}, //map to VC2
+	{DESERILIAER_ADDR, 0x098E, 0x9E},
+	{DESERILIAER_ADDR, 0x098F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0990, 0x80},
+	{DESERILIAER_ADDR, 0x0991, 0x01},
+	{DESERILIAER_ADDR, 0x0992, 0x81},
+	
+	// YUV422 8bit, video pipe 3, map FS/FE
+	{DESERILIAER_ADDR, 0x09CB, 0x07},
+	{DESERILIAER_ADDR, 0x09ED, 0x15}, //map to MIPI Controller 3
+	{DESERILIAER_ADDR, 0x09CD, 0x1E}, //map to VC3
+	{DESERILIAER_ADDR, 0x09CE, 0xDE},
+	{DESERILIAER_ADDR, 0x09CF, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x09D0, 0xC0},
+	{DESERILIAER_ADDR, 0x09D1, 0x01},
+	{DESERILIAER_ADDR, 0x09D2, 0xC1},
+
+	{GMSL_ADDR, GMSL_WAIT_MS, 20}, 
+	{DESERILIAER_ADDR, 0x08A0, 0x04}, //PHY 2x4 MIPI output configured as two ports with four data lanes each. PHY0 and PHY1 combined, and PHY2 and PHY3 combined.
+	{DESERILIAER_ADDR, 0x08A3, 0xE4}, //default 0x4E, 0xE4:MIPI PHY1/PHY0 lane mapping PHY1:D1-D3/D0-D2, PHY0:D1-D1/D0-D0
+	{DESERILIAER_ADDR, 0x08A4, 0xE4}, //default 0xE4, 0xE4:MIPI PHY3/PHY2 lane mapping PHY3:D1-D3/D0-D2, PHY2:D1-D1/D0-D0
+
+	// Set 4 lane D-PHY (Default setting)
+	{DESERILIAER_ADDR, 0x090A, 0xC0},
+	{DESERILIAER_ADDR, 0x094A, 0xC0},
+	{DESERILIAER_ADDR, 0x098A, 0xC0},
+	{DESERILIAER_ADDR, 0x09CA, 0xC0},
+
+	// Turn on MIPI PHYs
+	{DESERILIAER_ADDR, 0x08A2, 0xF0},
+	
+	// Set MIPI Data rate to be 2400Mbps/lane for port A and enable software override
+	{DESERILIAER_ADDR, 0x0415, 0x2F}, //Lower than 8M set to 0x2F
+	{DESERILIAER_ADDR, 0x0418, 0x2F},
+	{DESERILIAER_ADDR, 0x041B, 0x2F},
+	{DESERILIAER_ADDR, 0x041E, 0x2F},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkA_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF1}, // Turn on GMSL2 mode for link A 
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7},
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x82},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkB_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF2}, // Turn on GMSL2 mode for link B
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7},
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x84},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkC_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF4}, // Turn on GMSL2 mode for link C
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100},
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7}, 
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x86},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkD_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF8}, // Turn on GMSL2 mode for link D 
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30},
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7}, 
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x88},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+
+static struct deser_reg SG_Deser_End_init[] = {
+	{DESERILIAER_ADDR, 0x0313, 0x83},
+	{DESERILIAER_ADDR, 0x0314, 0xa7}, //LinkA
+	{DESERILIAER_ADDR, 0x034A, 0xa7}, //LinkB
+	{DESERILIAER_ADDR, 0x0381, 0xa7}, //LinkC
+	{DESERILIAER_ADDR, 0x03B7, 0xa7}, //LinkD
+	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable all links back
+	{DESERILIAER_ADDR, 0x0018, 0x0F}, // One-shot link reset for all links
+	{GMSL_ADDR, GMSL_WAIT_MS, 100},
+	{DESERILIAER_ADDR, 0x040b, 0x02}, // Enable MIPI Output
+	{DESERILIAER_ADDR, 0x08a0, 0x84},
+};
+
+#endif
