From d5e9cea0603d980dc26c7dfcb7bbc8ac5d5e1aa2 Mon Sep 17 00:00:00 2001
From: Alexander Hoffman <alxhoff@gmail.com>
Date: Thu, 31 Jul 2025 12:08:12 +0200
Subject: [PATCH] 4 TCAN4x5x adapters on SPI1

---
 .../cvb/tegra234-p3737-0000-a04.dtsi          | 100 +++++++++++++++---
 kernel/kernel/drivers/net/can/m_can/m_can.c   |   8 +-
 .../kernel/drivers/net/can/m_can/tcan4x5x.c   |  35 ++++--
 3 files changed, 117 insertions(+), 26 deletions(-)

diff --git a/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-a04.dtsi b/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-a04.dtsi
index 4ff5f3d12..d8fc9906a 100644
--- a/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-a04.dtsi
+++ b/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-a04.dtsi
@@ -243,27 +243,99 @@
 		nvidia,xusb-padctl = <&xusb_padctl>;
 	};
 
+	tcan_cclk: tcan_cclk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <40000000>;       // Most TCAN4550EVMs use 40 MHz
+			clock-output-names = "tcan_cclk";
+	};
+
+	tcan_hclk: tcan_hclk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <40000000>;       // Most TCAN4550EVMs use 40 MHz
+			clock-output-names = "tcan_hclk";
+	};
+
 	spi@3210000{ /* SPI1 in 40 pin conn */
 		status = "okay";
+		spi-max-frequency = <50000000>;
+		num-cs = <4>;
+		nvidia,enable-hw-based-cs;
+
+		cs-gpios = <0>,
+			<0>,
+			<&tegra_main_gpio TEGRA234_MAIN_GPIO(P, 4) GPIO_ACTIVE_LOW>,
+			<&tegra_aon_gpio TEGRA234_AON_GPIO(BB, 0) GPIO_ACTIVE_LOW>;
+
 		spi@0 { /* chip select 0 */
-			compatible = "tegra-spidev";
+			compatible = "ti,tcan4x5x";
 			reg = <0x0>;
-			spi-max-frequency = <50000000>;
-			controller-data {
-				nvidia,enable-hw-based-cs;
-				nvidia,rx-clk-tap-delay = <0x10>;
-				nvidia,tx-clk-tap-delay = <0x0>;
-			};
+			spi-max-frequency = <18000000>;
+			clocks = <&tcan_hclk>, <&tcan_cclk>;
+			clock-names = "hclk", "cclk";
+			clock-frequency = <40000000>;
+
+			// MRAM layout for TCAN4x5x:
+			//   <offset sidf_elems xidf_elems rxf0_elems rxf1_elems rxb_elems txe_elems txb_elems>
+			//
+			// This configuration:
+			//   <0x0 1 0 27 0 0 1 1>
+			//
+			// - offset       = 0x0         → Start of MRAM
+			// - sidf_elems   = 1           → One standard 11-bit ID filter (accepts all IDs)
+			// - xidf_elems   = 0           → No extended ID filters (radar uses standard IDs)
+			// - rxf0_elems   = 27          → 16-entry RX FIFO0 for receiving CAN frames
+			// - rxf1_elems   = 0           → RX FIFO1 not used
+			// - rxb_elems    = 0           → No dedicated RX buffers
+			// - txe_elems    = 1           → One TX event FIFO entry (optional but useful)
+			// - txb_elems    = 1           → One TX buffer for occasional outgoing messages
+			//
+			// Total usage: 1236 bytes of 2048-byte internal MRAM
+
+			bosch,mram-cfg = <0x0 1 0 27 0 0 1 1>;
+			interrupt-parent = <&tegra_main_gpio>;
+			interrupts = <TEGRA234_MAIN_GPIO(Q, 6) IRQ_TYPE_LEVEL_LOW>;
+			//reset-gpios = <&tegra_main_gpio TEGRA234_MAIN_GPIO(R, 4) GPIO_ACTIVE_LOW>;
 		};
+
 		spi@1 { /* chip select 1 */
-			compatible = "tegra-spidev";
+			compatible = "ti,tcan4x5x";
 			reg = <0x1>;
-			spi-max-frequency = <50000000>;
-			controller-data {
-				nvidia,enable-hw-based-cs;
-				nvidia,rx-clk-tap-delay = <0x10>;
-				nvidia,tx-clk-tap-delay = <0x0>;
-			};
+			spi-max-frequency = <18000000>;
+			clocks = <&tcan_hclk>, <&tcan_cclk>;
+			clock-names = "hclk", "cclk";
+			clock-frequency = <40000000>;
+			bosch,mram-cfg = <0x0 1 0 27 0 0 1 1>;
+			interrupt-parent = <&tegra_main_gpio>;
+			interrupts = <TEGRA234_MAIN_GPIO(R, 0) IRQ_TYPE_LEVEL_LOW>;
+			//reset-gpios = <&tegra_main_gpio TEGRA234_MAIN_GPIO(R, 4) GPIO_ACTIVE_LOW>;
+		};
+
+		spi@2 { /* chip select 2 */
+			compatible = "ti,tcan4x5x";
+			reg = <0x2>;
+			spi-max-frequency = <18000000>;
+			clocks = <&tcan_hclk>, <&tcan_cclk>;
+			clock-names = "hclk", "cclk";
+			clock-frequency = <40000000>;
+			bosch,mram-cfg = <0x0 1 0 27 0 0 1 1>;
+			interrupt-parent = <&tegra_main_gpio>;
+			interrupts = <TEGRA234_MAIN_GPIO(R, 5) IRQ_TYPE_LEVEL_LOW>;
+			//reset-gpios = <&tegra_main_gpio TEGRA234_MAIN_GPIO(R, 4) GPIO_ACTIVE_LOW>;
+		};
+
+		spi@3 { /* chip select 3 */
+			compatible = "ti,tcan4x5x";
+			reg = <0x3>;
+			spi-max-frequency = <18000000>;
+			clocks = <&tcan_hclk>, <&tcan_cclk>;
+			clock-names = "hclk", "cclk";
+			clock-frequency = <40000000>;
+			bosch,mram-cfg = <0x0 1 0 27 0 0 1 1>;
+			interrupt-parent = <&tegra_aon_gpio>;
+			interrupts = <TEGRA234_AON_GPIO(BB, 1) IRQ_TYPE_LEVEL_LOW>;
+			//reset-gpios = <&tegra_main_gpio TEGRA234_MAIN_GPIO(R, 4) GPIO_ACTIVE_LOW>;
 		};
 	};
 
diff --git a/kernel/kernel/drivers/net/can/m_can/m_can.c b/kernel/kernel/drivers/net/can/m_can/m_can.c
index 19a19a7b7..efcd2616d 100644
--- a/kernel/kernel/drivers/net/can/m_can/m_can.c
+++ b/kernel/kernel/drivers/net/can/m_can/m_can.c
@@ -1825,13 +1825,17 @@ int m_can_class_register(struct m_can_classdev *m_can_dev)
 	if (m_can_dev->pm_clock_support) {
 		pm_runtime_enable(m_can_dev->dev);
 		ret = m_can_clk_start(m_can_dev);
-		if (ret)
+		if (ret){
+			dev_err(m_can_dev->dev, "can_clk_start failed (err=%d)\n", ret);
 			goto pm_runtime_fail;
+		}
 	}
 
 	ret = m_can_dev_setup(m_can_dev);
-	if (ret)
+	if (ret){
+		dev_err(m_can_dev->dev, "m_can_dev_setup failed (err=%d)\n", ret);
 		goto clk_disable;
+	}
 
 	ret = register_m_can_dev(m_can_dev->net);
 	if (ret) {
diff --git a/kernel/kernel/drivers/net/can/m_can/tcan4x5x.c b/kernel/kernel/drivers/net/can/m_can/tcan4x5x.c
index f903f78af..8d89deed4 100644
--- a/kernel/kernel/drivers/net/can/m_can/tcan4x5x.c
+++ b/kernel/kernel/drivers/net/can/m_can/tcan4x5x.c
@@ -413,13 +413,13 @@ static int tcan4x5x_can_probe(struct spi_device *spi)
 	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		ret = -ENOMEM;
-		goto out_m_can_class_free_dev;
+		goto out_alloc;
 	}
 
 	priv->power = devm_regulator_get_optional(&spi->dev, "vsup");
 	if (PTR_ERR(priv->power) == -EPROBE_DEFER) {
 		ret = -EPROBE_DEFER;
-		goto out_m_can_class_free_dev;
+		goto out_regulator_optional;
 	} else {
 		priv->power = NULL;
 	}
@@ -458,37 +458,52 @@ static int tcan4x5x_can_probe(struct spi_device *spi)
 	spi->bits_per_word = 32;
 	ret = spi_setup(spi);
 	if (ret)
-		goto out_m_can_class_free_dev;
+		goto out_spi_setup;
 
 	priv->regmap = devm_regmap_init(&spi->dev, &tcan4x5x_bus,
 					&spi->dev, &tcan4x5x_regmap);
 	if (IS_ERR(priv->regmap)) {
 		ret = PTR_ERR(priv->regmap);
-		goto out_m_can_class_free_dev;
+		goto out_regmap;
 	}
 
 	ret = tcan4x5x_power_enable(priv->power, 1);
 	if (ret)
-		goto out_m_can_class_free_dev;
+		goto out_power;
 
 	ret = tcan4x5x_parse_config(mcan_class);
 	if (ret)
-		goto out_power;
+		goto out_parse_config;
 
 	ret = tcan4x5x_init(mcan_class);
 	if (ret)
-		goto out_power;
+		goto out_tcan_init;
 
 	ret = m_can_class_register(mcan_class);
 	if (ret)
-		goto out_power;
+		goto out_class_register;
 
 	netdev_info(mcan_class->net, "TCAN4X5X successfully initialized.\n");
 	return 0;
 
-out_power:
+out_class_register:
+	dev_err(&spi->dev, "out_class_register");
+out_tcan_init:
+	dev_err(&spi->dev, "out_tcan_init");
+out_parse_config:
+	dev_err(&spi->dev, "out_parse_config");
 	tcan4x5x_power_enable(priv->power, 0);
- out_m_can_class_free_dev:
+out_power:
+	dev_err(&spi->dev, "out_power");
+out_regmap:
+	dev_err(&spi->dev, "out_regmap");
+out_spi_setup:
+	dev_err(&spi->dev, "out_spi_setup");
+out_regulator_optional:
+	dev_err(&spi->dev, "out_regulator_optional");
+out_alloc:
+	dev_err(&spi->dev, "out_alloc");
+out_m_can_class_free_dev:
 	m_can_class_free_dev(mcan_class->net);
 	dev_err(&spi->dev, "Probe failed, err=%d\n", ret);
 
-- 
2.50.1

