From 844b29147168f9a550fb13cd07c5af2f4d5938d3 Mon Sep 17 00:00:00 2001
From: Brian Silverman <brian.silverman@bluerivert.com>
Date: Mon, 23 Dec 2019 12:52:45 -0800
Subject: [PATCH 10/20] Fix error recovery for
 tegra_channel_kthread_capture_dequeue

Previously, it allowed the main application thread to sneak in the
middle of its error recovery. This led to double-frees and other forms
of corrupted state.

Also, as documented at https://lore.kernel.org/patchwork/patch/589697/,
if you're going to call kthread_stop, the kthread needs to wait until
kthread_should_stop returns 1 before returning. Otherwise, there's a
race condition leading to double-frees and NULL dereferences.
---
 .../media/platform/tegra/camera/vi/vi5_fops.c | 80 ++++++++++++-------
 1 file changed, 52 insertions(+), 28 deletions(-)

diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
index 59ee7fe32..325ff2b78 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
@@ -641,15 +641,17 @@ static int vi5_channel_error_recover(struct tegra_channel *chan,
 
 	/* stop vi channel */
 	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
-		if (err) {
-			dev_err(&chan->video->dev, "vi capture release failed\n");
-			goto done;
+		if (chan->tegra_vi_channel[vi_port]) {
+			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+			if (err) {
+				dev_err(&chan->video->dev, "vi capture release failed\n");
+				goto done;
+			}
+			vi_channel_close_ex(chan->vi_channel_id[vi_port],
+						chan->tegra_vi_channel[vi_port]);
+			chan->tegra_vi_channel[vi_port] = NULL;
 		}
-		vi_channel_close_ex(chan->vi_channel_id[vi_port],
-					chan->tegra_vi_channel[vi_port]);
-		chan->tegra_vi_channel[vi_port] = NULL;
 	}
 
 
@@ -754,6 +756,7 @@ static int tegra_channel_kthread_capture_dequeue(void *data)
 	unsigned long flags;
 	struct tegra_channel *chan = data;
 	struct tegra_channel_buffer *buf;
+	enum channel_capture_state capture_state;
 
 	set_freezable();
 
@@ -775,19 +778,35 @@ static int tegra_channel_kthread_capture_dequeue(void *data)
 			vi5_capture_dequeue(chan, buf);
 		}
 
+		if (kthread_should_stop())
+			break;
+
 		spin_lock_irqsave(&chan->capture_state_lock, flags);
-		if (chan->capture_state == CAPTURE_ERROR) {
-			spin_unlock_irqrestore(&chan->capture_state_lock,
-				flags);
-			err = tegra_channel_error_recover(chan, false);
-			if (err) {
+		capture_state = chan->capture_state;
+		spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+		if (capture_state == CAPTURE_ERROR) {
+			/* We deliberately keep this lock held even across
+			 * msleep calls so that no other context can observe
+			 * the invalid state produced by failed error_recover
+			 * calls. */
+			mutex_lock(&chan->video_lock);
+			while (!kthread_should_stop()) {
+				err = tegra_channel_error_recover(chan, false);
+				if (!err) {
+					break;
+				}
 				dev_err(chan->vi->dev,
-					"fatal: error recovery failed\n");
-				break;
+					"fatal: error recovery failed: %d\n",
+					err);
+				if (kthread_should_stop()) {
+					break;
+				}
+				/* kthread_stop won't interrupt this, but it's
+				 * pretty short so it's fine */
+				msleep(300);
 			}
-		} else
-			spin_unlock_irqrestore(&chan->capture_state_lock,
-				flags);
+			mutex_unlock(&chan->video_lock);
+		}
 		if (kthread_should_stop())
 			break;
 	}
@@ -836,6 +855,7 @@ done:
 static void vi5_channel_stop_kthreads(struct tegra_channel *chan)
 {
 	mutex_lock(&chan->stop_kthread_lock);
+	mutex_unlock(&chan->video_lock);
 
 	/* Stop the kthread for capture enqueue */
 	if (chan->kthread_capture_start) {
@@ -849,6 +869,7 @@ static void vi5_channel_stop_kthreads(struct tegra_channel *chan)
 		chan->kthread_capture_dequeue = NULL;
 	}
 
+	mutex_lock(&chan->video_lock);
 	mutex_unlock(&chan->stop_kthread_lock);
 }
 
@@ -1016,16 +1037,19 @@ static int vi5_channel_stop_streaming(struct vb2_queue *vq)
 
 	if (!chan->bypass) {
 		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
-
-			if (err)
-				dev_err(&chan->video->dev,
-					"vi capture release failed\n");
-
-			vi_channel_close_ex(chan->vi_channel_id[vi_port],
-						chan->tegra_vi_channel[vi_port]);
-			chan->tegra_vi_channel[vi_port] = NULL;
+			/* if vi5_channel_error_recover fails, it will leave this NULL */
+			if (chan->tegra_vi_channel[vi_port]) {
+				err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+					CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+
+				if (err)
+					dev_err(&chan->video->dev,
+						"vi capture release failed\n");
+
+				vi_channel_close_ex(chan->vi_channel_id[vi_port],
+							chan->tegra_vi_channel[vi_port]);
+				chan->tegra_vi_channel[vi_port] = NULL;
+			}
 		}
 
 		/* release all remaining buffers to v4l2 */
-- 
2.51.0

