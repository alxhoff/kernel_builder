From 27d0d8f93f4784a496182db0bb05c9a2cea3ffbd Mon Sep 17 00:00:00 2001
From: Alexander Hoffman <alxhoff@gmail.com>
Date: Fri, 28 Nov 2025 14:14:32 +0100
Subject: [PATCH 02/26] ISX031 RGB camera driver

---
 kernel/nvidia/drivers/media/i2c/Kconfig       |   7 +
 kernel/nvidia/drivers/media/i2c/Makefile      |   1 +
 .../nvidia/drivers/media/i2c/isx031/Makefile  |   8 +
 .../nvidia/drivers/media/i2c/isx031/fzcam.c   | 819 ++++++++++++++++++
 .../media/i2c/isx031/fzcam_mode_tbls.h        |  78 ++
 .../nvidia/drivers/media/i2c/isx031/fzcama.c  | 819 ++++++++++++++++++
 .../media/i2c/isx031/fzcama_mode_tbls.h       |  78 ++
 .../nvidia/drivers/media/i2c/isx031/serdes.c  | 369 ++++++++
 .../nvidia/drivers/media/i2c/isx031/serdes.h  | 196 +++++
 .../nvidia/drivers/media/i2c/isx031/serdesa.c | 325 +++++++
 .../nvidia/drivers/media/i2c/isx031/serdesa.h | 239 +++++
 11 files changed, 2939 insertions(+)
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/Makefile
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdes.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdes.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdesa.h

diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 5ec3c683c..5ac7c6d4e 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -210,6 +210,13 @@ config NV_VIRTUAL_I2C_MUX
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called virtual_i2c_mux.
+
+config NV_VIDEO_ISX031
+	tristate "ISX031 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && I2C_IOEXPANDER_SER_MAX9295 && I2C_IOEXPANDER_DESER_MAX9296
+	help
+	  Video4Linux2 sensor-level driver for the Sony ISX031 camera sensor
+
 endmenu
 
 endif
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index c4708d8c7..8cdf742ac 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -27,3 +27,4 @@ obj-$(CONFIG_NV_VIDEO_HAWK_OWL) += nv_hawk_owl.o
 obj-$(CONFIG_NV_DESER_MAX96712) += max96712.o
 obj-$(CONFIG_VIDEO_ECAM) += ar1335.o
 ar1335-objs :=  ar1335_common.o
+obj-$(CONFIG_NV_VIDEO_ISX031) += isx031/
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/Makefile b/kernel/nvidia/drivers/media/i2c/isx031/Makefile
new file mode 100644
index 000000000..526951283
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/Makefile
@@ -0,0 +1,8 @@
+subdir-ccflags-y += -Werror
+
+ccflags-y += -I$(srctree)/drivers/media/platform/tegra
+ccflags-y += -I$(srctree)/drivers/video/tegra/camera
+
+obj-y += serdes.o serdesa.o
+obj-m += fzcam.o
+obj-m += fzcama.o
\ No newline at end of file
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c b/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
new file mode 100644
index 000000000..89a5dc277
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
@@ -0,0 +1,819 @@
+/*
+ * sgcam.c - sgcam sensor driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include "fzcam_mode_tbls.h"
+
+//#define USE_RESET_GPIO
+#define SGCAM_DEFAULT_MODE		SGCAM_MODE_1920X1536_CROP_30FPS
+#define SGCAM_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_1X16
+
+
+#define SGCAM_DEFAULT_WIDTH		1920
+#define SGCAM_DEFAULT_HEIGHT	1536
+#define SGCAM_DEFAULT_CLK_FREQ	37125000
+
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define sgcam_subdev camera_common_data
+#else
+struct sgcam_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct sgcam {
+	int 	channel;
+	u32					sensor_def_addr;
+	u32					sensor_map_addr;
+	struct 	camera_common_power_rail	power;
+	int		numctrls;
+	struct 	v4l2_ctrl_handler	ctrl_handler;
+	struct 	i2c_client	*i2c_client;
+	struct 	v4l2_subdev	*subdev;
+	struct 	sgcam_subdev sd;
+	struct 	media_pad	pad;
+	u32				frame_length;
+	s32		group_hold_prev;
+	bool	group_hold_en;
+	s64 	last_wdr_et_val;
+	struct regmap	*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	.use_single_rw = true,
+#else
+	.use_single_read = true,
+	.use_single_write = true,
+#endif
+};
+
+static int sgcam_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int sgcam_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static const struct v4l2_ctrl_ops sgcam_ctrl_ops = {
+	.g_volatile_ctrl = sgcam_g_volatile_ctrl,
+	.s_ctrl = sgcam_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+};
+
+static inline void sgcam_get_frame_length_regs(sgcam_reg *regs,
+				u32 frame_length)
+{
+	return;
+}
+
+static inline void sgcam_get_coarse_time_regs_shs1(sgcam_reg *regs,
+				u32 coarse_time)
+{
+	return ;
+}
+
+static inline void sgcam_get_coarse_time_regs_shs2(sgcam_reg *regs,
+				u32 coarse_time)
+{
+	return; 
+}
+
+static inline void sgcam_get_gain_reg(sgcam_reg *regs,
+				u8 gain)
+{
+
+}
+
+static inline int sgcam_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int sgcam_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct device *dev = &priv->i2c_client->dev;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int sgcam_write_table(struct sgcam *priv,
+		const sgcam_reg table[])
+{		
+	return 0;
+	
+	/*
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 sgcam_TABLE_WAIT_MS,
+					 sgcam_TABLE_END);
+	*/
+}
+
+static int sgcam_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	
+#ifdef USE_RESET_GPIO
+	/*exit reset mode: XCLR */
+	if (pw->reset_gpio) {
+		gpio_set_value(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_set_value(pw->reset_gpio, 1);
+		usleep_range(30, 50);
+	}
+#endif
+
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int sgcam_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err)
+			goto power_off_done;
+		else
+			dev_err(dev, "%s failed.\n", __func__);
+		return err;
+	}
+#ifdef USE_RESET_GPIO
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_set_value(pw->reset_gpio, 0);
+#endif
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int sgcam_power_get(struct sgcam *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	#ifdef USE_RESET_GPIO
+	struct camera_common_pdata *pdata = priv->pdata;
+	#endif
+	struct device *dev = &priv->i2c_client->dev;
+	const char *mclk_name;
+	struct clk *parent;
+	int err = 0;
+
+	mclk_name = priv->pdata->mclk_name ?
+		    priv->pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
+
+#ifdef USE_RESET_GPIO
+	pw->reset_gpio = pdata->reset_gpio;
+#endif
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+static int sgcam_set_gain(struct sgcam *priv, s64 val);
+static int sgcam_set_frame_rate(struct sgcam *priv, s64 val);
+static int sgcam_set_exposure(struct sgcam *priv, s64 val);
+
+/* Video ops */
+static int sgcam_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static int sgcam_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+static int sgcam_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	int err = 0;
+
+	dev_dbg(dev, "%s++ enable %d\n", __func__, enable);
+
+	if (!enable) {
+		err = sgcam_write_table(priv, mode_table[SGCAM_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+		else 
+			return 0;
+	}
+
+	err = sgcam_write_table(priv, mode_table[SGCAM_MODE_START_STREAM]);
+	if (err)
+		return err;
+	else
+		return 0;
+}
+
+static int sgcam_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops sgcam_subdev_video_ops = {
+	.g_frame_interval	= sgcam_g_frame_interval,
+	.s_frame_interval	= sgcam_s_frame_interval,
+	.s_stream	= sgcam_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = sgcam_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops sgcam_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int sgcam_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int sgcam_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	int ret = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops sgcam_subdev_pad_ops = {
+	.set_fmt = sgcam_set_fmt,
+	.get_fmt = sgcam_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.get_mbus_config	= camera_common_get_mbus_config,
+#endif
+};
+
+static struct v4l2_subdev_ops sgcam_subdev_ops = {
+	.core	= &sgcam_subdev_core_ops,
+	.video	= &sgcam_subdev_video_ops,
+	.pad = &sgcam_subdev_pad_ops,
+};
+
+const static struct of_device_id sgcam_of_match[] = {
+	{ .compatible = "nvidia,fzcam",},
+	{ },
+};
+
+static struct camera_common_sensor_ops sgcam_common_ops = {
+	.power_on = sgcam_power_on,
+	.power_off = sgcam_power_off,
+	.write_reg = sgcam_write_reg,
+	.read_reg = sgcam_read_reg,
+};
+
+static int sgcam_set_group_hold(struct sgcam *priv, s32 val)
+{
+	return 0;
+}
+
+static int sgcam_set_gain(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcam_set_frame_rate(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcam_set_exposure(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+
+static int sgcam_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcam *priv =
+		container_of(ctrl->handler, struct sgcam, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+
+	default:
+			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcam_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcam *priv =
+		container_of(ctrl->handler, struct sgcam, ctrl_handler);
+	struct camera_common_data	*s_data = priv->s_data;
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = sgcam_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		err = sgcam_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		err = sgcam_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		err = sgcam_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		s_data->sensor_mode_id = (int) (*ctrl->p_new.p_s64);
+		break;
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcam_ctrls_init(struct sgcam *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err = 0;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = num_ctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, sgcam_of_match);
+
+static struct camera_common_pdata *sgcam_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err = 0;
+	const char *str;
+	
+	#ifdef USE_RESET_GPIO
+	int gpio;
+	#endif
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(sgcam_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(&client->dev, "mclk not in DT\n");
+
+#ifdef USE_RESET_GPIO
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+#endif
+
+	return board_priv_pdata;
+}
+
+static int sgcam_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops sgcam_subdev_internal_ops = {
+	.open = sgcam_open,
+};
+
+static const struct media_entity_operations sgcam_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int sgcam_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct sgcam *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "probing fzcam v4l2 sensor\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct sgcam) + sizeof(struct v4l2_ctrl *),
+			    GFP_KERNEL);
+
+	if (!priv) {
+		dev_err(&client->dev, "unable to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_dbg(&client->dev, "channel not found\n");
+		
+	err = device_property_read_u32(&client->dev, "reg", &priv->sensor_map_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "reg not found\n");
+		priv->sensor_map_addr = 0x00;
+	}
+
+	err = device_property_read_u32(&client->dev,  "def-addr", &priv->sensor_def_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "def-addr not found\n");
+		priv->sensor_def_addr = 0x00;
+	}
+	
+	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = sgcam_parse_dt(client, common_data);
+
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &sgcam_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &sgcam_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  SGCAM_DEFAULT_DATAFMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = (void *)priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(sgcam_frmfmt);
+	common_data->def_mode = SGCAM_DEFAULT_MODE;
+	common_data->def_width = SGCAM_DEFAULT_WIDTH;
+	common_data->def_height = SGCAM_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = SGCAM_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	priv->last_wdr_et_val = 0;
+
+	err = sgcam_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "sgcam");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize sgcam.\n");
+		return err;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &sgcam_subdev_ops);
+
+	err = sgcam_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &sgcam_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		     V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &sgcam_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1,
+				&priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_info(&client->dev, "Detected Sensor\n");
+
+	return 0;
+}
+
+static int
+sgcam_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+static const struct i2c_device_id sgcam_id[] = {
+	{ "fzcam", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sgcam_id);
+
+static struct i2c_driver sgcam_i2c_driver = {
+	.driver = {
+		.name = "fzcam",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(sgcam_of_match),
+	},
+	.probe = sgcam_probe,
+	.remove = sgcam_remove,
+	.id_table = sgcam_id,
+};
+
+module_i2c_driver(sgcam_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sensing-World MAXIM GMSL");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
new file mode 100644
index 000000000..a6f605a46
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
@@ -0,0 +1,78 @@
+/*
+ * SGCAM_mode_tbls.h - fzcam sensor mode tables
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __SGCAM_I2C_TABLES__
+#define __SGCAM_I2C_TABLES__
+
+#include <media/camera_common.h>
+#include <linux/miscdevice.h>
+
+#define SGCAM_TABLE_WAIT_MS	0
+#define SGCAM_TABLE_END		1
+#define SGCAM_MAX_RETRIES	3
+#define SGCAM_WAIT_MS_STOP	1
+#define SGCAM_WAIT_MS_START	30
+#define SGCAM_WAIT_MS_STREAM	210
+#define SGCAM_GAIN_TABLE_SIZE 255
+
+#define sgcam_reg struct reg_8
+
+static sgcam_reg SGCAM_start[] = {
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_START},
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_STREAM},
+	{SGCAM_TABLE_END, 0x00}
+};
+
+static sgcam_reg SGCAM_stop[] = {
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_STOP},
+	{SGCAM_TABLE_END, 0x00}
+};
+
+static sgcam_reg SGCAM_1920x1536_crop_30fps[] = {
+
+	{SGCAM_TABLE_END, 0x00},
+};
+
+enum {
+	SGCAM_MODE_1920X1536_CROP_30FPS,
+	SGCAM_MODE_START_STREAM,
+	SGCAM_MODE_STOP_STREAM,
+};
+
+static sgcam_reg *mode_table[] = {
+	[SGCAM_MODE_1920X1536_CROP_30FPS]
+		= SGCAM_1920x1536_crop_30fps,
+	[SGCAM_MODE_START_STREAM]
+		= SGCAM_start,
+	[SGCAM_MODE_STOP_STREAM]
+		= SGCAM_stop,
+};
+
+static const int SGCAM_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in device tree!
+ */
+static const struct camera_common_frmfmt sgcam_frmfmt[] = {
+	{{1920, 1536}, SGCAM_30fps, 1, 0, SGCAM_MODE_1920X1536_CROP_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __SGCAM_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c b/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
new file mode 100644
index 000000000..13d07833e
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
@@ -0,0 +1,819 @@
+/*
+ * sgcama.c - sgcama sensor driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include "fzcama_mode_tbls.h"
+
+//#define USE_RESET_GPIO
+#define SGCAMA_DEFAULT_MODE		SGCAMA_MODE_1920X1536_CROP_30FPS
+#define SGCAMA_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_1X16
+
+
+#define SGCAMA_DEFAULT_WIDTH	1920
+#define SGCAMA_DEFAULT_HEIGHT	1536
+#define SGCAMA_DEFAULT_CLK_FREQ	37125000
+
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define sgcama_subdev camera_common_data
+#else
+struct sgcama_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct sgcama {
+	int 	channel;
+	u32					sensor_def_addr;
+	u32					sensor_map_addr;
+	struct 	camera_common_power_rail	power;
+	int		numctrls;
+	struct 	v4l2_ctrl_handler	ctrl_handler;
+	struct 	i2c_client	*i2c_client;
+	struct 	v4l2_subdev	*subdev;
+	struct 	sgcama_subdev sd;
+	struct 	media_pad	pad;
+	u32				frame_length;
+	s32		group_hold_prev;
+	bool	group_hold_en;
+	s64 	last_wdr_et_val;
+	struct regmap	*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	.use_single_rw = true,
+#else
+	.use_single_read = true,
+	.use_single_write = true,
+#endif
+};
+
+static int sgcama_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int sgcama_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static const struct v4l2_ctrl_ops sgcama_ctrl_ops = {
+	.g_volatile_ctrl = sgcama_g_volatile_ctrl,
+	.s_ctrl = sgcama_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+};
+
+static inline void sgcama_get_frame_length_regs(sgcama_reg *regs,
+				u32 frame_length)
+{
+	return;
+}
+
+static inline void sgcama_get_coarse_time_regs_shs1(sgcama_reg *regs,
+				u32 coarse_time)
+{
+	return ;
+}
+
+static inline void sgcama_get_coarse_time_regs_shs2(sgcama_reg *regs,
+				u32 coarse_time)
+{
+	return; 
+}
+
+static inline void sgcama_get_gain_reg(sgcama_reg *regs,
+				u8 gain)
+{
+
+}
+
+static inline int sgcama_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int sgcama_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct device *dev = &priv->i2c_client->dev;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int sgcama_write_table(struct sgcama *priv,
+		const sgcama_reg table[])
+{		
+	return 0;
+	
+	/*
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 SGCAMAA_TABLE_WAIT_MS,
+					 SGCAMAA_TABLE_END);
+	*/
+}
+
+static int sgcama_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	
+#ifdef USE_RESET_GPIO
+	/*exit reset mode: XCLR */
+	if (pw->reset_gpio) {
+		gpio_set_value(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_set_value(pw->reset_gpio, 1);
+		usleep_range(30, 50);
+	}
+#endif
+
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int sgcama_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err)
+			goto power_off_done;
+		else
+			dev_err(dev, "%s failed.\n", __func__);
+		return err;
+	}
+#ifdef USE_RESET_GPIO
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_set_value(pw->reset_gpio, 0);
+#endif
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int sgcama_power_get(struct sgcama *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	#ifdef USE_RESET_GPIO
+	struct camera_common_pdata *pdata = priv->pdata;
+	#endif
+	struct device *dev = &priv->i2c_client->dev;
+	const char *mclk_name;
+	struct clk *parent;
+	int err = 0;
+
+	mclk_name = priv->pdata->mclk_name ?
+		    priv->pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
+
+#ifdef USE_RESET_GPIO
+	pw->reset_gpio = pdata->reset_gpio;
+#endif
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+static int sgcama_set_gain(struct sgcama *priv, s64 val);
+static int sgcama_set_frame_rate(struct sgcama *priv, s64 val);
+static int sgcama_set_exposure(struct sgcama *priv, s64 val);
+
+/* Video ops */
+static int sgcama_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static int sgcama_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+static int sgcama_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	int err = 0;
+
+	dev_dbg(dev, "%s++ enable %d\n", __func__, enable);
+
+	if (!enable) {
+		err = sgcama_write_table(priv, mode_table[SGCAMA_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+		else 
+			return 0;
+	}
+
+	err = sgcama_write_table(priv, mode_table[SGCAMA_MODE_START_STREAM]);
+	if (err)
+		return err;
+	else
+		return 0;
+}
+
+static int sgcama_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops sgcama_subdev_video_ops = {
+	.g_frame_interval	= sgcama_g_frame_interval,
+	.s_frame_interval	= sgcama_s_frame_interval,
+	.s_stream	= sgcama_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = sgcama_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops sgcama_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int sgcama_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int sgcama_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	int ret = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops sgcama_subdev_pad_ops = {
+	.set_fmt = sgcama_set_fmt,
+	.get_fmt = sgcama_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.get_mbus_config	= camera_common_get_mbus_config,
+#endif
+};
+
+static struct v4l2_subdev_ops sgcama_subdev_ops = {
+	.core	= &sgcama_subdev_core_ops,
+	.video	= &sgcama_subdev_video_ops,
+	.pad = &sgcama_subdev_pad_ops,
+};
+
+const static struct of_device_id sgcama_of_match[] = {
+	{ .compatible = "nvidia,fzcama",},
+	{ },
+};
+
+static struct camera_common_sensor_ops sgcama_common_ops = {
+	.power_on = sgcama_power_on,
+	.power_off = sgcama_power_off,
+	.write_reg = sgcama_write_reg,
+	.read_reg = sgcama_read_reg,
+};
+
+static int sgcama_set_group_hold(struct sgcama *priv, s32 val)
+{
+	return 0;
+}
+
+static int sgcama_set_gain(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcama_set_frame_rate(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcama_set_exposure(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+
+static int sgcama_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcama *priv =
+		container_of(ctrl->handler, struct sgcama, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+
+	default:
+			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcama_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcama *priv =
+		container_of(ctrl->handler, struct sgcama, ctrl_handler);
+	struct camera_common_data	*s_data = priv->s_data;
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = sgcama_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		err = sgcama_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		err = sgcama_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		err = sgcama_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		s_data->sensor_mode_id = (int) (*ctrl->p_new.p_s64);
+		break;
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcama_ctrls_init(struct sgcama *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err = 0;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = num_ctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, sgcama_of_match);
+
+static struct camera_common_pdata *sgcama_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err = 0;
+	const char *str;
+	
+	#ifdef USE_RESET_GPIO
+	int gpio;
+	#endif
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(sgcama_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(&client->dev, "mclk not in DT\n");
+
+#ifdef USE_RESET_GPIO
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+#endif
+
+	return board_priv_pdata;
+}
+
+static int sgcama_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops sgcama_subdev_internal_ops = {
+	.open = sgcama_open,
+};
+
+static const struct media_entity_operations sgcama_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int sgcama_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct sgcama *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "probing sgcama v4l2 sensor\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct sgcama) + sizeof(struct v4l2_ctrl *),
+			    GFP_KERNEL);
+
+	if (!priv) {
+		dev_err(&client->dev, "unable to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_dbg(&client->dev, "channel not found\n");
+		
+	err = device_property_read_u32(&client->dev, "reg", &priv->sensor_map_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "reg not found\n");
+		priv->sensor_map_addr = 0x00;
+	}
+
+	err = device_property_read_u32(&client->dev,  "def-addr", &priv->sensor_def_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "def-addr not found\n");
+		priv->sensor_def_addr = 0x00;
+	}
+	
+	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = sgcama_parse_dt(client, common_data);
+
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &sgcama_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &sgcama_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  SGCAMA_DEFAULT_DATAFMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = (void *)priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(sgcama_frmfmt);
+	common_data->def_mode = SGCAMA_DEFAULT_MODE;
+	common_data->def_width = SGCAMA_DEFAULT_WIDTH;
+	common_data->def_height = SGCAMA_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = SGCAMA_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	priv->last_wdr_et_val = 0;
+
+	err = sgcama_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "sgcama");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize sgcama.\n");
+		return err;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &sgcama_subdev_ops);
+
+	err = sgcama_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &sgcama_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		     V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &sgcama_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1,
+				&priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_info(&client->dev, "Detected Sensor\n");
+
+	return 0;
+}
+
+static int
+sgcama_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+static const struct i2c_device_id sgcama_id[] = {
+	{ "fzcama", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sgcama_id);
+
+static struct i2c_driver sgcama_i2c_driver = {
+	.driver = {
+		.name = "fzcama",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(sgcama_of_match),
+	},
+	.probe = sgcama_probe,
+	.remove = sgcama_remove,
+	.id_table = sgcama_id,
+};
+
+module_i2c_driver(sgcama_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sensing-World MAXIM GMSL");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
new file mode 100644
index 000000000..f93dd2365
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
@@ -0,0 +1,78 @@
+/*
+ * sgcama_mode_tbls.h - sgcama sensor mode tables
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __SGCAMA_I2C_TABLES__
+#define __SGCAMA_I2C_TABLES__
+
+#include <media/camera_common.h>
+#include <linux/miscdevice.h>
+
+#define SGCAMA_TABLE_WAIT_MS	0
+#define SGCAMA_TABLE_END		1
+#define SGCAMA_MAX_RETRIES	3
+#define SGCAMA_WAIT_MS_STOP	1
+#define SGCAMA_WAIT_MS_START	30
+#define SGCAMA_WAIT_MS_STREAM	210
+#define SGCAMA_GAIN_TABLE_SIZE 255
+
+#define sgcama_reg struct reg_8
+
+static sgcama_reg sgcama_start[] = {
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_START},
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_STREAM},
+	{SGCAMA_TABLE_END, 0x00}
+};
+
+static sgcama_reg sgcama_stop[] = {
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_STOP},
+	{SGCAMA_TABLE_END, 0x00}
+};
+
+static sgcama_reg sgcama_1920x1536_crop_30fps[] = {
+
+	{SGCAMA_TABLE_END, 0x00},
+};
+
+enum {
+	SGCAMA_MODE_1920X1536_CROP_30FPS,
+	SGCAMA_MODE_START_STREAM,
+	SGCAMA_MODE_STOP_STREAM,
+};
+
+static sgcama_reg *mode_table[] = {
+	[SGCAMA_MODE_1920X1536_CROP_30FPS]
+		= sgcama_1920x1536_crop_30fps,
+	[SGCAMA_MODE_START_STREAM]
+		= sgcama_start,
+	[SGCAMA_MODE_STOP_STREAM]
+		= sgcama_stop,
+};
+
+static const int sgcama_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in device tree!
+ */
+static const struct camera_common_frmfmt sgcama_frmfmt[] = {
+	{{1920, 1536}, sgcama_30fps, 1, 0, SGCAMA_MODE_1920X1536_CROP_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __SGCAMA_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdes.c b/kernel/nvidia/drivers/media/i2c/isx031/serdes.c
new file mode 100644
index 000000000..485c913fd
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdes.c
@@ -0,0 +1,369 @@
+/*
+ * serdes.c - serdes GMSL Expander driver
+ *
+ * Copyright (c) 2021, Fangzhu Tech Corp. All rights reserved.
+ * Based on Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include "serdes.h"
+
+#define SERDES_MODULE_VERSION "1.0.0.0"
+
+#define IS_LINK     (1)
+#define NO_LINK     (0)
+#define SENYUN_ISX031  (0)
+#define SENYUN_ISX031F (1)
+
+struct serdes {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct gpio_desc *pwdn_gpio;
+	int channel;
+	int camA_type, camB_type; //0=Senyun ISX031, 1=Senyun ISX031F(need mfp8 trigger)
+	unsigned char linka,linkb; //0x45, 0x46
+};
+struct serdes *global_priv[2];
+
+#define DBG
+//#define DBG_REG
+static int Deser_write_reg(int channel, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err;
+	int addr_bak;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priv[channel]->i2c_client;
+
+	if(slave_addr != DESERILIAER_ADDR) {
+		addr_bak = global_priv[channel]->i2c_client->addr;
+		global_priv[channel]->i2c_client->addr = slave_addr;
+	}
+	err = regmap_write(global_priv[channel]->regmap, reg, val);
+	#ifdef DBG_REG
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, reg, val);
+	#endif
+
+	if(slave_addr != DESERILIAER_ADDR)
+		global_priv[channel]->i2c_client->addr = addr_bak;
+	usleep_range(200, 500);
+	#ifdef DBG_REG
+	dev_info(&i2c_client->dev, "Serdes [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, slave_addr, reg, val );
+	#endif
+	return err;
+}
+
+int Deser_write_reg_list(int channel, struct deser_reg *table, int size)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err = 0, i;
+	u8 slave_addr;
+	u16 reg;
+	u16 val;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priv[channel]->i2c_client;
+	
+	for(i=0; i<size; i++)
+	{
+		slave_addr = table[i].slave_addr;
+		reg = table[i].reg;
+		val = table[i].val;
+		
+		if(global_priv[channel]->linka == IS_LINK && global_priv[channel]->linkb == NO_LINK){
+		    /* Only Port A Link */
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x21)
+		    {
+		        val = 0x31;
+		    }
+		    if(slave_addr == SERILIAER_ADDR && reg == 0x0000 && val == (SERILIAER_ADDR_B << 1))
+		    {
+		        continue;
+		    }
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x23)
+		    {
+		        /* disable split mode */
+		        continue;
+		    }
+		    if(slave_addr == SERILIAER_ADDR_B){
+		        /* skip configure port B */
+		        continue;
+		    }
+		}
+		else if(global_priv[channel]->linka == NO_LINK && global_priv[channel]->linkb == IS_LINK)
+		{
+		    /* Only Port B Link */
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x21)
+		    {
+		        val = 0x32;
+		    }
+		    if(slave_addr == SERILIAER_ADDR && reg == 0x0000 && val == (SERILIAER_ADDR_A << 1))
+		    {
+		        continue;
+		    }
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x23)
+		    {
+		        /* disable split mode */
+		        continue;
+		    }
+		    if(slave_addr == SERILIAER_ADDR_A){
+		        /* skip configure port A */
+		        continue;
+		    }
+		}
+		else if(global_priv[channel]->linka == NO_LINK && global_priv[channel]->linkb == NO_LINK)
+		{
+		    /* No Port Link */
+		    return 0;
+		}
+		if(slave_addr == GMSL_ADDR) {
+			//dev_info(&i2c_client->dev, "mdelay = %d(ms)\n", val);
+			msleep(val);
+		}
+        else if(slave_addr == SERILIAER_ADDR && reg == 0x0000)
+        {
+            err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+            if(err){
+                slave_addr = (val >> 1); 
+                err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+                if(err){
+                    dev_dbg(&i2c_client->dev, "MAX929x Write failed [0x%02x]:[0x%04x=0x%02x]\n", slave_addr, reg, val);
+                    return err;
+                }
+            }
+        }
+		else
+			err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+
+		if(err!=0)
+			break;
+	}
+
+	return err;
+}
+
+static  struct regmap_config deser_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int Deser_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device dev = client->dev;
+	struct serdes *priv;
+	int err;
+
+	dev_dbg(&dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &deser_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pwdn_gpio = devm_gpiod_get(&client->dev, "pwdn", GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwdn_gpio)) {
+		//dev_info(&dev, "get pwdn value :%d\n", gpiod_get_value(priv->pwdn_gpio));
+		//gpiod_set_value(priv->pwdn_gpio, false);
+		//msleep(200);
+		gpiod_set_value(priv->pwdn_gpio, true);
+		msleep(200);
+	}
+	
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_err(&dev, "channel not found\n");
+	
+	global_priv[priv->channel] = priv;
+	
+	//Set MAX9296 3Gbps
+	err = Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0313, 0x00); 	//disable csi output
+	if (err) {
+		dev_err(&dev, "%s: fail\n", __func__);
+		return 0;
+	}
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0005, 0x80); //LOCK output enabled, disable the others
+	
+	/*detect GMSL Link A */
+	priv->camA_type = SENYUN_ISX031;
+	priv->linka = IS_LINK;
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21);
+	mdelay(200);
+	err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_A<<1);
+	if (err) {
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0006, 0xDF);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x01);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21);
+
+		mdelay(200);
+		priv->camA_type = SENYUN_ISX031F;
+		err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_A<<1);
+		if (err) {
+			priv->camA_type = SENYUN_ISX031;
+			priv->linka = NO_LINK;
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*2);
+			#endif
+		}
+		else {
+			priv->linka = IS_LINK;
+			if(priv->camA_type == SENYUN_ISX031F)
+				err = Deser_write_reg_list(priv->channel, SG_linkA_SY_ISX031F_Ser_init,
+					sizeof(SG_linkA_SY_ISX031F_Ser_init)/sizeof(struct deser_reg));
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2, priv->camB_type);
+			#endif
+		}
+	}
+	else {
+		priv->linka = IS_LINK;
+			if(priv->camA_type == SENYUN_ISX031)
+				err = Deser_write_reg_list(priv->channel, SG_linkA_SY_ISX031_Ser_init,
+					sizeof(SG_linkA_SY_ISX031_Ser_init)/sizeof(struct deser_reg));
+		#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2, priv->camA_type);
+		#endif
+	}
+	
+	/*detect GMSL Link B */
+	priv->camB_type = SENYUN_ISX031;
+	priv->linkb = IS_LINK;
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x22);
+	mdelay(200);
+	err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_B<<1);
+	if (err) {
+		priv->camB_type = SENYUN_ISX031F;
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0006, 0xDF);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x01);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x22);
+		mdelay(200);
+		err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_B<<1);
+		if (err) {
+			priv->camB_type = SENYUN_ISX031;
+			priv->linkb = NO_LINK;
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21); //switch to linkA
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*2+1);
+			#endif
+		}
+		else {
+			priv->linkb = IS_LINK;
+			if(priv->camB_type == SENYUN_ISX031F)
+				err = Deser_write_reg_list(priv->channel, SG_linkB_SY_ISX031F_Ser_init,
+					sizeof(SG_linkB_SY_ISX031F_Ser_init)/sizeof(struct deser_reg));
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2+1, priv->camB_type);
+			#endif
+		}
+	}
+	else {
+		priv->linkb = IS_LINK;
+		if(priv->camB_type == SENYUN_ISX031)
+			err = Deser_write_reg_list(priv->channel, SG_linkB_SY_ISX031_Ser_init,
+				sizeof(SG_linkB_SY_ISX031_Ser_init)/sizeof(struct deser_reg));
+		#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2+1, priv->camA_type);
+		#endif
+	}
+	if(priv->linka == IS_LINK || priv->linkb == IS_LINK) {
+		err = Deser_write_reg_list(priv->channel, SG_Deser_MAX9296_init,
+				sizeof(SG_Deser_MAX9296_init)/sizeof(struct deser_reg));
+	}
+
+	return 0;
+}
+
+int Deser_lock(int channel)
+{
+	if(global_priv[channel]->linka == IS_LINK || global_priv[channel]->linkb == IS_LINK)
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(Deser_lock);
+
+static int Deser_remove(struct i2c_client *client)
+{
+	if (client != NULL) {
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id Deser_id[] = {
+	{ "serdes", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, Deser_id);
+
+const struct of_device_id Deser_of_match[] = {
+	{ .compatible = "nvidia,serdes", },
+	{ },
+};
+
+static struct i2c_driver Deser_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "serdes",
+		.of_match_table = of_match_ptr(Deser_of_match),
+	},
+	.probe = Deser_probe,
+	.remove = Deser_remove,
+	.id_table = Deser_id,
+};
+
+static int __init Deser_init(void)
+{
+	return i2c_add_driver(&Deser_i2c_driver);
+}
+
+static void __exit Deser_exit(void)
+{
+	i2c_del_driver(&Deser_i2c_driver);
+}
+
+module_init(Deser_init);
+module_exit(Deser_exit);
+
+MODULE_DESCRIPTION("IO Expander Driver MAX9296 Sensing-World");
+MODULE_AUTHOR("Sensing-World Tech Corporation");
+MODULE_VERSION(SERDES_MODULE_VERSION);
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdes.h b/kernel/nvidia/drivers/media/i2c/isx031/serdes.h
new file mode 100644
index 000000000..e4ae6ddd2
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdes.h
@@ -0,0 +1,196 @@
+#ifndef __SERDES_H__
+#define __SERDES_H__
+
+#define GMSL_TABLE_END 0xffff
+#define GMSL_WAIT_MS 0x55
+#define GMSL_ADDR 0x08
+
+struct deser_reg
+{
+	u16 slave_addr;
+	u16 reg;
+	u16 val;
+};
+
+#define DESERILIAER_ADDR    0x48
+#define SERILIAER_ADDR      0x62
+#define SERILIAER_ADDR_A    0x41
+#define SERILIAER_ADDR_B    0x42
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkA_SY_ISX031_Ser_init[] = {
+	{SERILIAER_ADDR_A, 0x0010, 0x21},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+
+	{SERILIAER_ADDR_A, 0x006b, 0x16},
+	{SERILIAER_ADDR_A, 0x0073, 0x17},
+	{SERILIAER_ADDR_A, 0x007b, 0x36},
+	{SERILIAER_ADDR_A, 0x0083, 0x36},
+	{SERILIAER_ADDR_A, 0x008b, 0x36},
+	{SERILIAER_ADDR_A, 0x0093, 0x36},
+	{SERILIAER_ADDR_A, 0x009b, 0x36},
+	{SERILIAER_ADDR_A, 0x00a3, 0x36},
+	{SERILIAER_ADDR_A, 0x00ab, 0x36},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x02be, 0x10},
+	{SERILIAER_ADDR_A, 0x02d3, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 500},
+
+	// {SERILIAER_ADDR_A, 0x02d3, 0x00},
+	{SERILIAER_ADDR_A, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 300},
+	{SERILIAER_ADDR_A, 0x0308, 0x62},
+	{SERILIAER_ADDR_A, 0x0311, 0xF0}, //Start Video Pipeline on CSI PortB
+	{SERILIAER_ADDR_A, 0x0316, 0x5E}, //Set DT
+	{SERILIAER_ADDR_A, 0x0318, 0x62},
+	{SERILIAER_ADDR_A, 0x0002, 0xF3}, //Turn on all pipeline
+	// {SERILIAER_ADDR_A, 0x02d3, 0x84},
+	// {SERILIAER_ADDR_A, 0x02d5, 0x07},
+	{SERILIAER_ADDR_A, 0x02d6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{SERILIAER_ADDR_A, 0x02d6, 0x84},
+	{SERILIAER_ADDR_A, 0x02d8, 0x07}, // mfp8 trigger
+
+};
+
+static struct deser_reg SG_linkA_SY_ISX031F_Ser_init[] = {
+	{SERILIAER_ADDR_A, 0x02d3, 0x00},
+	{SERILIAER_ADDR_A, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+	{SERILIAER_ADDR_A, 0x02d3, 0x10},
+	//{SERILIAER_ADDR_A, 0x02d3, 0x84},
+	{SERILIAER_ADDR_A, 0x02d5, 0x07}, // mfp7 trigger
+	{SERILIAER_ADDR_A, 0x02d6, 0x10},
+	//{SERILIAER_ADDR_A, 0x02d6, 0x84},
+	{SERILIAER_ADDR_A, 0x02d8, 0x07}, // mfp8 trigger
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x006b, 0x16},
+	{SERILIAER_ADDR_A, 0x0073, 0x17},
+	{SERILIAER_ADDR_A, 0x007b, 0x36},
+	{SERILIAER_ADDR_A, 0x0083, 0x36},
+	{SERILIAER_ADDR_A, 0x008b, 0x36},
+	{SERILIAER_ADDR_A, 0x0093, 0x36},
+	{SERILIAER_ADDR_A, 0x009b, 0x36},
+	{SERILIAER_ADDR_A, 0x00a3, 0x36},
+	{SERILIAER_ADDR_A, 0x00ab, 0x36},
+	{SERILIAER_ADDR_A, 0x0044, 0x36},
+	{SERILIAER_ADDR_A, 0x0045, 0x20},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x005B, 0x01}, // Stream ID
+	{SERILIAER_ADDR_A, 0x0318, 0x5e}, // Set DT YUV-422 8Bit
+	{SERILIAER_ADDR_A, 0x0331, 0x33}, // 4Lanes
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkB_SY_ISX031_Ser_init[] = {
+	{SERILIAER_ADDR_B, 0x0010, 0x22},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+
+	{SERILIAER_ADDR_B, 0x006b, 0x16},
+	{SERILIAER_ADDR_B, 0x0073, 0x17},
+	{SERILIAER_ADDR_B, 0x007b, 0x37},
+	{SERILIAER_ADDR_B, 0x0083, 0x37},
+	{SERILIAER_ADDR_B, 0x008b, 0x37},
+	{SERILIAER_ADDR_B, 0x0093, 0x37},
+	{SERILIAER_ADDR_B, 0x009b, 0x37},
+	{SERILIAER_ADDR_B, 0x00a3, 0x37},
+	{SERILIAER_ADDR_B, 0x00ab, 0x37},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x02be, 0x10},
+	{SERILIAER_ADDR_B, 0x02d3, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 500},
+
+	// {SERILIAER_ADDR_B, 0x02d3, 0x00},
+	{SERILIAER_ADDR_B, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 300},
+	{SERILIAER_ADDR_B, 0x0308, 0x64},
+	{SERILIAER_ADDR_B, 0x0311, 0xF0}, //Start Video Pipeline on CSI PortB
+	{SERILIAER_ADDR_B, 0x0316, 0x62},
+	{SERILIAER_ADDR_B, 0x0318, 0x5E}, //Set DT
+	{SERILIAER_ADDR_B, 0x0002, 0xF3}, //Turn on all pipeline
+	// {SERILIAER_ADDR_B, 0x02d3, 0x84},
+	// {SERILIAER_ADDR_B, 0x02d5, 0x07},
+	{SERILIAER_ADDR_B, 0x02d6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{SERILIAER_ADDR_B, 0x02d6, 0x84},
+	{SERILIAER_ADDR_B, 0x02d8, 0x07}, // mfp8 trigger
+};
+
+static struct deser_reg SG_linkB_SY_ISX031F_Ser_init[] = {
+	{SERILIAER_ADDR_B, 0x02d3, 0x00},
+	{SERILIAER_ADDR_B, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+	{SERILIAER_ADDR_B, 0x02d3, 0x10},
+	//{SERILIAER_ADDR_B, 0x02d3, 0x84},
+	{SERILIAER_ADDR_B, 0x02d5, 0x07}, // mfp7 trigger
+	{SERILIAER_ADDR_B, 0x02d6, 0x10},
+	//{SERILIAER_ADDR_B, 0x02d6, 0x84},
+	{SERILIAER_ADDR_B, 0x02d8, 0x07}, // mfp8 trigger
+
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x006b, 0x16},
+	{SERILIAER_ADDR_B, 0x0073, 0x17},
+	{SERILIAER_ADDR_B, 0x007b, 0x37},
+	{SERILIAER_ADDR_B, 0x0083, 0x37},
+	{SERILIAER_ADDR_B, 0x008b, 0x37},
+	{SERILIAER_ADDR_B, 0x0093, 0x37},
+	{SERILIAER_ADDR_B, 0x009b, 0x37},
+	{SERILIAER_ADDR_B, 0x00a3, 0x37},
+	{SERILIAER_ADDR_B, 0x00ab, 0x37},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x0318, 0x5e}, // Set DT YUV-422 8Bit
+	{SERILIAER_ADDR_B, 0x005B, 0x02}, // Stream ID
+	{SERILIAER_ADDR_B, 0x0331, 0x33}, // 4Lanes
+};
+
+static struct deser_reg SG_Deser_MAX9296_init[] = {
+	{DESERILIAER_ADDR, 0x0010, 0x23},
+	
+	{DESERILIAER_ADDR, 0x0320, 0x2F}, 
+	// Deserializer MIPI MAP SRC->DST three
+	{DESERILIAER_ADDR, 0x044B, 0x07}, // Pipe Y MAP enable - three
+	{DESERILIAER_ADDR, 0x048B, 0x07}, // Pipe Z MAP enable - three
+
+	{DESERILIAER_ADDR, 0x042D, 0x00},
+	{DESERILIAER_ADDR, 0x046D, 0x15}, // Pipe Y To MIPI port A -> 0X44B
+	{DESERILIAER_ADDR, 0x04AD, 0x15}, // Pipe Z To MIPI port A -> 0X48B
+	{DESERILIAER_ADDR, 0x04ED, 0x00},
+	// Pipeline Y -> VC=0, DT=1E
+	{DESERILIAER_ADDR, 0x044D, 0x1e}, // Pipeline Y mapping src (YUV422 8Bit) 
+	{DESERILIAER_ADDR, 0x044E, 0x1e}, // Pipeline Y YUV422 8Bit mapping
+	{DESERILIAER_ADDR, 0x044F, 0x00}, // Pipeline Y FS mapping
+	{DESERILIAER_ADDR, 0x0450, 0x00}, // Pipeline Y FS mapping
+	{DESERILIAER_ADDR, 0x0451, 0x01}, // Pipeline Y FE mapping
+	{DESERILIAER_ADDR, 0x0452, 0x01}, // Pipeline Y FE mapping
+	// Pipeline Z -> VC=1, DT=1E
+	{DESERILIAER_ADDR, 0x048D, 0x1e}, // Pipeline Z mapping src (YUV422 8Bit) 
+	{DESERILIAER_ADDR, 0x048E, 0x5e}, // Pipeline Z YUV422 8Bit mapping
+	{DESERILIAER_ADDR, 0x048F, 0x00}, // Pipeline Z FS mapping
+	{DESERILIAER_ADDR, 0x0490, 0x40}, // Pipeline Z FS mapping
+	{DESERILIAER_ADDR, 0x0491, 0x01}, // Pipeline Z FE mapping
+	{DESERILIAER_ADDR, 0x0492, 0x41}, // Pipeline Z FE mapping
+
+	{DESERILIAER_ADDR, 0x044A, 0xC0}, // four lane output from MIPI Port A
+	{DESERILIAER_ADDR, 0x048A, 0xC0}, // four lane output from MIPI Port A
+
+	{DESERILIAER_ADDR, 0x0003, 0x40}, // MFP6 used as GPI, disable UTART1 function
+	{DESERILIAER_ADDR, 0x0B08, 0x20}, // GPI-to-GPO
+	{DESERILIAER_ADDR, 0x02C2, 0x83}, // mfp6 config MAX9296->MAX9295 mfp8 passthrough
+	{DESERILIAER_ADDR, 0x02C3, 0xA7}, // mfp6 config
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{DESERILIAER_ADDR, 0x0313, 0x02}, // Enable MIPI output
+};
+
+#endif
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
new file mode 100644
index 000000000..cb08d226c
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
@@ -0,0 +1,325 @@
+/*
+ * serdesaa.c - serdesaa GMSL Expander driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include "serdesa.h"
+
+#define SERDESA_MODULE_VERSION "1.0.1.0"
+
+#define IS_LINK     (1)
+#define NO_LINK     (0)
+//MAX96712
+
+struct serdesa {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct gpio_desc *pwdn_gpio;
+	int channel;
+	unsigned char videoa,videob,videoc,videod; //0x41, 0x42, 0x43, 0x44
+};
+struct serdesa *global_priva[2];
+
+#define DBG
+//#define DBG_REG
+static int serdesa_write_reg(int channel, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err;
+	int addr_bak;
+
+	if(channel > 2 || channel < 0)
+		return -1;
+	
+
+	i2c_client = global_priva[channel]->i2c_client;
+	if(slave_addr != DESERILIAER_ADDR) {
+		addr_bak = global_priva[channel]->i2c_client->addr;
+		global_priva[channel]->i2c_client->addr = slave_addr;
+	}
+	err = regmap_write(global_priva[channel]->regmap, reg, val);
+	#ifdef DBG_REG
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, reg, val);
+	#endif
+
+	usleep_range(200, 500);
+	#ifdef DBG_REG
+	if(slave_addr != DESERILIAER_ADDR) 
+		dev_info(&i2c_client->dev, "serdesa: [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, global_priva[channel]->i2c_client->addr, reg, val );
+	else 
+		dev_info(&i2c_client->dev, "serdesa: [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, global_priva[channel]->i2c_client->addr, reg, val );
+	#endif
+
+	if(slave_addr != DESERILIAER_ADDR)
+		global_priva[channel]->i2c_client->addr = addr_bak;
+	
+	return err;
+}
+// static int serdesa_read_reg(int channel, u8 slave_addr, u16 reg, unsigned int *val)
+// {
+// 	struct i2c_client *i2c_client = NULL;
+// 	int err;
+// 	int addr_bak;
+// 	if(channel > 3 || channel < 0)
+// 		return -1;
+// 	i2c_client = global_priva[channel]->i2c_client;
+// 	addr_bak = global_priva[channel]->i2c_client->addr;
+// 	global_priva[channel]->i2c_client->addr = slave_addr;
+// 	err = regmap_read(global_priva[channel]->regmap, reg, val);
+// 	if (err)
+// 		dev_err(&i2c_client->dev, "%s:i2c read failed, 0x%x = %x\n",
+// 			__func__, reg, *val);
+// 	global_priva[channel]->i2c_client->addr = addr_bak;
+// 	#ifndef DBG_REG
+// 	dev_info(&i2c_client->dev, "MAX929x[%d-0x%02x]:[0x%04x=0x%02x]\n", channel, slave_addr, reg, *val);
+// 	#endif
+// 	if(err)
+// 		return 0;
+// 	return 1;
+// }
+
+int serdesa_write_reg_list(int channel, struct deser_reg *table, int size)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err = 0, i;
+	u8 slave_addr;
+	u16 reg;
+	u16 val;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priva[channel]->i2c_client;
+	
+	for(i=0; i<size; i++)
+	{
+		slave_addr = table[i].slave_addr;
+		reg = table[i].reg;
+		val = table[i].val;
+		
+		if(slave_addr == GMSL_ADDR) {
+			//dev_info(&i2c_client->dev, "mdelay = %d(ms)\n", val);
+			msleep(val);
+		}
+        else if(slave_addr == SERILIAER_ADDR && reg == 0x0000)
+        {
+            err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+            if(err){
+                slave_addr = (val >> 1); 
+                err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+                if(err){
+                    dev_dbg(&i2c_client->dev, "MAX929x Write failed [0x%02x]:[0x%04x=0x%02x]\n", slave_addr, reg, val);
+                    return err;
+                }
+            }
+        }
+		else
+			err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+
+		if(err!=0)
+			break;
+	}
+
+	return err;
+}
+
+static  struct regmap_config deser_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int serdesa_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device dev = client->dev;
+	struct serdesa *priv;
+	int err, cnt=0;//, tmp;
+
+	dev_dbg(&dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &deser_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pwdn_gpio = devm_gpiod_get(&client->dev, "pwdn", GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwdn_gpio)) {
+		//dev_info(&dev, "get pwdn value :%d\n", gpiod_get_value(priv->pwdn_gpio));
+		//gpiod_set_value(priv->pwdn_gpio, false);
+		//msleep(200);
+		gpiod_set_value(priv->pwdn_gpio, true);
+		msleep(200);
+	}
+	
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_err(&dev, "channel not found\n");
+	
+	global_priva[priv->channel] = priv;
+	
+	//sensing camera
+	// err = serdesa_write_reg_list(priv->channel, SG_Deser_6G_init,
+	// 		sizeof(SG_Deser_6G_init)/sizeof(struct deser_reg));
+	// err = serdesa_read_reg(priv->channel, SERILIAER_ADDR, 0x00, &tmp);
+	// if(tmp != 0x80)
+	// 	err = serdesa_write_reg_list(priv->channel, SG_Deser_3G_init,
+	// 		sizeof(SG_Deser_3G_init)/sizeof(struct deser_reg));
+	// err = serdesa_write_reg_list(priv->channel, SG_Deser_init,
+	// 		sizeof(SG_Deser_init)/sizeof(struct deser_reg));
+	//otobrite camera
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_6G_init,
+			sizeof(SG_Deser_6G_init)/sizeof(struct deser_reg));
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_init,
+			sizeof(SG_Deser_init)/sizeof(struct deser_reg));
+			
+	/*detect GMSL Link A */
+	priv->videoa = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkA_Dser_Ser_init,
+		sizeof(SG_linkA_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videoa = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4);
+		#endif
+	}
+	else {
+		priv->videoa = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4);
+		#endif
+	}
+	/*detect GMSL Link B */
+	priv->videob = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkB_Dser_Ser_init,
+		sizeof(SG_linkB_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videob = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+1);
+		#endif
+	}
+	else {
+		priv->videob = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+1);
+		#endif
+	}
+	/*detect GMSL Link C */
+	priv->videoc = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkC_Dser_Ser_init,
+		sizeof(SG_linkC_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videoc = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+2);
+		#endif
+	}
+	else {
+		priv->videoc = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+2);
+		#endif
+	}
+	/*detect GMSL Link D */
+	priv->videod = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkD_Dser_Ser_init,
+		sizeof(SG_linkD_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videod = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+3);
+		#endif
+	}
+	else {
+		priv->videod = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+3);
+		#endif
+	}
+
+	cnt = priv->videoa + priv->videob + priv->videoc + priv->videod;
+    if(cnt > 3)
+    {
+		serdesa_write_reg(priv->channel, DESERILIAER_ADDR, 0x0418, 0x33);
+    }
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_End_init,
+		sizeof(SG_Deser_End_init)/sizeof(struct deser_reg));
+	return 0;
+}
+
+static int serdesa_remove(struct i2c_client *client)
+{
+	if (client != NULL) {
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id serdesa_id[] = {
+	{ "serdesa", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, serdesa_id);
+
+const struct of_device_id serdesa_of_match[] = {
+	{ .compatible = "nvidia,serdesa", },
+	{ },
+};
+
+static struct i2c_driver serdesa_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "serdesa",
+		.of_match_table = of_match_ptr(serdesa_of_match),
+	},
+	.probe = serdesa_probe,
+	.remove = serdesa_remove,
+	.id_table = serdesa_id,
+};
+
+static int __init serdesa_init(void)
+{
+	return i2c_add_driver(&serdesa_i2c_driver);
+}
+
+static void __exit serdesa_exit(void)
+{
+	i2c_del_driver(&serdesa_i2c_driver);
+}
+
+module_init(serdesa_init);
+module_exit(serdesa_exit);
+
+MODULE_DESCRIPTION("IO Expander Driver MAX96712 Sensing-World");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_VERSION(SERDESA_MODULE_VERSION);
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h
new file mode 100644
index 000000000..c4479693d
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h
@@ -0,0 +1,239 @@
+#ifndef __SERDESA_H__
+#define __SERDESA_H__
+/*
+* 2023-02-12 4-IMX390 need set CSI Rate to 0x2F 
+* 0x2D3 Rising
+* 0x2D6 Rising
+*
+*/
+
+#define GMSL_TABLE_END  0xffff
+#define GMSL_WAIT_MS 	0x55
+#define GMSL_ADDR 		0x08
+
+struct deser_reg {
+	u16 slave_addr;
+	u16 reg;
+	u16 val;
+};
+
+#define DESERILIAER_ADDR    0x29
+#define SERILIAER_ADDR      0x62
+#define SERILIAER_ADDR_A    0x41
+#define SERILIAER_ADDR_B    0x42
+#define SERILIAER_ADDR_C    0x43
+#define SERILIAER_ADDR_D    0x44
+#define WR_PARAM
+
+// static struct deser_reg SG_Deser_3G_init[] = {
+// 	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+// 	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable link A
+// 	{DESERILIAER_ADDR, 0x0010, 0x11},
+// 	{DESERILIAER_ADDR, 0x0011, 0x11},
+// };
+static struct deser_reg SG_Deser_6G_init[] = {
+	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable link A
+	{DESERILIAER_ADDR, 0x0010, 0x22},
+	{DESERILIAER_ADDR, 0x0011, 0x22},
+};
+static struct deser_reg SG_Deser_init[] = {
+	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+	{DESERILIAER_ADDR, 0x0006, 0xF0}, // Enable link A
+	
+	//3G Settings
+
+	{DESERILIAER_ADDR, 0x00F0, 0x62},
+	{DESERILIAER_ADDR, 0x00F1, 0xEA},
+	{DESERILIAER_ADDR, 0x00F4, 0x0F},
+
+	// Video Pipe to MIPI Controller Mapping
+	// YUV422 8bit, video pipe 0, map FS/FE, Four pipiline in and PortA csi output
+	{DESERILIAER_ADDR, 0x090B, 0x07}, 
+	{DESERILIAER_ADDR, 0x092D, 0x15}, //map to MIPI Controller 0
+	{DESERILIAER_ADDR, 0x090D, 0x1E}, //map to VC0
+	{DESERILIAER_ADDR, 0x090E, 0x1E},
+	{DESERILIAER_ADDR, 0x090F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0910, 0x00},
+	{DESERILIAER_ADDR, 0x0911, 0x01},
+	{DESERILIAER_ADDR, 0x0912, 0x01},
+	
+	// YUV422 8bit, video pipe 1, map FS/FE
+	{DESERILIAER_ADDR, 0x094B, 0x07},
+	{DESERILIAER_ADDR, 0x096D, 0x15}, //map to MIPI Controller 1
+	{DESERILIAER_ADDR, 0x094D, 0x1E}, //map to VC1
+	{DESERILIAER_ADDR, 0x094E, 0x5E},
+	{DESERILIAER_ADDR, 0x094F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0950, 0x40},
+	{DESERILIAER_ADDR, 0x0951, 0x01},
+	{DESERILIAER_ADDR, 0x0952, 0x41},
+	
+	// YUV422 8bit, video pipe 2, map FS/FE
+	{DESERILIAER_ADDR, 0x098B, 0x07},
+	{DESERILIAER_ADDR, 0x09AD, 0x15}, //map to MIPI Controller 2
+	{DESERILIAER_ADDR, 0x098D, 0x1E}, //map to VC2
+	{DESERILIAER_ADDR, 0x098E, 0x9E},
+	{DESERILIAER_ADDR, 0x098F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0990, 0x80},
+	{DESERILIAER_ADDR, 0x0991, 0x01},
+	{DESERILIAER_ADDR, 0x0992, 0x81},
+	
+	// YUV422 8bit, video pipe 3, map FS/FE
+	{DESERILIAER_ADDR, 0x09CB, 0x07},
+	{DESERILIAER_ADDR, 0x09ED, 0x15}, //map to MIPI Controller 3
+	{DESERILIAER_ADDR, 0x09CD, 0x1E}, //map to VC3
+	{DESERILIAER_ADDR, 0x09CE, 0xDE},
+	{DESERILIAER_ADDR, 0x09CF, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x09D0, 0xC0},
+	{DESERILIAER_ADDR, 0x09D1, 0x01},
+	{DESERILIAER_ADDR, 0x09D2, 0xC1},
+
+	{GMSL_ADDR, GMSL_WAIT_MS, 20}, 
+	{DESERILIAER_ADDR, 0x08A0, 0x04}, //PHY 2x4 MIPI output configured as two ports with four data lanes each. PHY0 and PHY1 combined, and PHY2 and PHY3 combined.
+	{DESERILIAER_ADDR, 0x08A3, 0xE4}, //default 0x4E, 0xE4:MIPI PHY1/PHY0 lane mapping PHY1:D1-D3/D0-D2, PHY0:D1-D1/D0-D0
+	{DESERILIAER_ADDR, 0x08A4, 0xE4}, //default 0xE4, 0xE4:MIPI PHY3/PHY2 lane mapping PHY3:D1-D3/D0-D2, PHY2:D1-D1/D0-D0
+
+	// Set 4 lane D-PHY (Default setting)
+	{DESERILIAER_ADDR, 0x090A, 0xC0},
+	{DESERILIAER_ADDR, 0x094A, 0xC0},
+	{DESERILIAER_ADDR, 0x098A, 0xC0},
+	{DESERILIAER_ADDR, 0x09CA, 0xC0},
+
+	// Turn on MIPI PHYs
+	{DESERILIAER_ADDR, 0x08A2, 0xF0},
+	
+	// Set MIPI Data rate to be 2400Mbps/lane for port A and enable software override
+	{DESERILIAER_ADDR, 0x0415, 0x2F}, //Lower than 8M set to 0x2F
+	{DESERILIAER_ADDR, 0x0418, 0x2F},
+	{DESERILIAER_ADDR, 0x041B, 0x2F},
+	{DESERILIAER_ADDR, 0x041E, 0x2F},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkA_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF1}, // Turn on GMSL2 mode for link A 
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7},
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x82},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkB_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF2}, // Turn on GMSL2 mode for link B
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7},
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x84},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkC_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF4}, // Turn on GMSL2 mode for link C
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100},
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7}, 
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x86},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkD_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF8}, // Turn on GMSL2 mode for link D 
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30},
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7}, 
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x88},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+
+static struct deser_reg SG_Deser_End_init[] = {
+	{DESERILIAER_ADDR, 0x0313, 0x83},
+	{DESERILIAER_ADDR, 0x0314, 0xa7}, //LinkA
+	{DESERILIAER_ADDR, 0x034A, 0xa7}, //LinkB
+	{DESERILIAER_ADDR, 0x0381, 0xa7}, //LinkC
+	{DESERILIAER_ADDR, 0x03B7, 0xa7}, //LinkD
+	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable all links back
+	{DESERILIAER_ADDR, 0x0018, 0x0F}, // One-shot link reset for all links
+	{GMSL_ADDR, GMSL_WAIT_MS, 100},
+	{DESERILIAER_ADDR, 0x040b, 0x02}, // Enable MIPI Output
+	{DESERILIAER_ADDR, 0x08a0, 0x84},
+};
+
+#endif
-- 
2.51.0

