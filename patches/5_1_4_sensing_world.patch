From 90b7e99e42eba1cd78a69e7e7e1a68a98cb98b55 Mon Sep 17 00:00:00 2001
From: Alexander Hoffman <alxhoff@gmail.com>
Date: Fri, 29 Nov 2024 14:20:37 +0100
Subject: [PATCH] Resolved merging SW changes into 5.1.4

---
 .../tegra234-p3737-0000-camera-d4xx-qual.dtsi | 1484 +++++
 .../cvb/tegra234-p3737-fixed-regulator.dtsi   |    4 +-
 .../tegra234-p3701-0000-p3737-0000.dts        |    3 +-
 kernel/nvidia/drivers/media/i2c/Kconfig       |   21 +
 kernel/nvidia/drivers/media/i2c/Makefile      |    4 +
 kernel/nvidia/drivers/media/i2c/d4xx.c        | 5700 +++++++++++++++++
 .../nvidia/drivers/media/i2c/isx031/Makefile  |    8 +
 .../nvidia/drivers/media/i2c/isx031/fzcam.c   |  819 +++
 .../media/i2c/isx031/fzcam_mode_tbls.h        |   78 +
 .../nvidia/drivers/media/i2c/isx031/fzcama.c  |  819 +++
 .../media/i2c/isx031/fzcama_mode_tbls.h       |   78 +
 .../nvidia/drivers/media/i2c/isx031/serdes.c  |  369 ++
 .../nvidia/drivers/media/i2c/isx031/serdes.h  |  196 +
 .../nvidia/drivers/media/i2c/isx031/serdesa.c |  325 +
 .../nvidia/drivers/media/i2c/isx031/serdesa.h |  239 +
 kernel/nvidia/drivers/media/i2c/max9295.c     |  206 +-
 kernel/nvidia/drivers/media/i2c/max9296.c     |  242 +-
 .../camera/fusa-capture/capture-vi-channel.c  |   29 +-
 .../platform/tegra/camera/sensor_common.c     |    4 +
 .../media/platform/tegra/camera/vi/channel.c  |  410 +-
 .../media/platform/tegra/camera/vi/graph.c    |   48 +-
 .../platform/tegra/camera/vi/mc_common.c      |   32 +
 .../platform/tegra/camera/vi/vi4_formats.h    |   32 +-
 .../media/platform/tegra/camera/vi/vi5_fops.c |  122 +-
 .../platform/tegra/camera/vi/vi5_formats.h    |   30 +-
 .../tegra/camera/tegra_camera_platform.c      |    5 +
 kernel/nvidia/include/media/gmsl-link.h       |    3 +
 kernel/nvidia/include/media/max9295.h         |    4 +
 kernel/nvidia/include/media/max9296.h         |    8 +
 kernel/nvidia/include/media/mc_common.h       |   23 +
 .../nvidia/include/media/tegra_camera_core.h  |   10 +-
 31 files changed, 11293 insertions(+), 62 deletions(-)
 create mode 100644 hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-camera-d4xx-qual.dtsi
 create mode 100644 kernel/nvidia/drivers/media/i2c/d4xx.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/Makefile
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdes.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdes.h
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/isx031/serdesa.h

diff --git a/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-camera-d4xx-qual.dtsi b/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-camera-d4xx-qual.dtsi
new file mode 100644
index 0000000..2cc5e5f
--- /dev/null
+++ b/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-0000-camera-d4xx-qual.dtsi
@@ -0,0 +1,1484 @@
+#include "dt-bindings/clock/tegra234-clock.h"
+
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(AC, 0)
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(H, 3)
+#define CAM2_PWDN	TEGRA234_MAIN_GPIO(H, 6)
+#define CAM3_PWDN	TEGRA234_MAIN_GPIO(AC, 1)
+
+#define ISX031_POC	TEGRA234_MAIN_GPIO(AC, 4)
+#define D457_POC	TEGRA234_MAIN_GPIO(AC, 7)
+
+//driver version 1.0
+
+//driver version 1.1
+//CAM_INT1 120 connector-117pin  
+#define ISX031_SYNC	TEGRA234_AON_GPIO(CC, 0)
+//CAM_INT3 120 connector-103pin  
+#define D457_SYNC	TEGRA234_AON_GPIO(CC, 2)
+
+#define CAMERA_I2C_MUX_BUS(x) (0x1E + x)
+
+/ {
+	gpio@2200000 {
+		cam-pwdn-high {
+			gpio-hog;
+			output-high;
+			gpios = <CAM0_PWDN 0 CAM1_PWDN 0
+				 CAM2_PWDN 0 CAM3_PWDN 0>;
+			label = "cam0-pwdn", "cam1-pwdn",
+				"cam2-pwdn", "cam3-pwdn";
+		};
+		cam-poc-high {
+			gpio-hog;
+			output-high;
+			gpios = <ISX031_POC 0 D457_POC 0>;
+			label = "isx031-poc", "d457-poc";
+		};
+	};
+
+	tegra-capture-vi {
+		num-channels = <14>;
+
+		ports {
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			//SG10A_ORIN_GMSL2 adapt board port J25/J26 for D457
+			port@0 {
+				reg = <0>;
+				status = "ok";
+
+				vi_in0: endpoint {
+					status = "ok";
+					port-index = <4>;
+					bus-width = <2>;
+					vc-id = <0>;
+					remote-endpoint = <&csi_out0>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+				status = "ok";
+
+				vi_in1: endpoint {
+					status = "ok";
+					port-index = <4>;
+					bus-width = <2>;
+					vc-id = <1>;
+					remote-endpoint = <&csi_out1>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+				status = "ok";
+
+				vi_in2: endpoint {
+					status = "ok";
+					port-index = <4>;
+					bus-width = <2>;
+					vc-id = <2>;
+					remote-endpoint = <&csi_out2>;
+				};
+			};
+			port@3 {
+				reg = <3>;
+				status = "ok";
+
+				vi_in3: endpoint {
+					status = "ok";
+					port-index = <4>;
+					bus-width = <2>;
+					vc-id = <3>;
+					remote-endpoint = <&csi_out3>;
+				};
+			};
+			//SG10A_ORIN_GMSL2 adapt board port J23/J24 for D457
+			port@4 {
+				reg = <4>;
+				status = "ok";
+
+				vi_in4: endpoint {
+					status = "ok";
+					port-index = <2>;
+					bus-width = <2>;
+					vc-id = <0>;
+					remote-endpoint = <&csi_out4>;
+				};
+			};
+			port@5 {
+				reg = <5>;
+				status = "ok";
+
+				vi_in5: endpoint {
+					status = "ok";
+					port-index = <2>;
+					bus-width = <2>;
+					vc-id = <1>;
+					remote-endpoint = <&csi_out5>;
+				};
+			};
+			port@6 {
+				reg = <6>;
+				status = "ok";
+
+				vi_in6: endpoint {
+					status = "ok";
+					port-index = <2>;
+					bus-width = <2>;
+					vc-id = <2>;
+					remote-endpoint = <&csi_out6>;
+				};
+			};
+			port@7 {
+				reg = <7>;
+				status = "ok";
+
+				vi_in7: endpoint {
+					status = "ok";
+					port-index = <2>;
+					bus-width = <2>;
+					vc-id = <3>;
+					remote-endpoint = <&csi_out7>;
+				};
+			};
+			//isx031 camera
+			port@8 {
+				reg = <8>;
+				fzcam_vi_in0: endpoint {
+					vc-id = <0>;
+					port-index = <0>;
+					bus-width = <4>;
+					remote-endpoint = <&fzcam_csi_out0>;
+				};
+			};
+			port@9 {
+				reg = <9>;
+				fzcam_vi_in1: endpoint {
+					vc-id = <1>;
+					port-index = <0>;
+					bus-width = <4>;
+					remote-endpoint = <&fzcam_csi_out1>;
+				};
+			};
+			port@10 {
+				reg = <10>;
+				fzcam_vi_in2: endpoint {
+					vc-id = <0>;
+					port-index = <5>;
+					bus-width = <4>;
+					remote-endpoint = <&fzcam_csi_out2>;
+				};
+			};
+			port@11 {
+				reg = <11>;
+				fzcam_vi_in3: endpoint {
+					vc-id = <1>;
+					port-index = <5>;
+					bus-width = <4>;
+					remote-endpoint = <&fzcam_csi_out3>;
+				};
+			};
+			port@12 {
+				reg = <12>;
+				fzcam_vi_in4: endpoint {
+					vc-id = <2>;
+					port-index = <5>;
+					bus-width = <4>;
+					remote-endpoint = <&fzcam_csi_out4>;
+				};
+			};
+			port@13 {
+				reg = <13>;
+				fzcam_vi_in5: endpoint {
+					vc-id = <3>;
+					port-index = <5>;
+					bus-width = <4>;
+					remote-endpoint = <&fzcam_csi_out5>;
+				};
+			};
+		};
+	};
+
+	i2c@3180000 {
+		status = "ok";
+		clock-frequency = <100000>;
+		tca9546@70 {
+			status = "ok";
+			reg = <0x70>;
+			compatible = "nxp,pca9546";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			skip_mux_detect = "yes";
+			vif-supply = <&p3737_vdd_1v8_sys>;
+			vcc-supply = <&p3737_vdd_1v8_sys>;
+			vcc-pullup-supply = <&battery_reg>;
+			force_bus_start = <CAMERA_I2C_MUX_BUS(0)>;
+			vcc_lp = "vcc";
+
+			i2c@0 {
+				reg = <0x0>;
+				#address-cells = <0x1>;
+				#size-cells = <0x0>;
+				i2c-mux,deselect-on-exit;
+				
+				dser0: max9296@48 {
+					status = "ok";
+					reg = <0x48>;
+					compatible = "maxim,max9296";
+					csi-mode = "2x4";
+					max-src = <2>;
+					reset-gpios = <&tegra_main_gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+				};
+
+				ser0_prim: max9295_prim@40 {
+					status = "ok";
+					reg = <0x40>;
+					compatible = "maxim,max9295_0";
+					is-prim-ser;
+				};
+
+				ser0_a: max9295_a@42 {
+					compatible = "maxim,max9295_0";
+					reg = <0x42>;
+					maxim,gmsl-dser-device = <&dser0>;
+				};
+
+				ser0_b: max9295_b@60 {
+					compatible = "maxim,max9295_0";
+					reg = <0x60>;
+					maxim,gmsl-dser-device = <&dser0>;
+				};
+
+				d4m0_depth: d4m0_depth@0a {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1a>;
+					reg = <0x0a>;
+					compatible = "intel,d4xx_0";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Depth";
+					maxim,gmsl-ser-device = <&ser0_a>;
+					maxim,gmsl-dser-device = <&dser0>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m0_out: endpoint {
+								port-index = <4>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in0>;
+							};
+						};
+					};
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_e";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "1";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "a";
+						csi-mode = "1x4";
+						st-vc = <0>;
+						vc-id = <0>;
+						num-lanes = <2>;
+					};
+				};
+
+				d4m0_ir: d4m0_ir@0c {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1a>;
+					reg = <0x0c>;
+					compatible = "intel,d4xx_0";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Y8";
+					maxim,gmsl-ser-device = <&ser0_a>;
+					maxim,gmsl-dser-device = <&dser0>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m1_out: endpoint {
+								port-index = <4>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in1>;
+							};
+						};
+					};
+					/* mode0: Y8, mode1: depth D16 */
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_e";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "0";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "a";
+						csi-mode = "1x4";
+						st-vc = <0>;
+						vc-id = <1>;
+						num-lanes = <2>;
+					};
+				};
+
+				d4m1_depth: d4m1_depth@2a {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1b>;
+					reg = <0x2a>;
+					compatible = "intel,d4xx_1";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Depth";
+					maxim,gmsl-ser-device = <&ser0_b>;
+					maxim,gmsl-dser-device = <&dser0>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m2_out: endpoint {
+								port-index = <4>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in2>;
+							};
+						};
+					};
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_e";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "1";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "b";
+						csi-mode = "1x4";
+						st-vc = <2>;
+						vc-id = <2>;
+						num-lanes = <2>;
+					};
+				};
+
+				d4m1_ir: d4m1_ir@2c {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1b>;
+					reg = <0x2c>;
+					compatible = "intel,d4xx_1";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Y8";
+					maxim,gmsl-ser-device = <&ser0_b>;
+					maxim,gmsl-dser-device = <&dser0>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m3_out: endpoint {
+								port-index = <4>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in3>;
+							};
+						};
+					};
+					/* mode0: Y8, mode1: depth D16 */
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_e";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "0";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "b";
+						csi-mode = "1x4";
+						st-vc = <2>;
+						vc-id = <3>;
+						num-lanes = <2>;
+					};
+				};
+			};
+
+			i2c@1 {
+				reg = <0x1>;
+				#address-cells = <0x1>;
+				#size-cells = <0x0>;
+				i2c-mux,deselect-on-exit;
+				
+				dser1: max9296@48 {
+					status = "ok";
+					reg = <0x48>;
+					compatible = "maxim,max9296";
+					csi-mode = "2x4";
+					max-src = <2>;
+					reset-gpios = <&tegra_main_gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+				};
+
+				ser1_prim: max9295_prim@40 {
+					status = "ok";
+					reg = <0x40>;
+					compatible = "maxim,max9295_1";
+					is-prim-ser;
+				};
+
+				ser1_a: max9295_a@42 {
+					compatible = "maxim,max9295_1";
+					reg = <0x42>;
+					maxim,gmsl-dser-device = <&dser1>;
+				};
+
+				ser1_b: max9295_b@60 {
+					compatible = "maxim,max9295_1";
+					reg = <0x60>;
+					maxim,gmsl-dser-device = <&dser1>;
+				};
+
+				d4m2_depth: d4m2_depth@0a {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1c>;
+					reg = <0x0a>;
+					compatible = "intel,d4xx_2";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Depth";
+					maxim,gmsl-ser-device = <&ser1_a>;
+					maxim,gmsl-dser-device = <&dser1>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							d4m4_out: endpoint {
+								port-index = <2>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in4>;
+							};
+						};
+					};
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_c";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "1";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "a";
+						csi-mode = "1x4";
+						st-vc = <0>;
+						vc-id = <0>;
+						num-lanes = <2>;
+					};
+				};
+
+				d4m2_ir: d4m2_ir@0c {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1c>;
+					reg = <0x0c>;
+					compatible = "intel,d4xx_2";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Y8";
+					maxim,gmsl-ser-device = <&ser1_a>;
+					maxim,gmsl-dser-device = <&dser1>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m5_out: endpoint {
+								port-index = <2>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in5>;
+							};
+						};
+					};
+					/* mode0: Y8, mode1: depth D16 */
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_c";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "0";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "a";
+						csi-mode = "1x4";
+						st-vc = <0>;
+						vc-id = <1>;
+						num-lanes = <2>;
+					};
+				};
+
+				d4m3_depth: d4m3_depth@2a {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1d>;
+					reg = <0x2a>;
+					compatible = "intel,d4xx_3";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Depth";
+					maxim,gmsl-ser-device = <&ser1_b>;
+					maxim,gmsl-dser-device = <&dser1>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m6_out: endpoint {
+								port-index = <2>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in6>;
+							};
+						};
+					};
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_c";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "1";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "b";
+						csi-mode = "1x4";
+						st-vc = <2>;
+						vc-id = <2>;
+						num-lanes = <2>;
+					};
+				};
+
+				d4m3_ir: d4m3_ir@2c {
+					status = "ok";
+					def-addr = <0x10>;
+					def-d4m-addr = <0x1d>;
+					reg = <0x2c>;
+					compatible = "intel,d4xx_3";
+					vcc-supply = <&p3737_vdd_1v8_sys>;
+					cam-type = "Y8";
+					maxim,gmsl-ser-device = <&ser1_b>;
+					maxim,gmsl-dser-device = <&dser1>;
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							d4m7_out: endpoint {
+								port-index = <2>;
+								bus-width = <2>;
+								remote-endpoint = <&csi_in7>;
+							};
+						};
+					};
+					/* mode0: Y8, mode1: depth D16 */
+					mode0 {
+						pixel_t = "grey_y16";
+						num_lanes = "2";
+						csi_pixel_bit_depth = "16";
+						active_w = "1280";
+						active_h = "720";
+						tegra_sinterface = "serial_c";
+						mclk_khz = "24000";
+						pix_clk_hz = "74250000";
+						line_length = "1280"; /* 2200 */
+						embedded_metadata_height = "0";
+					};
+					gmsl-link {
+						src-csi-port = "b";
+						dst-csi-port = "a";
+						serdes-csi-link = "b";
+						csi-mode = "1x4";
+						st-vc = <2>;
+						vc-id = <3>;
+						num-lanes = <2>;
+					};
+				};
+			};
+
+			i2c@2 {
+				reg = <2>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				i2c-mux,deselect-on-exit;
+				
+				serdes@48 {
+					compatible = "nvidia,serdes";
+					reg = <0x48>;
+					pwdn-gpios = <&tegra_main_gpio CAM2_PWDN GPIO_ACTIVE_HIGH>;
+					channel = <0>;
+				};
+
+				fzcam_a@2a {
+					compatible = "nvidia,fzcam";
+					reg = <0x2a>;
+
+					devnode = "video0";
+					sensor_model ="fzcam";
+
+					clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
+							<&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+					clock-names = "extperiph1", "pllp_grtba";
+					mclk = "extperiph1";
+					channel = <0>;
+					
+					mode0 {
+						mclk_khz = "37125";
+						num_lanes = "4";
+						tegra_sinterface = "serial_a";
+						vc_id = "0";
+						
+						discontinuous_clk = "no";
+						dpcm_enable = "false";
+						cil_settletime = "0";
+						
+						csi_pixel_bit_depth = "16";
+						mode_type = "yuv";
+						pixel_phase = "uyvy";
+
+						active_w = "1920";
+						active_h = "1536";
+						readout_orientation = "0";
+						line_length = "2200";
+						inherent_gain = "1";
+						
+						pix_clk_hz = "74250000";
+						serdes_pix_clk_hz = "375000000";
+
+						gain_factor = "10";
+						min_gain_val = "1"; /* 0dB */
+						max_gain_val = "480"; /* 48dB */
+						step_gain_val = "3"; /* 0.3 */
+						default_gain = "1";
+						framerate_factor = "1000000";
+						min_framerate = "30000000"; /* 1.5 */
+						max_framerate = "30000000"; /* 30 */
+						step_framerate = "1";
+						default_framerate= "30000000";
+
+						exposure_factor = "1000000";
+						min_exp_time = "30"; /* us */
+						max_exp_time = "660000"; /* us */
+						step_exp_time = "1";
+						default_exp_time = "33334";/* us */
+						embedded_metadata_height = "0";
+					};
+
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							fzcam_fzcam_out0: endpoint {
+								vc-id = <0>;
+								port-index = <0>;
+								bus-width = <4>;
+								remote-endpoint = <&fzcam_csi_in0>;
+								};
+							};
+						};
+				};
+
+				fzcam_b@2b {
+					compatible = "nvidia,fzcam";
+					reg = <0x2b>;
+					
+					devnode = "video1";
+					sensor_model ="fzcam";
+
+					/* Define any required hw resources needed by driver */
+					/* ie. clocks, io pins, power sources */
+					clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
+							<&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+					clock-names = "extperiph1", "pllp_grtba";
+					mclk = "extperiph1";
+					channel = <0>;
+
+					mode0 {
+						mclk_khz = "37125";
+						num_lanes = "4";
+						tegra_sinterface = "serial_a";
+						vc_id = "1";
+						
+						discontinuous_clk = "no";
+						dpcm_enable = "false";
+						cil_settletime = "0";
+						
+						csi_pixel_bit_depth = "16";
+						mode_type = "yuv";
+						pixel_phase = "uyvy";
+
+						active_w = "1920";
+						active_h = "1536";
+						readout_orientation = "0";
+						line_length = "2200";
+						inherent_gain = "1";
+						
+						pix_clk_hz = "74250000";
+						serdes_pix_clk_hz = "375000000";
+
+						gain_factor = "10";
+						min_gain_val = "1"; /* 0dB */
+						max_gain_val = "480"; /* 48dB */
+						step_gain_val = "3"; /* 0.3 */
+						default_gain = "1";
+						framerate_factor = "1000000";
+						min_framerate = "30000000"; /* 1.5 */
+						max_framerate = "30000000"; /* 30 */
+						step_framerate = "1";
+						default_framerate= "30000000";
+						exposure_factor = "1000000";
+						min_exp_time = "30"; /* us */
+						max_exp_time = "660000"; /* us */
+						step_exp_time = "1";
+						default_exp_time = "33334";/* us */
+						embedded_metadata_height = "0";
+					};
+
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							fzcam_fzcam_out1: endpoint {
+								vc-id = <1>;
+								port-index = <0>;
+								bus-width = <4>;
+								remote-endpoint = <&fzcam_csi_in1>;
+							};
+						};
+					};
+				};
+			};
+		
+			i2c@3 { //MAX96712
+				reg = <3>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				i2c-mux,deselect-on-exit;
+				
+				serdes@29 {
+					compatible = "nvidia,serdesa";
+					reg = <0x29>;
+					pwdn-gpios = <&tegra_main_gpio CAM3_PWDN GPIO_ACTIVE_HIGH>;
+					channel = <1>;
+				};
+				fzcam_a@2a {
+					compatible = "nvidia,fzcama";
+					reg = <0x2a>;
+
+					devnode = "video2";
+					sensor_model ="fzcama";
+
+					/* Define any required hw resources needed by driver */
+					/* ie. clocks, io pins, power sources */
+					clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
+							<&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+					clock-names = "extperiph1", "pllp_grtba";
+					mclk = "extperiph1";
+					channel = <1>;
+
+					mode0 {
+						mclk_khz = "37125";
+						num_lanes = "4";
+						tegra_sinterface = "serial_g";
+						vc_id = "0";
+						
+						discontinuous_clk = "no";
+						dpcm_enable = "false";
+						cil_settletime = "0";
+						
+						csi_pixel_bit_depth = "16";
+						mode_type = "yuv";
+						pixel_phase = "uyvy";
+
+						active_w = "1920";
+						active_h = "1536";
+						readout_orientation = "0";
+						line_length = "2200";
+						inherent_gain = "1";
+						
+						pix_clk_hz = "74250000";
+						serdes_pix_clk_hz = "375000000";
+
+						gain_factor = "10";
+						min_gain_val = "1"; /* 0dB */
+						max_gain_val = "480"; /* 48dB */
+						step_gain_val = "3"; /* 0.3 */
+						default_gain = "1";
+						framerate_factor = "1000000";
+						min_framerate = "30000000"; /* 1.5 */
+						max_framerate = "30000000"; /* 30 */
+						step_framerate = "1";
+						default_framerate= "30000000";
+
+						exposure_factor = "1000000";
+						min_exp_time = "30"; /* us */
+						max_exp_time = "660000"; /* us */
+						step_exp_time = "1";
+						default_exp_time = "33334";/* us */
+
+						embedded_metadata_height = "0";
+					};
+
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							fzcam_fzcam_out2: endpoint {
+								vc-id = <0>;
+								port-index = <5>;
+								bus-width = <4>;
+								remote-endpoint = <&fzcam_csi_in2>;
+							};
+						};
+					};
+				};	
+				fzcam_b@2b {
+					compatible = "nvidia,fzcama";
+					reg = <0x2b>;
+
+					devnode = "video3";
+					sensor_model ="fzcama";
+
+					/* Define any required hw resources needed by driver */
+					/* ie. clocks, io pins, power sources */
+					clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
+							<&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+					clock-names = "extperiph1", "pllp_grtba";
+					mclk = "extperiph1";
+					channel = <1>;
+
+					mode0 {
+						mclk_khz = "37125";
+						num_lanes = "4";
+						tegra_sinterface = "serial_g";
+						vc_id = "1";
+						
+						discontinuous_clk = "no";
+						dpcm_enable = "false";
+						cil_settletime = "0";
+						
+						csi_pixel_bit_depth = "16";
+						mode_type = "yuv";
+						pixel_phase = "uyvy";
+
+						active_w = "1920";
+						active_h = "1536";
+						readout_orientation = "0";
+						line_length = "2200";
+						inherent_gain = "1";
+						
+						pix_clk_hz = "74250000";
+						serdes_pix_clk_hz = "375000000";
+
+						gain_factor = "10";
+						min_gain_val = "1"; /* 0dB */
+						max_gain_val = "480"; /* 48dB */
+						step_gain_val = "3"; /* 0.3 */
+						default_gain = "1";
+						framerate_factor = "1000000";
+						min_framerate = "30000000"; /* 1.5 */
+						max_framerate = "30000000"; /* 30 */
+						step_framerate = "1";
+						default_framerate= "30000000";
+
+						exposure_factor = "1000000";
+						min_exp_time = "30"; /* us */
+						max_exp_time = "660000"; /* us */
+						step_exp_time = "1";
+						default_exp_time = "33334";/* us */
+						embedded_metadata_height = "0";
+					};
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							fzcam_fzcam_out3: endpoint {
+								vc-id = <1>;
+								port-index = <5>;
+								bus-width = <4>;
+								remote-endpoint = <&fzcam_csi_in3>;
+							};
+						};
+					};
+				};	
+				fzcam_c@2c {
+					compatible = "nvidia,fzcama";
+					reg = <0x2c>;
+
+					devnode = "video4";
+					sensor_model ="fzcama";
+
+					/* Define any required hw resources needed by driver */
+					/* ie. clocks, io pins, power sources */
+					clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
+							<&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+					clock-names = "extperiph1", "pllp_grtba";
+					mclk = "extperiph1";
+					channel = <1>;
+					
+					mode0 {
+						mclk_khz = "37125";
+						num_lanes = "4";
+						tegra_sinterface = "serial_g";
+						vc_id = "2";
+						
+						discontinuous_clk = "no";
+						dpcm_enable = "false";
+						cil_settletime = "0";
+						
+						csi_pixel_bit_depth = "16";
+						mode_type = "yuv";
+						pixel_phase = "uyvy";
+
+						active_w = "1920";
+						active_h = "1536";
+						readout_orientation = "0";
+						line_length = "2200";
+						inherent_gain = "1";
+						
+						pix_clk_hz = "74250000";
+						serdes_pix_clk_hz = "375000000";
+
+						gain_factor = "10";
+						min_gain_val = "1"; /* 0dB */
+						max_gain_val = "480"; /* 48dB */
+						step_gain_val = "3"; /* 0.3 */
+						default_gain = "1";
+						framerate_factor = "1000000";
+						min_framerate = "30000000"; /* 1.5 */
+						max_framerate = "30000000"; /* 30 */
+						step_framerate = "1";
+						default_framerate= "30000000";
+
+						exposure_factor = "1000000";
+						min_exp_time = "30"; /* us */
+						max_exp_time = "660000"; /* us */
+						step_exp_time = "1";
+						default_exp_time = "33334";/* us */
+						embedded_metadata_height = "0";
+					};
+
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							fzcam_fzcam_out4: endpoint {
+								vc-id = <2>;
+								port-index = <5>;
+								bus-width = <4>;
+								remote-endpoint = <&fzcam_csi_in4>;
+								};
+							};
+						};
+				};	
+				fzcam_d@2d {
+					compatible = "nvidia,fzcama";
+					reg = <0x2d>;
+
+					devnode = "video5";	
+					sensor_model ="fzcama";
+
+					/* Define any required hw resources needed by driver */
+					/* ie. clocks, io pins, power sources */
+					clocks = <&bpmp_clks TEGRA234_CLK_EXTPERIPH1>,
+							<&bpmp_clks TEGRA234_CLK_EXTPERIPH1>;
+					clock-names = "extperiph1", "pllp_grtba";
+					mclk = "extperiph1";
+					channel = <1>;			
+
+					mode0 {
+						mclk_khz = "37125";
+						num_lanes = "4";
+						tegra_sinterface = "serial_g";
+						vc_id = "3";
+						
+						discontinuous_clk = "no";
+						dpcm_enable = "false";
+						cil_settletime = "0";
+						
+						csi_pixel_bit_depth = "16";
+						mode_type = "yuv";
+						pixel_phase = "uyvy";
+
+						active_w = "1920";
+						active_h = "1536";
+						readout_orientation = "0";
+						line_length = "2200";
+						inherent_gain = "1";
+						
+						pix_clk_hz = "74250000";
+						serdes_pix_clk_hz = "375000000";
+
+						gain_factor = "10";
+						min_gain_val = "1"; /* 0dB */
+						max_gain_val = "480"; /* 48dB */
+						step_gain_val = "3"; /* 0.3 */
+						default_gain = "1";
+						framerate_factor = "1000000";
+						min_framerate = "30000000"; /* 1.5 */
+						max_framerate = "30000000"; /* 30 */
+						step_framerate = "1";
+						default_framerate= "30000000";
+
+						exposure_factor = "1000000";
+						min_exp_time = "30"; /* us */
+						max_exp_time = "660000"; /* us */
+						step_exp_time = "1";
+						default_exp_time = "33334";/* us */
+
+						embedded_metadata_height = "0";
+					};
+
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						port@0 {
+							reg = <0>;
+							fzcam_fzcam_out5: endpoint {
+								vc-id = <3>;
+								port-index = <5>;
+								bus-width = <4>;
+								remote-endpoint = <&fzcam_csi_in5>;
+							};
+						};
+					};
+				};				
+			};
+		};
+	};
+
+	host1x@13e00000 {
+		nvcsi@15a00000 {
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+
+			num-channels = <14>;
+			//intel d4xx
+			channel@0 {
+				reg = <0x0>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in0: endpoint@0 {
+							status = "ok";
+							port-index = <4>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m0_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out0: endpoint@1 {
+							status = "ok";
+							remote-endpoint = <&vi_in0>;
+						};
+					};
+				};
+			};
+			channel@1 {
+				reg = <0x1>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in1: endpoint@2 {
+							status = "ok";
+							port-index = <4>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m1_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out1: endpoint@3 {
+							status = "ok";
+							remote-endpoint = <&vi_in1>;
+						};
+					};
+
+				};
+			};
+			channel@2 {
+				reg = <0x2>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in2: endpoint@4 {
+							status = "ok";
+							port-index = <4>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m2_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out2: endpoint@5 {
+							status = "ok";
+							remote-endpoint = <&vi_in2>;
+						};
+					};
+				};
+			};
+			channel@3 {
+				reg = <0x3>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in3: endpoint@6 {
+							status = "ok";
+							port-index = <4>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m3_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out3: endpoint@7 {
+							status = "ok";
+							remote-endpoint = <&vi_in3>;
+						};
+					};
+				};
+			};
+			channel@4 {
+				reg = <0x4>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in4: endpoint@8 {
+							status = "ok";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m4_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out4: endpoint@9 {
+							status = "ok";
+							remote-endpoint = <&vi_in4>;
+						};
+					};
+				};
+			};
+			channel@5 {
+				reg = <0x5>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in5: endpoint@10 {
+							status = "ok";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m5_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out5: endpoint@11 {
+							status = "ok";
+							remote-endpoint = <&vi_in5>;
+						};
+					};
+				};
+			};
+			channel@6 {
+				reg = <0x6>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in6: endpoint@12 {
+							status = "ok";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m6_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out6: endpoint@13 {
+							status = "ok";
+							remote-endpoint = <&vi_in6>;
+						};
+					};
+				};
+			};
+			channel@7 {
+				reg = <0x7>;
+				status = "ok";
+
+				ports {
+					#address-cells = <0x1>;
+					#size-cells = <0x0>;
+
+					port@0 {
+						reg = <0>;
+						status = "ok";
+
+						csi_in7: endpoint@14 {
+							status = "ok";
+							port-index = <2>;
+							bus-width = <2>;
+							remote-endpoint = <&d4m7_out>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						status = "ok";
+						csi_out7: endpoint@15 {
+							status = "ok";
+							remote-endpoint = <&vi_in7>;
+						};
+					};
+				};
+			};
+
+			//FZCAM
+			channel@8 {
+				reg = <8>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						fzcam_csi_in0: endpoint@16 {
+							port-index = <0>;
+							bus-width = <4>;
+							remote-endpoint = <&fzcam_fzcam_out0>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						fzcam_csi_out0: endpoint@17 {
+							remote-endpoint = <&fzcam_vi_in0>;
+						};
+					};
+				};
+			};
+			channel@9 {
+				reg = <9>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						fzcam_csi_in1: endpoint@18 {
+							port-index = <0>;
+							bus-width = <4>;
+							remote-endpoint = <&fzcam_fzcam_out1>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						fzcam_csi_out1: endpoint@19 {
+							remote-endpoint = <&fzcam_vi_in1>;
+						};
+					};
+				};
+			};
+			channel@10 {
+				reg = <10>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						fzcam_csi_in2: endpoint@20 {
+							port-index = <6>;
+							bus-width = <4>;
+							remote-endpoint = <&fzcam_fzcam_out2>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						fzcam_csi_out2: endpoint@21 {
+							remote-endpoint = <&fzcam_vi_in2>;
+						};
+					};
+				};
+			};
+			channel@11 {
+				reg = <11>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						fzcam_csi_in3: endpoint@22 {
+							port-index = <6>;
+							bus-width = <4>;
+							remote-endpoint = <&fzcam_fzcam_out3>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						fzcam_csi_out3: endpoint@23 {
+							remote-endpoint = <&fzcam_vi_in3>;
+						};
+					};
+				};
+			};			
+			channel@12 {
+				reg = <12>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						fzcam_csi_in4: endpoint@24 {
+							port-index = <6>;
+							bus-width = <4>;
+							remote-endpoint = <&fzcam_fzcam_out4>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						fzcam_csi_out4: endpoint@25{
+							remote-endpoint = <&fzcam_vi_in4>;
+						};
+					};
+				};
+			};
+			channel@13 {
+				reg = <13>;
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					port@0 {
+						reg = <0>;
+						fzcam_csi_in5: endpoint@26 {
+							port-index = <6>;
+							bus-width = <4>;
+							remote-endpoint = <&fzcam_fzcam_out5>;
+						};
+					};
+					port@1 {
+						reg = <1>;
+						fzcam_csi_out5: endpoint@27 {
+							remote-endpoint = <&fzcam_vi_in5>;
+						};
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-fixed-regulator.dtsi b/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-fixed-regulator.dtsi
index 6b79962..9b17457 100644
--- a/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-fixed-regulator.dtsi
+++ b/hardware/nvidia/platform/t23x/concord/kernel-dts/cvb/tegra234-p3737-fixed-regulator.dtsi
@@ -161,7 +161,7 @@
 			regulator-name = "vdd_sys_en";
 			regulator-min-microvolt = <1200000>;
 			regulator-max-microvolt = <1200000>;
-			gpio = <&tegra_main_gpio TEGRA234_MAIN_GPIO(AC, 7) 0>;
+			// gpio = <&tegra_main_gpio TEGRA234_MAIN_GPIO(AC, 7) 0>;
 			regulator-always-on;
 			enable-active-high;
 		};
@@ -172,7 +172,7 @@
 			regulator-min-microvolt = <1800000>;
 			regulator-max-microvolt = <1800000>;
 			vin-supply = <&p3737_vdd_1v8_sys>;
-			gpio = <&tegra_aon_gpio TEGRA234_AON_GPIO(CC, 2) 0>; //CAM_INT3, GPIO_ACTIVE_HIGH == 0
+			// gpio = <&tegra_aon_gpio TEGRA234_AON_GPIO(CC, 2) 0>; //CAM_INT3, GPIO_ACTIVE_HIGH == 0
 			enable-active-high;
 		};
 	};
diff --git a/hardware/nvidia/platform/t23x/concord/kernel-dts/tegra234-p3701-0000-p3737-0000.dts b/hardware/nvidia/platform/t23x/concord/kernel-dts/tegra234-p3701-0000-p3737-0000.dts
index 4059d66..7ebad11 100644
--- a/hardware/nvidia/platform/t23x/concord/kernel-dts/tegra234-p3701-0000-p3737-0000.dts
+++ b/hardware/nvidia/platform/t23x/concord/kernel-dts/tegra234-p3701-0000-p3737-0000.dts
@@ -20,7 +20,8 @@
 #include "tegra234-power-tree-p3701-0000-p3737-0000.dtsi"
 #include "tegra234-dcb-p3701-0000-a02-p3737-0000-a01.dtsi"
 #include <tegra234-soc/mods-simple-bus.dtsi>
-#include "cvb/tegra234-p3737-camera-modules.dtsi"
+//#include "cvb/tegra234-p3737-camera-modules.dtsi"
+#include "cvb/tegra234-p3737-0000-camera-d4xx-qual.dtsi"
 #include <t234-common-cvb/tegra234-pwm.dtsi>
 #include <t234-common-cvm/tegra234-cpuidle.dtsi>
 #include <t234-common-cvm/tegra234-thermal.dtsi>
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 5ec3c68..7f288fa 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -210,6 +210,27 @@ config NV_VIRTUAL_I2C_MUX
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called virtual_i2c_mux.
+
+config VIDEO_D4XX
+	tristate "D4XX camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+		This is a Video4Linux2 sensor-level driver for the Intel
+		D4XX depth camera sensor
+
+		To compile this driver as a module, choose M here: the module
+		will be called d4xx.
+
+config VIDEO_D4XX_SERDES
+	bool "D4XX camera sensor setup with Maxim Serdes"
+	depends on VIDEO_D4XX
+        default y
+	help
+		This is a Video4Linux2 sensor-level driver for the Intel
+		D4XX depth camera sensor
+
+                This option is for setup with Maxim Serdes.
+
 endmenu
 
 endif
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index c4708d8..5e4c0bf 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -27,3 +27,7 @@ obj-$(CONFIG_NV_VIDEO_HAWK_OWL) += nv_hawk_owl.o
 obj-$(CONFIG_NV_DESER_MAX96712) += max96712.o
 obj-$(CONFIG_VIDEO_ECAM) += ar1335.o
 ar1335-objs :=  ar1335_common.o
+obj-$(CONFIG_VIDEO_D4XX) += d4xx.o
+
+
+obj-y += isx031/
diff --git a/kernel/nvidia/drivers/media/i2c/d4xx.c b/kernel/nvidia/drivers/media/i2c/d4xx.c
new file mode 100644
index 0000000..0dcce1e
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/d4xx.c
@@ -0,0 +1,5700 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ds5.c - Intel(R) RealSense(TM) D4XX camera driver
+ *
+ * Copyright (c) 2017-2023, INTEL CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+// #define DEBUG 1
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+#include <linux/version.h>
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+#include <linux/ipu-isys.h>
+#include <media/d4xx_pdata.h>
+#endif
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-mediabus.h>
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+#include <media/max9295.h>
+#include <media/max9296.h>
+#else
+#include <media/gmsl-link.h>
+#define GMSL_CSI_DT_YUV422_8 0x1E
+#define GMSL_CSI_DT_RGB_888 0x24
+#define GMSL_CSI_DT_RAW_8 0x2A
+#define GMSL_CSI_DT_EMBED 0x12
+#endif
+
+//#define DS5_DRIVER_NAME "DS5 RealSense camera driver"
+#define DS5_DRIVER_NAME "d4xx"
+#define DS5_DRIVER_NAME_AWG "d4xx-awg"
+#define DS5_DRIVER_NAME_ASR "d4xx-asr"
+#define DS5_DRIVER_NAME_CLASS "d4xx-class"
+#define DS5_DRIVER_NAME_DFU "d4xx-dfu"
+
+#define DS5_MIPI_SUPPORT_LINES		0x0300
+#define DS5_MIPI_SUPPORT_PHY		0x0304
+#define DS5_MIPI_DATARATE_MIN		0x0308
+#define DS5_MIPI_DATARATE_MAX		0x030A
+#define DS5_FW_VERSION			0x030C
+#define DS5_FW_BUILD			0x030E
+#define DS5_DEVICE_TYPE			0x0310
+#define DS5_DEVICE_TYPE_D45X		6
+#define DS5_DEVICE_TYPE_D43X		5
+#define DS5_DEVICE_TYPE_D46X		4
+
+#define DS5_MIPI_LANE_NUMS		0x0400
+#define DS5_MIPI_LANE_DATARATE		0x0402
+#define DS5_MIPI_CONF_STATUS		0x0500
+
+#define DS5_START_STOP_STREAM		0x1000
+#define DS5_DEPTH_STREAM_STATUS		0x1004
+#define DS5_RGB_STREAM_STATUS		0x1008
+#define DS5_IMU_STREAM_STATUS		0x100C
+#define DS5_IR_STREAM_STATUS		0x1014
+
+#define DS5_STREAM_DEPTH		0x0
+#define DS5_STREAM_RGB			0x1
+#define DS5_STREAM_IMU			0x2
+#define DS5_STREAM_IR			0x4
+#define DS5_STREAM_STOP			0x100
+#define DS5_STREAM_START		0x200
+#define DS5_STREAM_IDLE			0x1
+#define DS5_STREAM_STREAMING		0x2
+
+#define DS5_DEPTH_STREAM_DT		0x4000
+#define DS5_DEPTH_STREAM_MD		0x4002
+#define DS5_DEPTH_RES_WIDTH		0x4004
+#define DS5_DEPTH_RES_HEIGHT		0x4008
+#define DS5_DEPTH_FPS			0x400C
+#define DS5_DEPTH_OVERRIDE		0x401C
+
+#define DS5_RGB_STREAM_DT		0x4020
+#define DS5_RGB_STREAM_MD		0x4022
+#define DS5_RGB_RES_WIDTH		0x4024
+#define DS5_RGB_RES_HEIGHT		0x4028
+#define DS5_RGB_FPS			0x402C
+
+#define DS5_IMU_STREAM_DT		0x4040
+#define DS5_IMU_STREAM_MD		0x4042
+#define DS5_IMU_RES_WIDTH		0x4044
+#define DS5_IMU_RES_HEIGHT		0x4048
+#define DS5_IMU_FPS			0x404C
+
+#define DS5_IR_STREAM_DT		0x4080
+#define DS5_IR_STREAM_MD		0x4082
+#define DS5_IR_RES_WIDTH		0x4084
+#define DS5_IR_RES_HEIGHT		0x4088
+#define DS5_IR_FPS			0x408C
+#define DS5_IR_OVERRIDE			0x409C
+
+#define DS5_DEPTH_CONTROL_BASE		0x4100
+#define DS5_RGB_CONTROL_BASE		0x4200
+#define DS5_MANUAL_EXPOSURE_LSB		0x0000
+#define DS5_MANUAL_EXPOSURE_MSB		0x0002
+#define DS5_MANUAL_GAIN			0x0004
+#define DS5_LASER_POWER			0x0008
+#define DS5_AUTO_EXPOSURE_MODE		0x000C
+#define DS5_EXPOSURE_ROI_TOP		0x0010
+#define DS5_EXPOSURE_ROI_LEFT		0x0014
+#define DS5_EXPOSURE_ROI_BOTTOM		0x0018
+#define DS5_EXPOSURE_ROI_RIGHT		0x001C
+#define DS5_MANUAL_LASER_POWER		0x0024
+#define DS5_PWM_FREQUENCY		0x0028
+
+#define DS5_DEPTH_CONFIG_STATUS		0x4800
+#define DS5_RGB_CONFIG_STATUS		0x4802
+#define DS5_IMU_CONFIG_STATUS		0x4804
+#define DS5_IR_CONFIG_STATUS		0x4808
+
+#define DS5_STATUS_STREAMING		0x1
+#define DS5_STATUS_INVALID_DT		0x2
+#define DS5_STATUS_INVALID_RES		0x4
+#define DS5_STATUS_INVALID_FPS		0x8
+
+#define MIPI_LANE_RATE			1000
+
+#define MAX_DEPTH_EXP			200000
+#define MAX_RGB_EXP			10000
+#define DEF_DEPTH_EXP			33000
+#define DEF_RGB_EXP			1660
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+
+#define MAX9295_REG0	0x0000
+#define MAX9295_I2C_4	0x0044
+#define MAX9295_I2C_5	0x0045
+
+#define MAX9296_CTRL0	0x0010
+#define RESET_LINK	(0x1 << 6)
+#define RESET_ONESHOT	(0x1 << 5)
+#define AUTO_LINK	(0x1 << 4)
+#define DUAL_LINK	(0x0)
+#define LINK_A		(0x1)
+#define LINK_B		(0x2)
+#define SPLITTER	(0x3)
+#define MAX9296_NUM	(4)
+
+#define MAX9295_I2C_ADDR_DEF	0x40
+#define D457_I2C_ADDR	0x10
+#endif
+enum ds5_mux_pad {
+	DS5_MUX_PAD_EXTERNAL,
+	DS5_MUX_PAD_DEPTH,
+	DS5_MUX_PAD_RGB,
+	DS5_MUX_PAD_IR,
+	DS5_MUX_PAD_IMU,
+	DS5_MUX_PAD_COUNT,
+};
+
+#define DS5_N_CONTROLS			8
+
+#define CSI2_MAX_VIRTUAL_CHANNELS	16
+
+#define DFU_WAIT_RET_LEN 6
+
+#define DS5_START_POLL_TIME	10
+#define DS5_START_MAX_TIME	1000
+#define DS5_START_MAX_COUNT	(DS5_START_MAX_TIME / DS5_START_POLL_TIME)
+
+/* DFU definition section */
+#define DFU_MAGIC_NUMBER "/0x01/0x02/0x03/0x04"
+#define DFU_BLOCK_SIZE 1024
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#define DFU_I2C_STANDARD_MODE		100000
+#define DFU_I2C_FAST_MODE			400000
+#define DFU_I2C_BUS_CLK_RATE		DFU_I2C_FAST_MODE
+#endif
+#define ds5_read_with_check(state, addr, val) {\
+	if (ds5_read(state, addr, val))	\
+		return -EINVAL; }
+#define ds5_raw_read_with_check(state, addr, buf, size)	{\
+	if (ds5_raw_read(state, addr, buf, size))	\
+		return -EINVAL; }
+#define ds5_write_with_check(state, addr, val) {\
+	if (ds5_write(state, addr, val))	\
+		return -EINVAL; }
+#define ds5_raw_write_with_check(state, addr, buf, size) {\
+	if (ds5_raw_write(state, addr, buf, size)) \
+		return -EINVAL; }
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+#define max9296_write_8_with_check(state, addr, buf) {\
+	if (max9296_write_8(state, addr, buf)) \
+		return -EINVAL; \
+	}
+#define max9295_write_8_with_check(state, addr, buf) {\
+	if (max9295_write_8(state, addr, buf)) \
+		return -EINVAL; \
+	}
+#define D4XX_LINK_FREQ_360MHZ		360000000ULL
+#define D4XX_LINK_FREQ_300MHZ		300000000ULL
+#define D4XX_LINK_FREQ_288MHZ		288000000ULL
+#define D4XX_LINK_FREQ_240MHZ		240000000ULL
+#define D4XX_LINK_FREQ_225MHZ		22500000ULL
+#endif
+enum dfu_fw_state {
+	appIDLE                = 0x0000,
+	appDETACH              = 0x0001,
+	dfuIDLE                = 0x0002,
+	dfuDNLOAD_SYNC         = 0x0003,
+	dfuDNBUSY              = 0x0004,
+	dfuDNLOAD_IDLE         = 0x0005,
+	dfuMANIFEST_SYNC       = 0x0006,
+	dfuMANIFEST            = 0x0007,
+	dfuMANIFEST_WAIT_RESET = 0x0008,
+	dfuUPLOAD_IDLE         = 0x0009,
+	dfuERROR               = 0x000a
+};
+
+enum dfu_state {
+	DS5_DFU_IDLE = 0,
+	DS5_DFU_RECOVERY,
+	DS5_DFU_OPEN,
+	DS5_DFU_IN_PROGRESS,
+	DS5_DFU_DONE,
+	DS5_DFU_ERROR
+} dfu_state_t;
+
+struct hwm_cmd {
+	u16 header;
+	u16 magic_word;
+	u32 opcode;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+	unsigned char Data[0];
+};
+
+static const struct hwm_cmd cmd_switch_to_dfu = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x1e,
+	.param1 = 0x01,
+};
+
+enum table_id {
+	COEF_CALIBRATION_ID = 0x19,
+	DEPTH_CALIBRATION_ID = 0x1f,
+	RGB_CALIBRATION_ID = 0x20,
+	IMU_CALIBRATION_ID = 0x22
+} table_id_t;
+
+static const struct hwm_cmd get_calib_data = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x15,
+	.param1 = 0x00,	//table_id
+};
+
+static const struct hwm_cmd set_calib_data = {
+	.header = 0x0114,
+	.magic_word = 0xCDAB,
+	.opcode = 0x62,
+	.param1 = 0x00,	//table_id
+	.param2 = 0x02,	//region
+};
+
+static const struct hwm_cmd gvd = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x10,
+};
+
+static const struct hwm_cmd set_ae_roi = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x44,
+};
+
+static const struct hwm_cmd get_ae_roi = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x45,
+};
+
+static const struct hwm_cmd set_ae_setpoint = {
+	.header = 0x18,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2B,
+	.param1 = 0xa, // AE control
+};
+
+static const struct hwm_cmd get_ae_setpoint = {
+	.header = 0x014,
+	.magic_word = 0xCDAB,
+	.opcode = 0x2C,
+	.param1 = 0xa, // AE control
+	.param2 = 0, // get current
+};
+
+static const struct hwm_cmd erb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x17,
+};
+
+static const struct hwm_cmd ewb = {
+	.header = 0x14,
+	.magic_word = 0xCDAB,
+	.opcode = 0x18,
+};
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static const s64 link_freq_menu_items[] = {
+	D4XX_LINK_FREQ_360MHZ,
+	D4XX_LINK_FREQ_300MHZ,
+	D4XX_LINK_FREQ_288MHZ,
+	D4XX_LINK_FREQ_240MHZ,
+	D4XX_LINK_FREQ_225MHZ,
+};
+#endif
+struct __fw_status {
+	uint32_t	spare1;
+	uint32_t	FW_lastVersion;
+	uint32_t	FW_highestVersion;
+	uint16_t	FW_DownloadStatus;
+	uint16_t	DFU_isLocked;
+	uint16_t	DFU_version;
+	uint8_t		ivcamSerialNum[8];
+	uint8_t		spare2[42];
+};
+
+/*************************/
+
+struct ds5_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl_handler handler_depth;
+	struct v4l2_ctrl_handler handler_rgb;
+	struct v4l2_ctrl_handler handler_y8;
+	struct v4l2_ctrl_handler handler_imu;
+	struct {
+		struct v4l2_ctrl *log;
+		struct v4l2_ctrl *fw_version;
+		struct v4l2_ctrl *gvd;
+		struct v4l2_ctrl *get_depth_calib;
+		struct v4l2_ctrl *set_depth_calib;
+		struct v4l2_ctrl *get_coeff_calib;
+		struct v4l2_ctrl *set_coeff_calib;
+		struct v4l2_ctrl *ae_roi_get;
+		struct v4l2_ctrl *ae_roi_set;
+		struct v4l2_ctrl *ae_setpoint_get;
+		struct v4l2_ctrl *ae_setpoint_set;
+		struct v4l2_ctrl *erb;
+		struct v4l2_ctrl *ewb;
+		struct v4l2_ctrl *hwmc;
+		struct v4l2_ctrl *laser_power;
+		struct v4l2_ctrl *manual_laser_power;
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+		/* in DS5 manual gain only works with manual exposure */
+		struct v4l2_ctrl *gain;
+		struct v4l2_ctrl *link_freq;
+		struct v4l2_ctrl *query_sub_stream;
+		struct v4l2_ctrl *set_sub_stream;
+	};
+};
+
+struct ds5_resolution {
+	u16 width;
+	u16 height;
+	u8 n_framerates;
+	const u16 *framerates;
+};
+
+struct ds5_format {
+	unsigned int n_resolutions;
+	const struct ds5_resolution *resolutions;
+	u32 mbus_code;
+	u8 data_type;
+};
+
+struct ds5_sensor {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	u16 mux_pad;
+	struct {
+		const struct ds5_format *format;
+		const struct ds5_resolution *resolution;
+		u16 framerate;
+	} config;
+	bool streaming;
+	/*struct ds5_vchan *vchan;*/
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+	int pipe_id;
+};
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define ds5_mux_subdev camera_common_data
+#else
+struct ds5_mux_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct ds5_variant {
+	const struct ds5_format *formats;
+	unsigned int n_formats;
+};
+
+struct ds5_dfu_dev {
+	struct cdev ds5_cdev;
+	struct class *ds5_class;
+	int device_open_count;
+	enum dfu_state dfu_state_flag;
+	unsigned char *dfu_msg;
+	u16 msg_write_once;
+	unsigned char init_v4l_f;
+	u32 bus_clk_rate;
+};
+
+enum {
+	DS5_DS5U,
+	DS5_ASR,
+	DS5_AWG,
+};
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+#define NR_OF_DS5_PADS 7
+#define NR_OF_DS5_STREAMS 4
+struct v4l2_mbus_framefmt ds5_ffmts[NR_OF_DS5_PADS];
+#endif
+
+struct ds5 {
+	struct { struct ds5_sensor sensor; } depth;
+	struct { struct ds5_sensor sensor; } ir;
+	struct { struct ds5_sensor sensor; } rgb;
+	struct { struct ds5_sensor sensor; } imu;
+	struct {
+		struct ds5_mux_subdev sd;
+		struct media_pad pads[DS5_MUX_PAD_COUNT];
+		struct ds5_sensor *last_set;
+	} mux;
+	struct ds5_ctrls ctrls;
+	struct ds5_dfu_dev dfu_dev;
+	bool power;
+	struct i2c_client *client;
+	/*struct ds5_vchan virtual_channels[CSI2_MAX_VIRTUAL_CHANNELS];*/
+	/* All below pointers are used for writing, cannot be const */
+	struct mutex lock;
+	struct regmap *regmap;
+	struct regulator *vcc;
+	const struct ds5_variant *variant;
+	int is_depth, is_y8, is_rgb, is_imu;
+	int aggregated;
+	int device_id;
+	u16 fw_version;
+	u16 fw_build;
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	struct gmsl_link_ctx g_ctx;
+	struct device *ser_dev;
+	struct device *dser_dev;
+	struct i2c_client *ser_i2c;
+	struct i2c_client *dser_i2c;
+#endif
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+#define NR_OF_CSI2_BE_SOC_STREAMS	16
+#define NR_OF_DS5_SUB_STREAMS	6 /*d+d.md,c+c.md,ir,imu*/
+	int pad_to_vc[DS5_MUX_PAD_COUNT];
+	int pad_to_substream[NR_OF_CSI2_BE_SOC_STREAMS];
+#endif
+};
+
+struct ds5_counters {
+	unsigned int n_res;
+	unsigned int n_fmt;
+	unsigned int n_ctrl;
+};
+
+#define ds5_from_depth_sd(sd) container_of(sd, struct ds5, depth.sd)
+#define ds5_from_ir_sd(sd) container_of(sd, struct ds5, ir.sd)
+#define ds5_from_rgb_sd(sd) container_of(sd, struct ds5, rgb.sd)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(5, 15, 122)
+static inline void msleep_range(unsigned int delay_base)
+{
+	usleep_range(delay_base * 1000, delay_base * 1000 + 500);
+}
+#endif
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static int ds5_write_8(struct ds5 *state, u16 reg, u8 val)
+{
+	int ret;
+
+	ret = regmap_raw_write(state->regmap, reg, &val, 1);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+			__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				 __func__, reg, val);
+
+	return ret;
+}
+#endif
+
+static int ds5_write(struct ds5 *state, u16 reg, u16 val)
+{
+	int ret;
+	u8 value[2];
+
+	value[1] = val >> 8;
+	value[0] = val & 0x00FF;
+
+	dev_dbg(&state->client->dev,
+			"%s(): writing to register: 0x%04x, value1: 0x%x, value2:0x%x\n",
+			__func__, reg, value[1], value[0]);
+
+	ret = regmap_raw_write(state->regmap, reg, value, sizeof(value));
+	if (ret < 0)
+		dev_err(&state->client->dev,
+				"%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+				__func__, ret, reg, val);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+				__func__, reg, val);
+
+	return ret;
+}
+
+static int ds5_raw_write(struct ds5 *state, u16 reg,
+		const void *val, size_t val_len)
+{
+	int ret = regmap_raw_write(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev,
+				"%s(): i2c raw write failed %d, %04x size(%d) bytes\n",
+				__func__, ret, reg, (int)val_len);
+	else
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev,
+					"%s(): i2c raw write 0x%04x: %d bytes\n",
+					__func__, reg, (int)val_len);
+	//usleep_range(100, 110);
+	return ret;
+}
+
+static int ds5_read(struct ds5 *state, u16 reg, u16 *val)
+{
+	int ret = regmap_raw_read(state->regmap, reg, val, 2);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+				__func__, ret, reg);
+	else {
+		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
+			dev_dbg(&state->client->dev, "%s(): i2c read 0x%04x: 0x%x\n",
+					__func__, reg, *val);
+	}
+	//usleep_range(100, 110);
+	return ret;
+}
+
+static int ds5_raw_read(struct ds5 *state, u16 reg, void *val, size_t val_len)
+{
+	int ret = regmap_raw_read(state->regmap, reg, val, val_len);
+	if (ret < 0)
+		dev_err(&state->client->dev, "%s(): i2c read failed %d, 0x%04x\n",
+			__func__, ret, reg);
+
+	return ret;
+}
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static s64 d4xx_query_sub_stream[NR_OF_CSI2_BE_SOC_STREAMS];
+static u8 d4xx_set_sub_stream[NR_OF_CSI2_BE_SOC_STREAMS];
+static void set_sub_stream_fmt(int index, u32 code)
+{
+	d4xx_query_sub_stream[index] &= 0xFFFFFFFFFFFF0000;
+	d4xx_query_sub_stream[index] |= code;
+}
+
+static void set_sub_stream_h(int index, u32 height)
+{
+	s64 val = height;
+
+	val &= 0xFFFF;
+	d4xx_query_sub_stream[index] &= 0xFFFFFFFF0000FFFF;
+	d4xx_query_sub_stream[index] |= val << 16;
+}
+
+static void set_sub_stream_w(int index, u32 width)
+{
+	s64 val = width;
+
+	val &= 0xFFFF;
+	d4xx_query_sub_stream[index] &= 0xFFFF0000FFFFFFFF;
+	d4xx_query_sub_stream[index] |= val << 32;
+}
+
+static void set_sub_stream_dt(int index, u32 dt)
+{
+	s64 val = dt;
+
+	val &= 0xFF;
+	d4xx_query_sub_stream[index] &= 0xFF00FFFFFFFFFFFF;
+	d4xx_query_sub_stream[index] |= val << 48;
+}
+
+static void set_sub_stream_vc_id(int index, u32 vc_id)
+{
+	s64 val = vc_id;
+
+	val &= 0xFF;
+	d4xx_query_sub_stream[index] &= 0x00FFFFFFFFFFFFFF;
+	d4xx_query_sub_stream[index] |= val << 56;
+}
+
+static int get_sub_stream_vc_id(int index)
+{
+	s64 val = 0;
+
+	val = d4xx_query_sub_stream[index] >> 56;
+	val &= 0xFF;
+	return (int)val;
+}
+#endif
+
+/* Pad ops */
+
+static const u16 ds5_default_framerate = 30;
+
+// **********************
+// FIXME: D16 width must be doubled, because an 8-bit format is used. Check how
+// the Tegra driver propagates resolutions and formats.
+// **********************
+
+//TODO: keep 6, till 5 is supported by FW
+static const u16 ds5_framerates[] = {5, 30};
+
+#define DS5_FRAMERATE_DEFAULT_IDX 1
+
+static const u16 ds5_framerate_30 = 30;
+
+static const u16 ds5_framerate_15_30[] = {15, 30};
+
+static const u16 ds5_framerate_25 = 25;
+
+static const u16 ds5_depth_framerate_to_30[] = {5, 15, 30};
+static const u16 ds5_framerate_to_30[] = {5, 10, 15, 30};
+static const u16 ds5_framerate_to_60[] = {5, 15, 30, 60};
+static const u16 ds5_framerate_to_90[] = {5, 15, 30, 60, 90};
+static const u16 ds5_framerate_100[] = {100};
+static const u16 ds5_framerate_90[] = {90};
+static const u16 ds5_imu_framerates[] = {50, 100, 200, 400};
+
+static const struct ds5_resolution d43x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  848,
+		.height = 100,
+		.framerates = ds5_framerate_100,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_100),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  256,
+		.height = 144,
+		.framerates = ds5_framerate_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_90),
+	},
+};
+
+static const struct ds5_resolution d46x_depth_sizes[] = {
+	{
+		.width = 1280,
+		.height = 960,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution y8_sizes[] = {
+	{
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_depth_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_depth_framerate_to_30),
+	}, {
+		.width =  848,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width =  424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}
+};
+
+static const struct ds5_resolution ds5_rlt_rgb_sizes[] = {
+	{
+		.width = 1280,
+		.height = 800,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerate_to_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_30),
+	}, {
+		.width = 848,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 640,
+		.height = 360,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 480,
+		.height = 270,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 424,
+		.height = 240,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	},
+};
+
+static const struct ds5_resolution ds5_onsemi_rgb_sizes[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.framerates = ds5_framerate_to_90,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_90),
+	}, {
+		.width = 960,
+		.height = 720,
+		.framerates = ds5_framerate_to_60,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_to_60),
+	}, {
+		.width = 1280,
+		.height = 720,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 1920,
+		.height = 1080,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	}, {
+		.width = 2048,
+		.height = 1536,
+		.framerates = ds5_framerates,
+		.n_framerates = ARRAY_SIZE(ds5_framerates),
+	},
+};
+
+static const struct ds5_resolution ds5_size_w10 = {
+	.width =  1920,
+	.height = 1080,
+	.framerates = &ds5_framerate_30,
+	.n_framerates = 1,
+};
+
+static const struct ds5_resolution d43x_calibration_sizes[] = {
+	{
+		.width =  1280,
+		.height = 800,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution d46x_calibration_sizes[] = {
+	{
+		.width =  1600,
+		.height = 1300,
+		.framerates = ds5_framerate_15_30,
+		.n_framerates = ARRAY_SIZE(ds5_framerate_15_30),
+	},
+};
+
+static const struct ds5_resolution ds5_size_imu[] = {
+	{
+	.width = 32,
+	.height = 1,
+	.framerates = ds5_imu_framerates,
+	.n_framerates = ARRAY_SIZE(ds5_imu_framerates),
+	},
+};
+
+// 32 bit IMU introduced with IMU sensitivity attribute Firmware
+static const struct ds5_resolution ds5_size_imu_extended[] = {
+	{
+	.width = 38,
+	.height = 1,
+	.framerates = ds5_imu_framerates,
+	.n_framerates = ARRAY_SIZE(ds5_imu_framerates),
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d43x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = GMSL_CSI_DT_YUV422_8,	/* Z16 */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = GMSL_CSI_DT_RAW_8,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d43x_depth_sizes),
+		.resolutions = d43x_depth_sizes,
+	}, {
+		.data_type = GMSL_CSI_DT_RGB_888,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_depth_formats_d46x[] = {
+	{
+		// TODO: 0x31 is replaced with 0x1e since it caused low FPS in Jetson.
+		.data_type = GMSL_CSI_DT_YUV422_8,	/* Z16 */
+		.mbus_code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		/* First format: default */
+		.data_type = GMSL_CSI_DT_RAW_8,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(d46x_depth_sizes),
+		.resolutions = d46x_depth_sizes,
+	}, {
+		.data_type = GMSL_CSI_DT_RGB_888,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d46x_calibration_sizes),
+		.resolutions = d46x_calibration_sizes,
+	},
+};
+
+#define DS5_DEPTH_N_FORMATS 1
+
+static const struct ds5_format ds5_y_formats_ds5u[] = {
+	{
+		/* First format: default */
+		.data_type = GMSL_CSI_DT_RAW_8,	/* Y8 */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = GMSL_CSI_DT_YUV422_8,	/* Y8I */
+		.mbus_code = MEDIA_BUS_FMT_VYUY8_1X16,
+		.n_resolutions = ARRAY_SIZE(y8_sizes),
+		.resolutions = y8_sizes,
+	}, {
+		.data_type = GMSL_CSI_DT_RGB_888,	/* 24-bit Calibration */
+		.mbus_code = MEDIA_BUS_FMT_RGB888_1X24,	/* FIXME */
+		.n_resolutions = ARRAY_SIZE(d43x_calibration_sizes),
+		.resolutions = d43x_calibration_sizes,
+	},
+};
+
+static const struct ds5_format ds5_rlt_rgb_format = {
+	.data_type = GMSL_CSI_DT_YUV422_8,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_rlt_rgb_sizes),
+	.resolutions = ds5_rlt_rgb_sizes,
+};
+#define DS5_RLT_RGB_N_FORMATS 1
+
+static const struct ds5_format ds5_onsemi_rgb_format = {
+	.data_type = GMSL_CSI_DT_YUV422_8,	/* UYVY */
+	.mbus_code = MEDIA_BUS_FMT_YUYV8_1X16,
+	.n_resolutions = ARRAY_SIZE(ds5_onsemi_rgb_sizes),
+	.resolutions = ds5_onsemi_rgb_sizes,
+};
+#define DS5_ONSEMI_RGB_N_FORMATS 1
+
+static const struct ds5_variant ds5_variants[] = {
+	[DS5_DS5U] = {
+		.formats = ds5_y_formats_ds5u,
+		.n_formats = ARRAY_SIZE(ds5_y_formats_ds5u),
+	},
+};
+
+static const struct ds5_format ds5_imu_formats[] = {
+	{
+		/* First format: default */
+		.data_type = GMSL_CSI_DT_RAW_8,	/* IMU DT */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(ds5_size_imu),
+		.resolutions = ds5_size_imu,
+	},
+};
+
+static const struct ds5_format ds5_imu_formats_extended[] = {
+	{
+		/* First format: default */
+		.data_type = GMSL_CSI_DT_RAW_8,	/* IMU DT */
+		.mbus_code = MEDIA_BUS_FMT_Y8_1X8,
+		.n_resolutions = ARRAY_SIZE(ds5_size_imu_extended),
+		.resolutions = ds5_size_imu_extended,
+	},
+};
+
+static const struct v4l2_mbus_framefmt ds5_mbus_framefmt_template = {
+	.width = 0,
+	.height = 0,
+	.code = MEDIA_BUS_FMT_FIXED,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_DEFAULT,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+/* Get readable sensor name */
+static const char *ds5_get_sensor_name(struct ds5 *state)
+{
+	static const char *sensor_name[] = {"unknown", "RGB", "DEPTH", "Y8", "IMU"};
+	int sensor_id = state->is_rgb * 1 + state->is_depth * 2 + \
+			state->is_y8 * 3 + state->is_imu * 4;
+	if (sensor_id >= (sizeof(sensor_name)/sizeof(*sensor_name)))
+		sensor_id = 0;
+
+	return sensor_name[sensor_id];
+}
+
+static void ds5_set_state_last_set(struct ds5 *state)
+{
+	 dev_dbg(&state->client->dev, "%s(): %s\n",
+		__func__, ds5_get_sensor_name(state));
+
+	if (state->is_depth)
+		state->mux.last_set = &state->depth.sensor;
+	else if (state->is_rgb)
+		state->mux.last_set = &state->rgb.sensor;
+	else if (state->is_y8)
+		state->mux.last_set = &state->ir.sensor;
+	else
+		state->mux.last_set = &state->imu.sensor;
+}
+
+/* This is needed for .get_fmt()
+ * and if streaming is started without .set_fmt()
+ */
+static void ds5_sensor_format_init(struct ds5_sensor *sensor)
+{
+	const struct ds5_format *fmt;
+	struct v4l2_mbus_framefmt *ffmt;
+	unsigned int i;
+
+	if (sensor->config.format)
+		return;
+
+	dev_dbg(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
+
+	ffmt = &sensor->format;
+	*ffmt = ds5_mbus_framefmt_template;
+	/* Use the first format */
+	fmt = sensor->formats;
+	ffmt->code = fmt->mbus_code;
+	/* and the first resolution */
+	ffmt->width = fmt->resolutions->width;
+	ffmt->height = fmt->resolutions->height;
+
+	sensor->config.format = fmt;
+	sensor->config.resolution = fmt->resolutions;
+	/* Set default framerate to 30, or to 1st one if not supported */
+	for (i = 0; i < fmt->resolutions->n_framerates; i++) {
+		if (fmt->resolutions->framerates[i] == ds5_framerate_30 /* fps */) {
+			sensor->config.framerate = ds5_framerate_30;
+			return;
+		}
+	}
+	sensor->config.framerate = fmt->resolutions->framerates[0];
+}
+
+/* No locking needed for enumeration methods */
+static int ds5_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+				     struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	dev_dbg(sensor->sd.dev, "%s(): sensor %s pad: %d index: %d\n",
+		__func__, sensor->sd.name, mce->pad, mce->index);
+	if (mce->pad)
+		return -EINVAL;
+
+	if (mce->index >= sensor->n_formats)
+		return -EINVAL;
+
+	mce->code = sensor->formats[mce->index].mbus_code;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_size(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	const struct ds5_format *fmt;
+	unsigned int i;
+
+	dev_dbg(sensor->sd.dev, "%s(): sensor %s is %s\n",
+		__func__, sensor->sd.name, ds5_get_sensor_name(state));
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fse->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	if (fse->index >= fmt->n_resolutions)
+		return -EINVAL;
+
+	fse->min_width = fse->max_width = fmt->resolutions[fse->index].width;
+	fse->min_height = fse->max_height = fmt->resolutions[fse->index].height;
+
+	return 0;
+}
+
+static int ds5_sensor_enum_frame_interval(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+					  struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	const struct ds5_format *fmt;
+	const struct ds5_resolution *res;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
+		if (fie->code == fmt->mbus_code)
+			break;
+
+	if (i == sensor->n_formats)
+		return -EINVAL;
+
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++)
+		if (res->width == fie->width && res->height == fie->height)
+			break;
+
+	if (i == fmt->n_resolutions)
+		return -EINVAL;
+
+	if (fie->index >= res->n_framerates)
+		return -EINVAL;
+
+	fie->interval.numerator = 1;
+	fie->interval.denominator = res->framerates[fie->index];
+
+	return 0;
+}
+
+static int ds5_sensor_get_fmt(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		fmt->format = *v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+#else
+		fmt->format = *v4l2_subdev_get_try_format(sd, v4l2_state, fmt->pad);
+#endif
+	else
+		fmt->format = sensor->format;
+
+	mutex_unlock(&state->lock);
+
+	dev_dbg(sd->dev, "%s(): pad %x, code %x, res %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	return 0;
+}
+
+/* Called with lock held */
+static const struct ds5_format *ds5_sensor_find_format(
+		struct ds5_sensor *sensor,
+		struct v4l2_mbus_framefmt *ffmt,
+		const struct ds5_resolution **best)
+{
+	const struct ds5_resolution *res;
+	const struct ds5_format *fmt;
+	unsigned long best_delta = ~0;
+	unsigned int i;
+
+	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++) {
+		if (fmt->mbus_code == ffmt->code)
+			break;
+	}
+	dev_dbg(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n",
+		__func__, fmt->mbus_code, ffmt->code);
+
+	if (i == sensor->n_formats) {
+		/* Not found, use default */
+		dev_dbg(sensor->sd.dev, "%s:%d Not found, use default\n",
+			__func__, __LINE__);
+		fmt = sensor->formats;
+	}
+	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
+		unsigned long delta = abs(ffmt->width * ffmt->height -
+				res->width * res->height);
+		if (delta < best_delta) {
+			best_delta = delta;
+			*best = res;
+		}
+	}
+
+	ffmt->code = fmt->mbus_code;
+	ffmt->width = (*best)->width;
+	ffmt->height = (*best)->height;
+
+	ffmt->field = V4L2_FIELD_NONE;
+	/* Should we use V4L2_COLORSPACE_RAW for Y12I? */
+	ffmt->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return fmt;
+}
+
+#define MIPI_CSI2_TYPE_NULL	0x10
+#define MIPI_CSI2_TYPE_BLANKING		0x11
+#define MIPI_CSI2_TYPE_EMBEDDED8	0x12
+#define MIPI_CSI2_TYPE_YUV422_8		0x1e
+#define MIPI_CSI2_TYPE_YUV422_10	0x1f
+#define MIPI_CSI2_TYPE_RGB565	0x22
+#define MIPI_CSI2_TYPE_RGB888	0x24
+#define MIPI_CSI2_TYPE_RAW6	0x28
+#define MIPI_CSI2_TYPE_RAW7	0x29
+#define MIPI_CSI2_TYPE_RAW8	0x2a
+#define MIPI_CSI2_TYPE_RAW10	0x2b
+#define MIPI_CSI2_TYPE_RAW12	0x2c
+#define MIPI_CSI2_TYPE_RAW14	0x2d
+/* 1-8 */
+#define MIPI_CSI2_TYPE_USER_DEF(i)	(0x30 + (i) - 1)
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static unsigned int mbus_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_RGB565_1X16:
+		return MIPI_CSI2_TYPE_RGB565;
+	case MEDIA_BUS_FMT_RGB888_1X24:
+		return MIPI_CSI2_TYPE_RGB888;
+	case MEDIA_BUS_FMT_YUYV10_1X20:
+		return MIPI_CSI2_TYPE_YUV422_10;
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_VYUY8_1X16:
+		return MIPI_CSI2_TYPE_YUV422_8;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		return MIPI_CSI2_TYPE_RAW12;
+	case MEDIA_BUS_FMT_Y10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		return MIPI_CSI2_TYPE_RAW10;
+	case MEDIA_BUS_FMT_Y8_1X8:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		return MIPI_CSI2_TYPE_RAW8;
+	case MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:
+	case MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:
+		return MIPI_CSI2_TYPE_USER_DEF(1);
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+}
+#endif
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static int ds5_s_state_pad(struct ds5 *state, int pad)
+{
+	int ret = 0;
+
+	dev_dbg(&state->client->dev, "%s(): set state for pad: %d\n", __func__, pad);
+
+	switch (pad) {
+	case DS5_MUX_PAD_DEPTH:
+		state->is_depth = 1;
+		state->is_rgb = 0;
+		state->is_y8 = 0;
+		state->is_imu = 0;
+		break;
+	case DS5_MUX_PAD_RGB:
+		state->is_depth = 0;
+		state->is_rgb = 1;
+		state->is_y8 = 0;
+		state->is_imu = 0;
+		break;
+	case DS5_MUX_PAD_IR:
+		state->is_depth = 0;
+		state->is_rgb = 0;
+		state->is_y8 = 1;
+		state->is_imu = 0;
+		break;
+	case DS5_MUX_PAD_IMU:
+		state->is_depth = 0;
+		state->is_rgb = 0;
+		state->is_y8 = 0;
+		state->is_imu = 1;
+		break;
+	default:
+		dev_warn(&state->client->dev, "%s(): unknown pad: %d\n", __func__, pad);
+		ret = -EINVAL;
+		break;
+	}
+	ds5_set_state_last_set(state);
+	return ret;
+}
+
+static int ds5_s_state(struct ds5 *state, int vc)
+{
+	int ret = 0;
+	int i = 0;
+	int pad = 0;
+	for (i = 0; i < ARRAY_SIZE(state->pad_to_vc); i++) {
+		if (state->pad_to_vc[i] == vc) {
+			pad = i;
+			break;
+		}
+	}
+
+	dev_info(&state->client->dev, "%s(): set state for vc: %d on pad: %d\n", __func__, vc, pad);
+
+	ret = ds5_s_state_pad(state, pad);
+	return ret;
+}
+
+#endif
+
+static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+				struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *mf;// = &fmt->format;
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	int substream = -1;
+#endif
+	//unsigned r;
+
+	dev_dbg(sensor->sd.dev, "%s(): state %p, "
+		"sensor %p, fmt %p, fmt->format %p\n",
+		__func__, state, sensor, fmt,  &fmt->format);
+
+	mf = &fmt->format;
+
+	if (fmt->pad)
+		return -EINVAL;
+
+	mutex_lock(&state->lock);
+
+	sensor->config.format = ds5_sensor_find_format(sensor, mf,
+						&sensor->config.resolution);
+	//r = DS5_FRAMERATE_DEFAULT_IDX < sensor->config.resolution->n_framerates ?
+	//	DS5_FRAMERATE_DEFAULT_IDX : 0;
+	/* FIXME: check if a framerate has been set */
+	//sensor->config.framerate = sensor->config.resolution->framerates[r];
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	if (cfg && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		*v4l2_subdev_get_try_format(&sensor->sd, cfg, fmt->pad) = *mf;
+#else
+	if (v4l2_state && fmt->which == V4L2_SUBDEV_FORMAT_TRY)
+		*v4l2_subdev_get_try_format(&sensor->sd, v4l2_state, fmt->pad) = *mf;
+#endif
+
+	else
+// FIXME: use this format in .s_stream()
+		sensor->format = *mf;
+
+	state->mux.last_set = sensor;
+
+	mutex_unlock(&state->lock);
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	substream = state->pad_to_substream[sensor->mux_pad];
+
+	if (substream != -1) {
+		set_sub_stream_fmt(substream, mf->code);
+		set_sub_stream_h(substream, mf->height);
+		set_sub_stream_w(substream, mf->width);
+		set_sub_stream_dt(substream, mbus_code_to_mipi(mf->code));
+	}
+
+	dev_dbg(sensor->sd.dev, "%s(): fmt->pad: %d, sensor->mux_pad: %d, code: 0x%x, %ux%u substream:%d\n", __func__,
+		fmt->pad, sensor->mux_pad, fmt->format.code,
+		fmt->format.width, fmt->format.height, substream);
+#endif
+	return 0;
+}
+
+static int ds5_sensor_set_fmt(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+			      struct v4l2_subdev_format *fmt)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	/* set state by vc */
+	ds5_s_state_pad(state, sensor->mux_pad);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	return __ds5_sensor_set_fmt(state, sensor, cfg, fmt);
+#else
+	return __ds5_sensor_set_fmt(state, sensor, v4l2_state, fmt);
+#endif
+}
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+static int ds5_setup_pipeline(struct ds5 *state, u8 data_type1, u8 data_type2,
+			      int pipe_id, u32 vc_id)
+{
+	int ret = 0;
+	dev_dbg(&state->client->dev,
+			 "set pipe %d, data_type1: 0x%x, \
+			 data_type2: 0x%x, vc_id: %u\n",
+			 pipe_id, data_type1, data_type2, vc_id);
+	ret |= max9295_set_pipe(state->ser_dev, pipe_id,
+				data_type1, data_type2, vc_id);
+	ret |= max9296_set_pipe(state->dser_dev, pipe_id,
+				data_type1, data_type2, vc_id);
+	if (ret)
+		dev_warn(&state->client->dev,
+			 "failed to set pipe %d, data_type1: 0x%x, \
+			 data_type2: 0x%x, vc_id: %u\n",
+			 pipe_id, data_type1, data_type2, vc_id);
+
+	return ret;
+}
+#endif
+
+static int ds5_configure(struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 fmt, md_fmt, vc_id;
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	u16 data_type1, data_type2;
+#endif
+	u16 dt_addr, md_addr, override_addr, fps_addr, width_addr, height_addr;
+	int ret;
+
+	if (state->is_depth) {
+		sensor = &state->depth.sensor;
+		dt_addr = DS5_DEPTH_STREAM_DT;
+		md_addr = DS5_DEPTH_STREAM_MD;
+		override_addr = DS5_DEPTH_OVERRIDE;
+		fps_addr = DS5_DEPTH_FPS;
+		width_addr = DS5_DEPTH_RES_WIDTH;
+		height_addr = DS5_DEPTH_RES_HEIGHT;
+		md_fmt = GMSL_CSI_DT_EMBED;
+		vc_id = state->g_ctx.dst_vc;
+	} else if (state->is_rgb) {
+		sensor = &state->rgb.sensor;
+		dt_addr = DS5_RGB_STREAM_DT;
+		md_addr = DS5_RGB_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_RGB_FPS;
+		width_addr = DS5_RGB_RES_WIDTH;
+		height_addr = DS5_RGB_RES_HEIGHT;
+		md_fmt = GMSL_CSI_DT_EMBED;
+		vc_id = state->g_ctx.dst_vc;
+	} else if (state->is_y8) {
+		sensor = &state->ir.sensor;
+		dt_addr = DS5_IR_STREAM_DT;
+		md_addr = DS5_IR_STREAM_MD;
+		override_addr = DS5_IR_OVERRIDE;
+		fps_addr = DS5_IR_FPS;
+		width_addr = DS5_IR_RES_WIDTH;
+		height_addr = DS5_IR_RES_HEIGHT;
+		md_fmt = GMSL_CSI_DT_EMBED;
+		vc_id = state->g_ctx.dst_vc;
+	} else if (state->is_imu) {
+		sensor = &state->imu.sensor;
+		dt_addr = DS5_IMU_STREAM_DT;
+		md_addr = DS5_IMU_STREAM_MD;
+		override_addr = 0;
+		fps_addr = DS5_IMU_FPS;
+		width_addr = DS5_IMU_RES_WIDTH;
+		height_addr = DS5_IMU_RES_HEIGHT;
+		md_fmt = 0x0;
+		vc_id = state->g_ctx.dst_vc;
+	} else {
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	data_type1 = sensor->config.format->data_type;
+	data_type2 = state->is_y8 ? 0x00 : md_fmt;
+
+	//vc_id = state->g_ctx.dst_vc;
+
+	ret = ds5_setup_pipeline(state, data_type1, data_type2, sensor->pipe_id,
+				 state->g_ctx.dst_vc);
+	// reset data path when switching to Y12I
+	if (state->is_y8 && data_type1 == GMSL_CSI_DT_RGB_888)
+		max9296_reset_oneshot(state->dser_dev);
+	if (ret < 0)
+		return ret;
+#endif
+
+	fmt = sensor->streaming ? sensor->config.format->data_type : 0;
+
+	/*
+	 * Set depth stream Z16 data type as 0x31
+	 * Set IR stream Y8I data type as 0x32
+	 */
+	if (state->is_depth && fmt != 0)
+		ret = ds5_write(state, dt_addr, 0x31);
+	else if (state->is_y8 && fmt != 0 &&
+		 sensor->config.format->data_type == GMSL_CSI_DT_YUV422_8)
+		ret = ds5_write(state, dt_addr, 0x32);
+	else
+		ret = ds5_write(state, dt_addr, fmt);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, md_addr, (vc_id << 8) | md_fmt);
+	if (ret < 0)
+		return ret;
+
+	if (!sensor->streaming)
+		return ret;
+
+	if (override_addr != 0) {
+		ret = ds5_write(state, override_addr, fmt);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ds5_write(state, fps_addr, sensor->config.framerate);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, width_addr, sensor->config.resolution->width);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_write(state, height_addr, sensor->config.resolution->height);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_depth_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static int ds5_sensor_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target);
+
+static int ds5_sensor_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __ds5_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+static int ds5_sensor_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
+
+	dev_dbg(sensor->sd.dev, "%s(): sensor: name=%s state=%d\n",
+		__func__, sensor->sd.name, on);
+
+	sensor->streaming = on;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ds5_sensor_video_ops = {
+	.g_frame_interval	= ds5_sensor_g_frame_interval,
+	.s_frame_interval	= ds5_sensor_s_frame_interval,
+	.s_stream		= ds5_sensor_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_depth_subdev_ops = {
+	.pad = &ds5_depth_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* InfraRed stream Y8/Y16 */
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both */
+static const struct v4l2_subdev_pad_ops ds5_ir_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_ir_subdev_ops = {
+	.pad = &ds5_ir_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+/* FIXME: identical to ds5_depth_pad_ops, use one for both? */
+static const struct v4l2_subdev_pad_ops ds5_rgb_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_rgb_subdev_ops = {
+	.pad = &ds5_rgb_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static const struct v4l2_subdev_pad_ops ds5_imu_pad_ops = {
+	.enum_mbus_code		= ds5_sensor_enum_mbus_code,
+	.enum_frame_size	= ds5_sensor_enum_frame_size,
+	.enum_frame_interval	= ds5_sensor_enum_frame_interval,
+	.get_fmt		= ds5_sensor_get_fmt,
+	.set_fmt		= ds5_sensor_set_fmt,
+};
+
+static const struct v4l2_subdev_ops ds5_imu_subdev_ops = {
+	.pad = &ds5_imu_pad_ops,
+	.video = &ds5_sensor_video_ops,
+};
+
+static int ds5_hw_set_auto_exposure(struct ds5 *state, u32 base, s32 val)
+{
+	if (val != V4L2_EXPOSURE_APERTURE_PRIORITY &&
+		val != V4L2_EXPOSURE_MANUAL)
+		return -EINVAL;
+
+	/*
+	 * In firmware color auto exposure setting follow the uvc_menu_info
+	 * exposure_auto_controls numbers, in drivers/media/usb/uvc/uvc_ctrl.c.
+	 */
+	if (state->is_rgb && val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+		val = 8;
+
+	/*
+	 * In firmware depth auto exposure on: 1, off: 0.
+	 */
+	if (!state->is_rgb) {
+		if (val == V4L2_EXPOSURE_APERTURE_PRIORITY)
+			val = 1;
+		else if (val == V4L2_EXPOSURE_MANUAL)
+			val = 0;
+	}
+
+	return ds5_write(state, base | DS5_AUTO_EXPOSURE_MODE, (u16)val);
+}
+
+/*
+ * Manual exposure in us
+ * Depth/Y8: between 100 and 200000 (200ms)
+ * Color: between 100 and 1000000 (1s)
+ */
+static int ds5_hw_set_exposure(struct ds5 *state, u32 base, s32 val)
+{
+	int ret = -1;
+
+	if (val < 1)
+		val = 1;
+	if ((state->is_depth || state->is_y8) && val > MAX_DEPTH_EXP)
+		val = MAX_DEPTH_EXP;
+	if (state->is_rgb && val > MAX_RGB_EXP)
+		val = MAX_RGB_EXP;
+
+	/*
+	 * Color and depth uses different unit:
+	 *	Color: 1 is 100 us
+	 *	Depth: 1 is 1 us
+	 */
+
+	ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_MSB, (u16)(val >> 16));
+	if (!ret)
+		ret = ds5_write(state, base | DS5_MANUAL_EXPOSURE_LSB,
+				(u16)(val & 0xffff));
+
+	return ret;
+}
+
+#define DS5_MAX_LOG_WAIT 200
+#define DS5_MAX_LOG_SLEEP 10
+#define DS5_MAX_LOG_POLL (DS5_MAX_LOG_WAIT / DS5_MAX_LOG_SLEEP)
+
+// TODO: why to use DS5_DEPTH_Y_STREAMS_DT?
+#define DS5_CAMERA_CID_BASE	(V4L2_CTRL_CLASS_CAMERA | DS5_DEPTH_STREAM_DT)
+
+#define DS5_CAMERA_CID_LOG			(DS5_CAMERA_CID_BASE+0)
+#define DS5_CAMERA_CID_LASER_POWER		(DS5_CAMERA_CID_BASE+1)
+#define DS5_CAMERA_CID_MANUAL_LASER_POWER	(DS5_CAMERA_CID_BASE+2)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+3)
+#define DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+4)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET	(DS5_CAMERA_CID_BASE+5)
+#define DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET	(DS5_CAMERA_CID_BASE+6)
+#define DS5_CAMERA_CID_FW_VERSION		(DS5_CAMERA_CID_BASE+7)
+#define DS5_CAMERA_CID_GVD			(DS5_CAMERA_CID_BASE+8)
+#define DS5_CAMERA_CID_AE_ROI_GET		(DS5_CAMERA_CID_BASE+9)
+#define DS5_CAMERA_CID_AE_ROI_SET		(DS5_CAMERA_CID_BASE+10)
+#define DS5_CAMERA_CID_AE_SETPOINT_GET		(DS5_CAMERA_CID_BASE+11)
+#define DS5_CAMERA_CID_AE_SETPOINT_SET		(DS5_CAMERA_CID_BASE+12)
+#define DS5_CAMERA_CID_ERB			(DS5_CAMERA_CID_BASE+13)
+#define DS5_CAMERA_CID_EWB			(DS5_CAMERA_CID_BASE+14)
+#define DS5_CAMERA_CID_HWMC			(DS5_CAMERA_CID_BASE+15)
+
+#define DS5_CAMERA_CID_PWM			(DS5_CAMERA_CID_BASE+22)
+
+/* the HWMC will remain for legacy tools compatibility,
+ * HWMC_RW used for UVC compatibility
+ */
+#define DS5_CAMERA_CID_HWMC_RW		(DS5_CAMERA_CID_BASE+32)
+
+#define DS5_HWMC_DATA			0x4900
+#define DS5_HWMC_STATUS			0x4904
+#define DS5_HWMC_RESP_LEN		0x4908
+#define DS5_HWMC_EXEC			0x490C
+
+#define DS5_HWMC_STATUS_OK		0
+#define DS5_HWMC_STATUS_ERR		1
+#define DS5_HWMC_STATUS_WIP		2
+#define DS5_HWMC_BUFFER_SIZE	1024
+
+enum DS5_HWMC_ERR {
+	DS5_HWMC_ERR_SUCCESS = 0,
+	DS5_HWMC_ERR_CMD     = -1,
+	DS5_HWMC_ERR_PARAM   = -6,
+	DS5_HWMC_ERR_NODATA  = -21,
+};
+
+static int ds5_get_hwmc_status(struct ds5 *state)
+{
+	int ret = 0;
+	u16 status = DS5_HWMC_STATUS_WIP;
+	int retries = 100;
+	int errorCode;
+	do {
+		if (retries != 100)
+			msleep_range(20);
+		ret = ds5_read(state, DS5_HWMC_STATUS, &status);
+	} while (retries-- && status == DS5_HWMC_STATUS_WIP);
+	dev_dbg(&state->client->dev,
+			"%s(): ret: 0x%x, status: 0x%x\n",
+			__func__, ret, status);
+	if (ret || status != DS5_HWMC_STATUS_OK) {
+		if (status == DS5_HWMC_STATUS_ERR) {
+			ds5_raw_read(state, DS5_HWMC_DATA, &errorCode, sizeof(errorCode));
+			switch(errorCode) {
+			case (DS5_HWMC_ERR_CMD):
+			case (DS5_HWMC_ERR_PARAM):
+				ret = -EBADMSG;
+			break;
+			case (DS5_HWMC_ERR_NODATA):
+				ret = -ENODATA;
+			break;
+
+			default:
+				dev_dbg(&state->client->dev,
+					"%s(): HWMC failed, ret: %d, status: %x, error code: %d\n",
+					__func__, ret, status, errorCode);
+				ret = -EBADMSG;
+				break;
+			}
+		}
+	}
+	if (!ret && (status != DS5_HWMC_STATUS_OK))
+		ret = -EBUSY;
+
+	return ret;
+}
+
+static int ds5_get_hwmc(struct ds5 *state, unsigned char *data,
+		u16 cmdDataLen, u16 *dataLen)
+{
+	int ret = 0;
+	u16 tmp_len = 0;
+
+	if (!data)
+		return -ENOBUFS;
+
+	memset(data, 0, cmdDataLen);
+	ret = ds5_get_hwmc_status(state);
+	if (ret) {
+		dev_dbg(&state->client->dev,
+			"%s(): HWMC status not clear, ret: %d\n",
+			__func__, ret);
+			return ret;
+	}
+
+	ret = regmap_raw_read(state->regmap, DS5_HWMC_RESP_LEN,
+			&tmp_len, sizeof(tmp_len));
+	if (ret)
+		return -EBADMSG;
+
+	if (tmp_len > cmdDataLen)
+		return -ENOBUFS;
+
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC read len: %d, lrs_len: %d\n",
+			__func__, tmp_len, tmp_len - 4);
+
+	ds5_raw_read_with_check(state, DS5_HWMC_DATA, data, tmp_len);
+	if (dataLen)
+		*dataLen = tmp_len;
+	return ret;
+}
+
+static int ds5_send_hwmc(struct ds5 *state,
+			u16 cmdLen,
+			struct hwm_cmd *cmd)
+{
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC header: 0x%x, magic: 0x%x, opcode: 0x%x, "
+			"cmdLen: %d, param1: %d, param2: %d, param3: %d, param4: %d\n",
+			__func__, cmd->header, cmd->magic_word, cmd->opcode,
+			cmdLen,	cmd->param1, cmd->param2, cmd->param3, cmd->param4);
+
+	ds5_raw_write_with_check(state, DS5_HWMC_DATA, cmd, cmdLen);
+	
+	ds5_write_with_check(state, DS5_HWMC_EXEC, 0x01); /* execute cmd */
+
+	return 0;
+}
+
+static int ds5_set_calibration_data(struct ds5 *state,
+		struct hwm_cmd *cmd, u16 length)
+{
+	int ret = -1;
+	int retries = 10;
+	u16 status = 2;
+
+	ds5_raw_write_with_check(state, DS5_HWMC_DATA, cmd, length);
+
+	ds5_write_with_check(state, DS5_HWMC_EXEC, 0x01); /* execute cmd */
+	do {
+		if (retries != 10)
+			msleep_range(200);
+		ret = ds5_read(state, DS5_HWMC_STATUS, &status);
+	} while (retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to set calibration table %d,"
+				"ret: %d, fw error: %x\n",
+				__func__, cmd->param1, ret, status);
+	}
+
+	return ret;
+}
+
+static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on);
+
+static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+					 ctrls.handler);
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct ds5_sensor *sensor = (struct ds5_sensor *)ctrl->priv;
+	int ret = -EINVAL;
+	u16 base = DS5_DEPTH_CONTROL_BASE;
+
+	if (sensor) {
+		switch (sensor->mux_pad) {
+		case DS5_MUX_PAD_DEPTH:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_depth);
+			state->is_rgb = 0;
+			state->is_depth = 1;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_RGB:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_rgb);
+			state->is_rgb = 1;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_IR:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_y8);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 1;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_IMU:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_imu);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+		default:
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+
+		}
+	}
+
+	if (state->is_rgb)
+		base = DS5_RGB_CONTROL_BASE;
+#ifndef CONFIG_VIDEO_INTEL_IPU6
+	else if (state->is_imu)
+		return -EINVAL;
+#endif
+	v4l2_dbg(3, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+	dev_dbg(&state->client->dev, "%s(): %s - ctrl: %s, value: %d\n",
+		__func__, ds5_get_sensor_name(state), ctrl->name, ctrl->val);
+
+	mutex_lock(&state->lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ds5_write(state, base | DS5_MANUAL_GAIN, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = ds5_hw_set_auto_exposure(state, base, ctrl->val);
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		ret = ds5_hw_set_exposure(state, base, ctrl->val);
+		break;
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ret = ds5_write(state, base | DS5_MANUAL_LASER_POWER,
+					ctrl->val);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET:
+		dev_dbg(&state->client->dev,
+			"%s(): DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET \n",	__func__);
+		if (ctrl->p_new.p) {
+			struct hwm_cmd *calib_cmd;
+			dev_dbg(&state->client->dev,
+				"%s(): table id: 0x%x\n",
+				__func__, *((u8 *)ctrl->p_new.p + 2));
+			if (DEPTH_CALIBRATION_ID == *((u8 *)ctrl->p_new.p + 2)) {
+				calib_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 256, GFP_KERNEL);
+				if (!calib_cmd) {
+					dev_err(&state->client->dev,
+						"%s(): Can't allocate memory for 0x%x\n",
+						__func__, ctrl->id);
+					ret = -ENOMEM;
+					break;
+				}
+				memcpy(calib_cmd, &set_calib_data, sizeof(set_calib_data));
+				calib_cmd->header = 276;
+				calib_cmd->param1 = DEPTH_CALIBRATION_ID;
+				memcpy(calib_cmd->Data, (u8 *)ctrl->p_new.p, 256);
+				ret = ds5_set_calibration_data(state, calib_cmd,
+					sizeof(struct hwm_cmd) + 256);
+				devm_kfree(&state->client->dev, calib_cmd);
+			}
+		}
+		break;
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET:
+			dev_dbg(&state->client->dev,
+				"%s(): DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET \n",
+				__func__);
+			if (ctrl->p_new.p) {
+				struct hwm_cmd *calib_cmd;
+				dev_dbg(&state->client->dev,
+					"%s(): table id %d\n",
+					__func__, *((u8 *)ctrl->p_new.p + 2));
+				if (COEF_CALIBRATION_ID == *((u8 *)ctrl->p_new.p + 2)) {
+					calib_cmd = devm_kzalloc(&state->client->dev,
+						sizeof(struct hwm_cmd) + 512, GFP_KERNEL);
+					if (!calib_cmd) {
+						dev_err(&state->client->dev,
+							"%s(): Can't allocate memory for 0x%x\n",
+							__func__, ctrl->id);
+						ret = -ENOMEM;
+						break;
+					}
+				memcpy(calib_cmd, &set_calib_data, sizeof (set_calib_data));
+				calib_cmd->header = 532;
+				calib_cmd->param1 = COEF_CALIBRATION_ID;
+				memcpy(calib_cmd->Data, (u8 *)ctrl->p_new.p, 512);
+				ret = ds5_set_calibration_data(state, calib_cmd,
+						sizeof(struct hwm_cmd) + 512);
+				devm_kfree(&state->client->dev, calib_cmd);
+			}
+		}
+		break;
+	case DS5_CAMERA_CID_AE_ROI_SET: 
+		if (ctrl->p_new.p_u16) {
+			struct hwm_cmd ae_roi_cmd;
+			memcpy(&ae_roi_cmd, &set_ae_roi, sizeof(ae_roi_cmd));
+			ae_roi_cmd.param1 = *((u16 *)ctrl->p_new.p_u16);
+			ae_roi_cmd.param2 = *((u16 *)ctrl->p_new.p_u16 + 1);
+			ae_roi_cmd.param3 = *((u16 *)ctrl->p_new.p_u16 + 2);
+			ae_roi_cmd.param4 = *((u16 *)ctrl->p_new.p_u16 + 3);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				&ae_roi_cmd);
+			if (!ret)
+				ret = ds5_get_hwmc_status(state);
+		}
+		break;
+	case DS5_CAMERA_CID_AE_SETPOINT_SET:
+		if (ctrl->p_new.p_s32) {
+			struct hwm_cmd *ae_setpoint_cmd;
+			dev_dbg(&state->client->dev, "%s():0x%x \n",
+				__func__, *(ctrl->p_new.p_s32));
+			ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 4, GFP_KERNEL);
+			if (!ae_setpoint_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ae_setpoint_cmd, &set_ae_setpoint, sizeof (set_ae_setpoint));
+			memcpy(ae_setpoint_cmd->Data, (u8 *)ctrl->p_new.p_s32, 4);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + 4,
+					ae_setpoint_cmd);
+			if (!ret)
+				ret = ds5_get_hwmc_status(state);
+			devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_ERB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			u16 len = 0;
+			struct hwm_cmd *erb_cmd;
+
+			offset = *(ctrl->p_new.p_u8) << 8;
+			offset |= *(ctrl->p_new.p_u8 + 1);
+			size = *(ctrl->p_new.p_u8 + 2) << 8;
+			size |= *(ctrl->p_new.p_u8 + 3);
+
+			dev_dbg(&state->client->dev, "%s(): offset %x, size: %x\n",
+							__func__, offset, size);
+			len = sizeof(struct hwm_cmd) + size;
+			erb_cmd = devm_kzalloc(&state->client->dev,	len, GFP_KERNEL);
+			if (!erb_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(erb_cmd, &erb, sizeof(struct hwm_cmd));
+			erb_cmd->param1 = offset;
+			erb_cmd->param2 = size;
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), erb_cmd);
+			if (!ret)
+				ret = ds5_get_hwmc(state, erb_cmd->Data, len, &size);
+			if (ret) {
+				dev_err(&state->client->dev,
+					"%s(): ERB cmd failed, ret: %d,"
+					"requested size: %d, actual size: %d\n",
+					__func__, ret, erb_cmd->param2, size);
+				devm_kfree(&state->client->dev, erb_cmd);
+				ret =  -EAGAIN;
+				break;
+			}
+
+			// Actual size returned from FW
+			*(ctrl->p_new.p_u8 + 2) = (size & 0xFF00) >> 8;
+			*(ctrl->p_new.p_u8 + 3) = (size & 0x00FF);
+
+			memcpy(ctrl->p_new.p_u8 + 4, erb_cmd->Data + 4, size - 4);
+			dev_dbg(&state->client->dev, "%s(): 0x%x 0x%x 0x%x 0x%x \n",
+				__func__,
+				*(ctrl->p_new.p_u8),
+				*(ctrl->p_new.p_u8+1),
+				*(ctrl->p_new.p_u8+2),
+				*(ctrl->p_new.p_u8+3));
+			devm_kfree(&state->client->dev, erb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_EWB:
+		if (ctrl->p_new.p_u8) {
+			u16 offset = 0;
+			u16 size = 0;
+			struct hwm_cmd *ewb_cmd;
+
+			offset = *((u8 *)ctrl->p_new.p_u8) << 8;
+			offset |= *((u8 *)ctrl->p_new.p_u8 + 1);
+			size = *((u8 *)ctrl->p_new.p_u8 + 2) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 3);
+
+			dev_dbg(&state->client->dev, "%s():0x%x 0x%x 0x%x 0x%x\n",
+					__func__,
+					*((u8 *)ctrl->p_new.p_u8),
+					*((u8 *)ctrl->p_new.p_u8 + 1),
+					*((u8 *)ctrl->p_new.p_u8 + 2),
+					*((u8 *)ctrl->p_new.p_u8 + 3));
+
+			ewb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size,
+					GFP_KERNEL);
+			if (!ewb_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ewb_cmd, &ewb, sizeof(ewb));
+			ewb_cmd->header = 0x14 + size;
+			ewb_cmd->param1 = offset; // start index
+			ewb_cmd->param2 = size; // size
+			memcpy(ewb_cmd->Data, (u8 *)ctrl->p_new.p_u8 + 4, size);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + size, ewb_cmd);
+			if (!ret)
+				ret = ds5_get_hwmc_status(state);
+			if (ret) {
+				dev_err(&state->client->dev,
+					"%s(): EWB cmd failed, ret: %d,"
+					"requested size: %d, actual size: %d\n",
+					__func__, ret, ewb_cmd->param2, size);
+				devm_kfree(&state->client->dev, ewb_cmd);
+				ret = -ENOMEM;
+				break;
+			}
+
+			devm_kfree(&state->client->dev, ewb_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC:
+		if (ctrl->p_new.p_u8) {
+			u16 size = 0;
+			struct hwm_cmd *cmd = (struct hwm_cmd *)ctrl->p_new.p_u8;
+			size = *((u8 *)ctrl->p_new.p_u8 + 1) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 0);
+			ret = ds5_send_hwmc(state, size + 4, cmd);
+			ret = ds5_get_hwmc(state, cmd->Data, ctrl->dims[0], &size);
+			if (ctrl->dims[0] < DS5_HWMC_BUFFER_SIZE) {
+				ret = -ENODATA;
+				break;
+			}
+			/*This is needed for legacy hwmc */
+			size += 4; // SIZE_OF_HW_MONITOR_HEADER
+			cmd->Data[1000] = (unsigned char)((size) & 0x00FF);
+			cmd->Data[1001] = (unsigned char)(((size) & 0xFF00) >> 8);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC_RW:
+		if (ctrl->p_new.p_u8) {
+			u16 size = *((u8 *)ctrl->p_new.p_u8 + 1) << 8;
+			size |= *((u8 *)ctrl->p_new.p_u8 + 0);
+			ret = ds5_send_hwmc(state, size + 4,
+					(struct hwm_cmd *)ctrl->p_new.p_u8);
+		}
+		break;
+	case DS5_CAMERA_CID_PWM:
+		if (state->is_depth)
+			ret = ds5_write(state, base | DS5_PWM_FREQUENCY, ctrl->val);
+		break;
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	case V4L2_CID_IPU_SET_SUB_STREAM:
+	{
+		u32 val = (*ctrl->p_new.p_s64 & 0xFFFF);
+		u16 on = val & 0x00FF;
+		u16 vc_id = (val >> 8) & 0x00FF;
+		int substream = -1;
+		if (vc_id < DS5_MUX_PAD_COUNT)
+			ret = ds5_s_state(state, vc_id);
+		substream = state->pad_to_substream[state->mux.last_set->mux_pad];
+		dev_info(&state->client->dev, "V4L2_CID_IPU_SET_SUB_STREAM %x vc_id:%d, substream:%d, on:%d\n", val, vc_id, substream, on);
+		if (on == 0xff)
+			break;
+		if (vc_id > NR_OF_DS5_STREAMS - 1)
+			dev_err(&state->client->dev, "invalid vc %d\n", vc_id);
+		else
+			d4xx_set_sub_stream[substream] = on;
+		ret = 0;
+	}
+		break;
+#endif
+	}
+
+	mutex_unlock(&state->lock);
+
+	return ret;
+}
+
+static int ds5_get_calibration_data(struct ds5 *state, enum table_id id,
+		unsigned char *table, unsigned int length)
+{
+	struct hwm_cmd *cmd;
+	int ret = -1;
+	int retries = 3;
+	u16 status = 2;
+	u16 table_length;
+
+	cmd = devm_kzalloc(&state->client->dev,
+			sizeof(struct hwm_cmd) + length + 4, GFP_KERNEL);
+	if (!cmd) {
+		dev_err(&state->client->dev, "%s(): Can't allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	memcpy(cmd, &get_calib_data, sizeof(get_calib_data));
+	cmd->param1 = id;
+	ds5_raw_write_with_check(state, 0x4900, cmd, sizeof(struct hwm_cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to get calibration table %d, fw error: %x\n",
+				__func__, id, status);
+		devm_kfree(&state->client->dev, cmd);
+		return status;
+	}
+
+	// get table length from fw
+	ret = regmap_raw_read(state->regmap, 0x4908,
+			&table_length, sizeof(table_length));
+
+	// read table
+	ds5_raw_read_with_check(state, 0x4900, cmd->Data, table_length);
+
+	// first 4 bytes are opcode HWM, not part of calibration table
+	memcpy(table, cmd->Data + 4, length);
+	devm_kfree(&state->client->dev, cmd);
+	return 0;
+}
+
+static int ds5_gvd(struct ds5 *state, unsigned char *data)
+{
+	struct hwm_cmd cmd;
+	int ret = -1;
+	u16 length = 0;
+	u16 status = 2;
+	u8 retries = 3;
+
+	memcpy(&cmd, &gvd, sizeof(gvd));
+	ds5_raw_write_with_check(state, 0x4900, &cmd, sizeof(cmd));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	do {
+		if (retries != 3)
+			msleep_range(10);
+
+		ret = ds5_read(state, 0x4904, &status);
+	} while (ret && retries-- && status != 0);
+
+	if (ret || status != 0) {
+		dev_err(&state->client->dev,
+				"%s(): Failed to read GVD, HWM cmd status: %x\n",
+				__func__, status);
+		return status;
+	}
+
+	ret = regmap_raw_read(state->regmap, 0x4908, &length, sizeof(length));
+	ds5_raw_read_with_check(state, 0x4900, data, length);
+
+	return ret;
+}
+
+static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ds5 *state = container_of(ctrl->handler, struct ds5,
+			ctrls.handler);
+	u16 log_prepare[] = {0x0014, 0xcdab, 0x000f, 0x0000, 0x0400, 0x0000,
+			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+	u16 execute_cmd = 0x0001;
+	unsigned int i;
+	u32 data;
+	int ret = 0;
+	struct ds5_sensor *sensor = (struct ds5_sensor *)ctrl->priv;
+	u16 base = (state->is_rgb) ? DS5_RGB_CONTROL_BASE : DS5_DEPTH_CONTROL_BASE;
+	u16 reg;
+
+	if (sensor) {
+		switch (sensor->mux_pad) {
+		case DS5_MUX_PAD_DEPTH:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_depth);
+			state->is_rgb = 0;
+			state->is_depth = 1;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_RGB:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_rgb);
+			state->is_rgb = 1;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_IR:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_y8);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 1;
+			state->is_imu = 0;
+		break;
+		case DS5_MUX_PAD_IMU:
+			state = container_of(ctrl->handler, struct ds5, ctrls.handler_imu);
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+		default:
+			state->is_rgb = 0;
+			state->is_depth = 0;
+			state->is_y8 = 0;
+			state->is_imu = 1;
+		break;
+
+		}
+	}
+	base = (state->is_rgb) ? DS5_RGB_CONTROL_BASE : DS5_DEPTH_CONTROL_BASE;
+
+	dev_dbg(&state->client->dev, "%s(): %s - ctrl: %s \n",
+		__func__, ds5_get_sensor_name(state), ctrl->name);
+
+	mutex_lock(&state->lock);
+	
+	switch (ctrl->id) {
+
+	case V4L2_CID_ANALOGUE_GAIN:
+		if (state->is_imu){
+			ret = -EINVAL;
+			break;
+		}
+		ret = ds5_read(state, base | DS5_MANUAL_GAIN, ctrl->p_new.p_u16);
+		break;
+
+	case V4L2_CID_EXPOSURE_AUTO:
+		if (state->is_imu){
+			ret = -EINVAL;
+			break;
+		}
+		ds5_read(state, base | DS5_AUTO_EXPOSURE_MODE, &reg);
+		*ctrl->p_new.p_u16 = reg;
+		/* see ds5_hw_set_auto_exposure */
+		if (!state->is_rgb) {
+			if (reg == 1)
+				*ctrl->p_new.p_u16 = V4L2_EXPOSURE_APERTURE_PRIORITY;
+			else if (reg == 0)
+				*ctrl->p_new.p_u16 = V4L2_EXPOSURE_MANUAL;
+		}
+
+		if (state->is_rgb && reg == 8)
+			*ctrl->p_new.p_u16 = V4L2_EXPOSURE_APERTURE_PRIORITY;
+
+		break;
+
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		if (state->is_imu){
+			ret = -EINVAL;
+			break;
+		}
+		/* see ds5_hw_set_exposure */
+		ds5_read(state, base | DS5_MANUAL_EXPOSURE_MSB, &reg);
+		data = ((u32)reg << 16) & 0xffff0000;
+		ds5_read(state, base | DS5_MANUAL_EXPOSURE_LSB, &reg);
+		data |= reg;
+		*ctrl->p_new.p_u32 = data;
+		break;
+
+	case DS5_CAMERA_CID_LASER_POWER:
+		if (!state->is_rgb)
+			ds5_read(state, base | DS5_LASER_POWER, ctrl->p_new.p_u16);
+		break;
+
+	case DS5_CAMERA_CID_MANUAL_LASER_POWER:
+		if (!state->is_rgb)
+			ds5_read(state, base | DS5_MANUAL_LASER_POWER, ctrl->p_new.p_u16);
+		break;
+
+	case DS5_CAMERA_CID_LOG:
+		// TODO: wrap HWMonitor command
+		//       1. prepare and send command
+		//       2. send command
+		//       3. execute command
+		//       4. wait for ccompletion
+		ret = regmap_raw_write(state->regmap, 0x4900,
+				log_prepare, sizeof(log_prepare));
+		if (ret < 0)
+			break;
+
+		ret = regmap_raw_write(state->regmap, 0x490C,
+				&execute_cmd, sizeof(execute_cmd));
+		if (ret < 0)
+			break;
+			
+		for (i = 0; i < DS5_MAX_LOG_POLL; i++) {
+			ret = regmap_raw_read(state->regmap, 0x4904,
+					&data, sizeof(data));
+			dev_dbg(&state->client->dev, "%s(): log ready 0x%x\n",
+				 __func__, data);
+			if (ret < 0)
+				break;
+			if (!data)
+				break;
+			msleep_range(5);
+		}
+
+//		if (i == DS5_MAX_LOG_POLL)
+//			return -ETIMEDOUT;
+
+		ret = regmap_raw_read(state->regmap, 0x4908, &data, sizeof(data));
+		dev_dbg(&state->client->dev, "%s(): log size 0x%x\n", __func__, data);
+		if (ret < 0)
+			break;
+		if (!data){
+			ret = 0;
+			break;
+		}
+		if (data > 1024){
+			ret = -ENOBUFS;
+			break;
+		}
+		ret = regmap_raw_read(state->regmap, 0x4900,
+				ctrl->p_new.p_u8, data);
+		break;
+	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, DEPTH_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 256);
+		break;
+	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET:
+		ret = ds5_get_calibration_data(state, COEF_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 512);
+		break;
+	case DS5_CAMERA_CID_FW_VERSION:
+		ret = ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+		ret = ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+		*ctrl->p_new.p_u32 = state->fw_version << 16;
+		*ctrl->p_new.p_u32 |= state->fw_build;
+		break;
+	case DS5_CAMERA_CID_GVD:
+		ret = ds5_gvd(state, ctrl->p_new.p_u8);
+		break;
+	case DS5_CAMERA_CID_AE_ROI_GET:
+		if (ctrl->p_new.p_u16) {
+			u16 len = sizeof(struct hwm_cmd) + 12;
+			u16 dataLen = 0;
+			struct hwm_cmd *ae_roi_cmd;
+			ae_roi_cmd = devm_kzalloc(&state->client->dev, len, GFP_KERNEL);
+			if (!ae_roi_cmd) {
+				dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+				ret = -ENOMEM;
+				break;
+			}
+			memcpy(ae_roi_cmd, &get_ae_roi, sizeof(struct hwm_cmd));
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), ae_roi_cmd);
+			if (ret) {
+				devm_kfree(&state->client->dev, ae_roi_cmd);
+				break;
+			}
+			ret = ds5_get_hwmc(state, ae_roi_cmd->Data, len, &dataLen);
+			if (!ret && dataLen <= ctrl->dims[0])
+				memcpy(ctrl->p_new.p_u16, ae_roi_cmd->Data + 4, 8);
+			devm_kfree(&state->client->dev, ae_roi_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_AE_SETPOINT_GET:
+	if (ctrl->p_new.p_s32) {
+		u16 len = sizeof(struct hwm_cmd) + 8;
+		u16 dataLen = 0;
+		struct hwm_cmd *ae_setpoint_cmd;
+		ae_setpoint_cmd = devm_kzalloc(&state->client->dev,	len, GFP_KERNEL);
+		if (!ae_setpoint_cmd) {
+			dev_err(&state->client->dev,
+					"%s(): Can't allocate memory for 0x%x\n",
+					__func__, ctrl->id);
+			ret = -ENOMEM;
+			break;
+		}
+		memcpy(ae_setpoint_cmd, &get_ae_setpoint, sizeof(struct hwm_cmd));
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), ae_setpoint_cmd);
+		if (ret) {		
+			devm_kfree(&state->client->dev, ae_setpoint_cmd);
+			break;
+		}
+		ret = ds5_get_hwmc(state, ae_setpoint_cmd->Data, len, &dataLen);
+		memcpy(ctrl->p_new.p_s32, ae_setpoint_cmd->Data + 4, 4);
+		dev_dbg(&state->client->dev, "%s(): len: %d, 0x%x \n",
+			__func__, dataLen, *(ctrl->p_new.p_s32));
+		devm_kfree(&state->client->dev, ae_setpoint_cmd);
+		}
+		break;
+	case DS5_CAMERA_CID_HWMC_RW: 
+		if (ctrl->p_new.p_u8) {
+			unsigned char *data = (unsigned char *)ctrl->p_new.p_u8;
+			u16 dataLen = 0;
+			u16 bufLen = ctrl->dims[0];
+			ret = ds5_get_hwmc(state, data,	bufLen, &dataLen);
+			if (ret) {
+				ret = 0; // LRS doesn't expect to get errors with HWMC
+				break;
+			}
+			/* This is needed for librealsense, to align there code with UVC,
+		 	 * last word is length - 4 bytes header length */
+			dataLen -= 4;
+			data[bufLen - 4] = (unsigned char)(dataLen & 0x00FF);
+			data[bufLen - 3] = (unsigned char)((dataLen & 0xFF00) >> 8);
+			data[bufLen - 2] = 0;
+			data[bufLen - 1] = 0;
+		}
+		break;
+	case DS5_CAMERA_CID_PWM:
+		if (state->is_depth)
+			ds5_read(state, base | DS5_PWM_FREQUENCY, ctrl->p_new.p_u16);
+		break;
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	case V4L2_CID_IPU_QUERY_SUB_STREAM: {
+		if (sensor) {
+			int substream = state->pad_to_substream[sensor->mux_pad];
+			int vc_id = get_sub_stream_vc_id(substream);
+
+			dev_dbg(sensor->sd.dev,
+				"%s(): V4L2_CID_IPU_QUERY_SUB_STREAM sensor->mux_pad:%d"
+				"vc:[%d] %d\n",
+				__func__, sensor->mux_pad, vc_id, substream);
+			*ctrl->p_new.p_s32 = substream;
+			state->mux.last_set = sensor;
+		} else {
+				/* we are in DS5 MUX case */
+				*ctrl->p_new.p_s32 = -1;
+		}
+	}
+		break;
+#endif
+	}
+	mutex_unlock(&state->lock);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ds5_ctrl_ops = {
+	.s_ctrl	= ds5_s_ctrl,
+	.g_volatile_ctrl = ds5_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_log = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LOG,
+	.name = "Logger",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1024},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_LASER_POWER,
+	.name = "Laser power on/off",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_manual_laser_power = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_MANUAL_LASER_POWER,
+	.name = "Manual laser power",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 360,
+	.step = 30,
+	.def = 150,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_fw_version = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_FW_VERSION,
+	.name = "fw version",
+	.type = V4L2_CTRL_TYPE_U32,
+	.dims = {1},
+	.elem_size = sizeof(u32),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_gvd = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_GVD,
+	.name = "GVD",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {239},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET,
+	.name = "get depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_depth_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET,
+	.name = "set depth calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {256},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_get_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET,
+	.name = "get coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_set_coeff_calib = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET,
+	.name = "set coeff calib",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {512},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_GET,
+	.name = "ae roi get",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_roi_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_ROI_SET,
+	.name = "ae roi set",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {8},
+	.elem_size = sizeof(u16),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_get = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_GET,
+	.name = "ae setpoint get",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ae_setpoint_set = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_AE_SETPOINT_SET,
+	.name = "ae setpoint set",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 4095,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_erb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_ERB,
+	.name = "ERB eeprom read",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_ewb = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_EWB,
+	.name = "EWB eeprom write",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {1020},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC,
+	.name = "HWMC",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {DS5_HWMC_BUFFER_SIZE + 4},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.step = 1,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_hwmc_rw = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_HWMC_RW,
+	.name = "HWMC_RW",
+	.type = V4L2_CTRL_TYPE_U8,
+	.dims = {DS5_HWMC_BUFFER_SIZE},
+	.elem_size = sizeof(u8),
+	.min = 0,
+	.max = 0xFFFFFFFF,
+	.def = 240,
+	.step = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+
+static const struct v4l2_ctrl_config ds5_ctrl_pwm = {
+	.ops = &ds5_ctrl_ops,
+	.id = DS5_CAMERA_CID_PWM,
+	.name = "PWM Frequency Selector",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE,
+};
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static const struct v4l2_ctrl_config d4xx_controls_link_freq = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_LINK_FREQ,
+	.name = "V4L2_CID_LINK_FREQ",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = ARRAY_SIZE(link_freq_menu_items) - 1,
+	.min =  0,
+	.step  = 0,
+	.def = 1,
+	.qmenu_int = link_freq_menu_items,
+};
+
+static struct v4l2_ctrl_config d4xx_controls_q_sub_stream = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_IPU_QUERY_SUB_STREAM,
+	.name = "query virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+	.max = NR_OF_DS5_SUB_STREAMS - 1,
+	.min = 0,
+	.def = 0,
+	.menu_skip_mask = 0,
+	.qmenu_int = d4xx_query_sub_stream,
+};
+
+static const struct v4l2_ctrl_config d4xx_controls_s_sub_stream = {
+	.ops = &ds5_ctrl_ops,
+	.id = V4L2_CID_IPU_SET_SUB_STREAM,
+	.name = "set virtual channel",
+	.type = V4L2_CTRL_TYPE_INTEGER64,
+	.max = 0xFFFF,
+	.min = 0,
+	.def = 0,
+	.step = 1,
+};
+#endif
+static int ds5_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	if (state->dfu_dev.dfu_state_flag)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+
+	return 0;
+};
+
+static int ds5_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	state->dfu_dev.device_open_count--;
+	return 0;
+};
+
+static const struct v4l2_subdev_internal_ops ds5_sensor_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+};
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+
+/*
+ * FIXME
+ * temporary solution before changing GMSL data structure or merging all 4 D457
+ * sensors into one i2c device. Only first sensor node per max9295 sets up the
+ * link.
+ *
+ * max 24 number from this link:
+ * https://docs.nvidia.com/jetson/archives/r35.1/DeveloperGuide/text/
+ * SD/CameraDevelopment/JetsonVirtualChannelWithGmslCameraFramework.html
+ * #jetson-agx-xavier-series
+ */
+#define MAX_DEV_NUM 24
+//static struct ds5 *serdes_inited[MAX_DEV_NUM];
+#ifdef CONFIG_OF
+static int ds5_board_setup(struct ds5 *state)
+{
+	struct device *dev = &state->client->dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *ser_node;
+	struct i2c_client *ser_i2c = NULL;
+	struct device_node *dser_node;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *gmsl;
+	int value = 0xFFFF;
+	const char *str_value;
+	int err;
+	//int i;
+
+	// err = of_property_read_u32(node, "reg", &state->g_ctx.sdev_reg);
+	// if (err < 0) {
+	// 	dev_err(dev, "reg not found\n");
+	// 	goto error;
+	// }
+
+	err = of_property_read_u32(node, "def-addr",
+					&state->g_ctx.sdev_def);
+	if (err < 0) {
+		dev_err(dev, "def-addr not found\n");
+		goto error;
+	}
+
+	ser_node = of_parse_phandle(node, "maxim,gmsl-ser-device", 0);
+	if (ser_node == NULL) {
+		/* check compatibility with jetpack */
+		ser_node = of_parse_phandle(node, "nvidia,gmsl-ser-device", 0);
+		if (ser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "[maxim|nvidia],gmsl-ser-device");
+			goto error;
+		}
+	}
+	err = of_property_read_u32(ser_node, "reg", &state->g_ctx.ser_reg);
+	dev_dbg(dev,  "serializer reg: 0x%x\n", state->g_ctx.ser_reg);
+	if (err < 0) {
+		dev_err(dev, "serializer reg not found\n");
+		goto error;
+	}
+
+	ser_i2c = of_find_i2c_device_by_node(ser_node);
+	of_node_put(ser_node);
+
+	if (ser_i2c == NULL) {
+		err = -EPROBE_DEFER;
+		goto error;
+	}
+	if (ser_i2c->dev.driver == NULL) {
+		dev_err(dev, "missing serializer driver\n");
+		goto error;
+	}
+
+	state->ser_dev = &ser_i2c->dev;
+
+	dser_node = of_parse_phandle(node, "maxim,gmsl-dser-device", 0);
+	if (dser_node == NULL) {
+		dser_node = of_parse_phandle(node, "nvidia,gmsl-dser-device", 0);
+		if (dser_node == NULL) {
+			dev_err(dev, "missing %s handle\n", "[maxim|nvidia],gmsl-dser-device");
+			goto error;
+		}
+	}
+
+	dser_i2c = of_find_i2c_device_by_node(dser_node);
+	of_node_put(dser_node);
+
+	if (dser_i2c == NULL) {
+		err = -EPROBE_DEFER;
+		goto error;
+	}
+	if (dser_i2c->dev.driver == NULL) {
+		dev_err(dev, "missing deserializer driver\n");
+		goto error;
+	}
+
+	state->dser_dev = &dser_i2c->dev;
+
+	/* populate g_ctx from DT */
+	gmsl = of_get_child_by_name(node, "gmsl-link");
+	if (gmsl == NULL) {
+		dev_err(dev, "missing gmsl-link device node\n");
+		err = -EINVAL;
+		goto error;
+	}
+
+	err = of_property_read_string(gmsl, "dst-csi-port", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No dst-csi-port found\n");
+		goto error;
+	}
+	state->g_ctx.dst_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+	err = of_property_read_string(gmsl, "src-csi-port", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No src-csi-port found\n");
+		goto error;
+	}
+	state->g_ctx.src_csi_port =
+		(!strcmp(str_value, "a")) ? GMSL_CSI_PORT_A : GMSL_CSI_PORT_B;
+
+	err = of_property_read_string(gmsl, "csi-mode", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No csi-mode found\n");
+		goto error;
+	}
+
+	if (!strcmp(str_value, "1x4")) {
+		state->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+	} else if (!strcmp(str_value, "2x4")) {
+		state->g_ctx.csi_mode = GMSL_CSI_2X4_MODE;
+	} else if (!strcmp(str_value, "4x2")) {
+		state->g_ctx.csi_mode = GMSL_CSI_4X2_MODE;
+	} else if (!strcmp(str_value, "2x2")) {
+		state->g_ctx.csi_mode = GMSL_CSI_2X2_MODE;
+	} else {
+		dev_err(dev, "invalid csi mode\n");
+		goto error;
+	}
+
+	err = of_property_read_string(gmsl, "serdes-csi-link", &str_value);
+	if (err < 0) {
+		dev_err(dev, "No serdes-csi-link found\n");
+		goto error;
+	}
+	state->g_ctx.serdes_csi_link =
+		(!strcmp(str_value, "a")) ?
+			GMSL_SERDES_CSI_LINK_A : GMSL_SERDES_CSI_LINK_B;
+
+	err = of_property_read_u32(gmsl, "st-vc", &value);
+	if (err < 0) {
+		dev_err(dev, "No st-vc info\n");
+		goto error;
+	}
+	state->g_ctx.st_vc = value;
+
+	err = of_property_read_u32(gmsl, "vc-id", &value);
+	if (err < 0) {
+		dev_err(dev, "No vc-id info\n");
+		goto error;
+	}
+	state->g_ctx.dst_vc = value;
+
+	err = of_property_read_u32(gmsl, "num-lanes", &value);
+	if (err < 0) {
+		dev_err(dev, "No num-lanes info\n");
+		goto error;
+	}
+	state->g_ctx.num_csi_lanes = value;
+	state->g_ctx.s_dev = dev;
+
+	// for (i = 0; i < MAX_DEV_NUM; i++) {
+	// 	if (!serdes_inited[i]) {
+	// 		serdes_inited[i] = state;
+	// 		return 0;
+	// 	} else if (serdes_inited[i]->ser_dev == state->ser_dev) {
+	// 		return -ENOTSUPP;
+	// 	}
+	// }
+	// err = -EINVAL;
+	// dev_err(dev, "cannot handle more than %d D457 cameras\n", MAX_DEV_NUM);
+	return 0;
+error:
+	return err;
+}
+#else
+// ds5mux i2c ser des
+// mux a - 2 0x42 0x48
+// mux b - 2 0x44 0x4a
+// mux c - 4 0x42 0x48
+// mux d - 4 0x44 0x4a
+// axiomtek
+// mux a - 2 0x42 0x48
+// mux b - 2 0x44 0x4a
+// mux c - 4 0x62 0x68
+// mux d - 4 0x64 0x6a
+
+static int ds5_board_setup(struct ds5 *state)
+{
+	struct device *dev = &state->client->dev;
+	struct d4xx_pdata *pdata = dev->platform_data;
+	struct i2c_adapter *adapter = state->client->adapter;
+	int bus = adapter->nr;
+	int err = 0;
+	int i;
+	char suffix = pdata->suffix;
+	static struct max9295_pdata max9295_pdata = {
+		.is_prim_ser = 1, // todo: configurable
+		.def_addr = 0x40, // todo: configurable
+	};
+	static struct max9296_pdata max9296_pdata = {
+		.max_src = 2,
+		.csi_mode = GMSL_CSI_2X4_MODE,
+	};
+	static struct i2c_board_info i2c_info_des = {
+		I2C_BOARD_INFO("max9296", 0x48),
+		.platform_data = &max9296_pdata,
+	};
+	static struct i2c_board_info i2c_info_ser = {
+		I2C_BOARD_INFO("max9295", 0x42),
+		.platform_data = &max9295_pdata,
+	};
+
+	i2c_info_ser.addr = pdata->subdev_info[0].ser_alias; //0x42, 0x44, 0x62, 0x64
+	state->ser_i2c = i2c_new_client_device(adapter, &i2c_info_ser);
+
+	i2c_info_des.addr = pdata->subdev_info[0].board_info.addr; //0x48, 0x4a, 0x68, 0x6a
+
+	/* look for already registered max9296, use same context if found */
+	for (i = 0; i < MAX_DEV_NUM; i++) {
+		if (serdes_inited[i] && serdes_inited[i]->dser_i2c) {
+			dev_info(dev, "MAX9296 found device on %d@0x%x\n",
+				serdes_inited[i]->dser_i2c->adapter->nr, serdes_inited[i]->dser_i2c->addr);
+			if (bus == serdes_inited[i]->dser_i2c->adapter->nr
+				&& serdes_inited[i]->dser_i2c->addr == i2c_info_des.addr) {
+				dev_info(dev, "MAX9296 AGGREGATION found device on 0x%x\n", i2c_info_des.addr);
+				state->dser_i2c = serdes_inited[i]->dser_i2c;
+				state->aggregated = 1;
+			}
+		}
+	}
+	if (state->aggregated)
+		suffix += 4;
+	dev_info(dev, "Init SerDes %c on %d@0x%x<->%d@0x%x\n",
+		suffix,
+		bus, pdata->subdev_info[0].board_info.addr, //48
+		bus, pdata->subdev_info[0].ser_alias); //42
+
+	if (!state->dser_i2c)
+		state->dser_i2c = i2c_new_client_device(adapter, &i2c_info_des);
+
+	if (state->ser_i2c == NULL) {
+		err = -EPROBE_DEFER;
+		dev_err(dev, "missing serializer client\n");
+		goto error;
+	}
+	if (state->ser_i2c->dev.driver == NULL) {
+		err = -EPROBE_DEFER;
+		dev_err(dev, "missing serializer driver\n");
+		goto error;
+	}
+	if (state->dser_i2c == NULL) {
+		err = -EPROBE_DEFER;
+		dev_err(dev, "missing deserializer client\n");
+		goto error;
+	}
+	if (state->dser_i2c->dev.driver == NULL) {
+		err = -EPROBE_DEFER;
+		dev_err(dev, "missing deserializer driver\n");
+		goto error;
+	}
+
+	// reg
+
+	state->g_ctx.sdev_reg = state->client->addr;
+	state->g_ctx.sdev_def = 0x10;// def-addr TODO: configurable
+	// Address reassignment for d4xx-a 0x10->0x12
+	dev_info(dev, "Address reassignment for %s-%c 0x%x->0x%x\n",
+		pdata->subdev_info[0].board_info.type, suffix,
+		state->g_ctx.sdev_def, state->g_ctx.sdev_reg);
+	//0x42, 0x44, 0x62, 0x64
+	state->g_ctx.ser_reg = pdata->subdev_info[0].ser_alias;
+	dev_info(dev,  "serializer: i2c-%d@0x%x\n",
+		state->ser_i2c->adapter->nr, state->g_ctx.ser_reg);
+
+	if (err < 0) {
+		dev_err(dev, "serializer reg not found\n");
+		goto error;
+	}
+
+	state->ser_dev = &state->ser_i2c->dev;
+
+	dev_info(dev,  "deserializer: i2c-%d@0x%x\n",
+		state->dser_i2c->adapter->nr, state->dser_i2c->addr);
+
+
+	state->dser_dev = &state->dser_i2c->dev;
+
+	/* populate g_ctx from pdata */
+	state->g_ctx.dst_csi_port = GMSL_CSI_PORT_A;
+	state->g_ctx.src_csi_port = GMSL_CSI_PORT_B;
+	state->g_ctx.csi_mode = GMSL_CSI_1X4_MODE;
+	if (state->aggregated) { // aggregation
+		dev_info(dev,  "configure GMSL port B\n");
+		state->g_ctx.serdes_csi_link = GMSL_SERDES_CSI_LINK_B;
+	} else {
+		dev_info(dev,  "configure GMSL port A\n");
+		state->g_ctx.serdes_csi_link = GMSL_SERDES_CSI_LINK_A;
+	}
+	state->g_ctx.st_vc = 0;
+	state->g_ctx.dst_vc = 0;
+
+	state->g_ctx.num_csi_lanes = 2;
+	state->g_ctx.s_dev = dev;
+
+	for (i = 0; i < MAX_DEV_NUM; i++) {
+		if (!serdes_inited[i]) {
+			serdes_inited[i] = state;
+			return 0;
+		} else if (serdes_inited[i]->ser_dev == state->ser_dev) {
+			return -ENOTSUPP;
+		}
+	}
+	err = -EINVAL;
+	dev_err(dev, "cannot handle more than %d D457 cameras\n", MAX_DEV_NUM);
+
+error:
+	return err;
+}
+
+#endif
+static const struct regmap_config ds5_regmap_max9296 = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static const struct regmap_config ds5_regmap_max9295 = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+static struct mutex serdes_lock__;
+
+static int ds5_gmsl_serdes_setup(struct ds5 *state)
+{
+	int err = 0;
+	int des_err = 0;
+	struct device *dev;
+
+	if (!state || !state->ser_dev || !state->dser_dev || !state->client)
+		return -EINVAL;
+
+	dev = &state->client->dev;
+
+	mutex_lock(&serdes_lock__);
+
+	max9296_power_off(state->dser_dev);
+	msleep(200);
+	/* For now no separate power on required for serializer device */
+	max9296_power_on(state->dser_dev);
+	msleep(200);
+
+	dev_dbg(dev, "Setup SERDES addressing and control pipeline\n");
+	/* setup serdes addressing and control pipeline */
+	err = max9296_setup_link(state->dser_dev, &state->client->dev);
+	if (err) {
+		dev_err(dev, "gmsl deserializer link config failed\n");
+		goto error;
+	}
+	//msleep(100);
+	err = max9295_setup_control(state->ser_dev);
+
+	/* proceed even if ser setup failed, to setup deser correctly */
+	if (err)
+		dev_err(dev, "gmsl serializer setup failed\n");
+
+	des_err = max9296_setup_control(state->dser_dev, &state->client->dev);
+	if (des_err) {
+		dev_err(dev, "gmsl deserializer setup failed\n");
+		/* overwrite err only if deser setup also failed */
+		err = des_err;
+	}
+
+error:
+	mutex_unlock(&serdes_lock__);
+	return err;
+}
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static short sensor_vc[NR_OF_DS5_STREAMS * 2] = {0,1,2,3, 2,3,0,1};
+module_param_array(sensor_vc, ushort, NULL, 0444);
+MODULE_PARM_DESC(sensor_vc, "VC set for sensors\n"
+		"\t\tsensor_vc=0,1,2,3,2,3,0,1");
+
+//#define PLATFORM_AXIOMTEK 1
+#ifdef PLATFORM_AXIOMTEK
+static short serdes_bus[4] = {5, 5, 5, 5};
+#else
+static short serdes_bus[4] = {4, 4, 2, 2};
+#endif
+module_param_array(serdes_bus, ushort, NULL, 0444);
+MODULE_PARM_DESC(serdes_bus, "max9295/6 deserializer i2c bus\n"
+		"\t\tserdes_bus=4,4,2,2");
+
+// Deserializer addresses can be 0x40 0x48 0x4a
+#ifdef PLATFORM_AXIOMTEK
+static unsigned short des_addr[4] = {0x48, 0x4a, 0x68, 0x6c};
+#else
+static unsigned short des_addr[4] = {0x48, 0x4a, 0x48, 0x4a};
+#endif
+module_param_array(des_addr, ushort, NULL, 0444);
+MODULE_PARM_DESC(des_addr, "max9296 deserializer i2c address\n"
+		"\t\tdes_addr=0x48,0x4a,0x48,0x4a");
+
+
+static int ds5_i2c_addr_setting(struct i2c_client *c, struct ds5 *state)
+{
+	int i = 0;
+	int c_addr_save = c->addr;
+	int c_bus = c->adapter->nr;
+	for (i = 0; i < 4; i++) {
+		if (c_bus == serdes_bus[i]) {
+			c->addr = des_addr[i];
+			dev_info(&c->dev, "Set max9296@%d-0x%x Link reset\n",
+					c_bus, c->addr);
+			ds5_write_8(state, 0x1000, 0x40); // reset link
+		}
+	}
+	// restore original slave address
+	c->addr = c_addr_save;
+
+	return 0;
+}
+#endif
+
+static int d4xx_gmsl_init_flag[4] = {0,0,0,0};
+
+static int ds5_serdes_setup(struct ds5 *state)
+{
+	int ret = 0;
+	struct i2c_client *c = state->client;
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	int i = 0, c_bus = 0;
+	int c_bus_new = c->adapter->nr;
+
+	for (i = 0; i < MAX_DEV_NUM; i++) {
+		if (serdes_inited[i] && serdes_inited[i]->dser_i2c) {
+			c_bus = serdes_inited[i]->dser_i2c->adapter->nr;
+			if (c_bus == c->adapter->nr) {
+				dev_info(&c->dev, "Already configured multiple camera for bus %d\n", c_bus);
+				c_bus_new = 0;
+				break;
+			}
+		} else {
+			break;
+		}
+	}
+
+	if (c_bus_new) {
+		dev_info(&c->dev, "Apply multiple camera i2c addr setting for bus %d\n", c_bus_new);
+		ret = ds5_i2c_addr_setting(c, state);
+		if (ret) {
+			dev_err(&c->dev, "failed apply i2c addr setting\n");
+			return ret;
+		}
+	}
+#endif
+	ret = ds5_board_setup(state);
+	if (ret) {
+		dev_err(&c->dev, "board setup failed\n");
+		return ret;
+	}
+
+	if(d4xx_gmsl_init_flag[state->device_id] == 0){
+		/* Pair sensor to serializer dev */
+		ret = max9295_sdev_pair(state->ser_dev, &state->g_ctx);
+		if (ret) {
+			dev_err(&c->dev, "gmsl ser pairing failed\n");
+			return ret;
+		}
+
+		/* Register sensor to deserializer dev */
+		ret = max9296_sdev_register(state->dser_dev, &state->g_ctx);
+		if (ret) {
+			dev_err(&c->dev, "gmsl deserializer register failed\n");
+			return ret;
+		}
+		d4xx_gmsl_init_flag[state->device_id] = 1;
+	}
+
+	
+	if(d4xx_gmsl_init_flag[state->device_id] == 1){
+		ret = ds5_gmsl_serdes_setup(state);
+		if (ret) {
+			dev_err(&c->dev, "%s gmsl serdes setup failed, ret=%d\n", __func__, ret);
+			d4xx_gmsl_init_flag[state->device_id] = 3;
+			return ret;
+		}
+
+		ret = max9295_init_settings(state->ser_dev);
+		if (ret) {
+			dev_warn(&c->dev, "%s, failed to init max9295 settings\n",
+				__func__);
+			d4xx_gmsl_init_flag[state->device_id] = 3;
+			return ret;
+		}
+
+		ret = max9296_init_settings(state->dser_dev);
+		if (ret) {
+			dev_warn(&c->dev, "%s, failed to init max9296 settings\n",
+				__func__);
+			d4xx_gmsl_init_flag[state->device_id] = 4;
+			return ret;
+		}
+		d4xx_gmsl_init_flag[state->device_id] = 2;
+	}else if(d4xx_gmsl_init_flag[state->device_id] == 2){
+		return 0;
+	}else{
+		return -EINVAL;
+	}
+	
+	return ret;
+}
+#endif
+enum state_sid {
+	DEPTH_SID = 0,
+	RGB_SID,
+	IR_SID,
+	IMU_SID,
+	MUX_SID = -1
+};
+
+static int ds5_ctrl_init(struct ds5 *state, int sid)
+{
+	const struct v4l2_ctrl_ops *ops = &ds5_ctrl_ops;
+	struct ds5_ctrls *ctrls = &state->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	int ret = -1;
+	struct ds5_sensor *sensor = NULL;
+
+	switch (sid) {
+	case DEPTH_SID:
+		hdl = &ctrls->handler_depth;
+		sensor = &state->depth.sensor;
+		break;
+	case RGB_SID:
+		hdl = &ctrls->handler_rgb;
+		sensor = &state->rgb.sensor;
+		break;
+	case IR_SID:
+		hdl = &ctrls->handler_y8;
+		sensor = &state->ir.sensor;
+		break;
+	case IMU_SID:
+		hdl = &ctrls->handler_imu;
+		sensor = &state->imu.sensor;
+		break;
+	default:
+		/* control for MUX */
+		hdl = &ctrls->handler;
+		sensor = NULL;
+		break;
+	}
+
+	dev_dbg(NULL, "%s():%d sid: %d\n", __func__, __LINE__, sid);
+	ret = v4l2_ctrl_handler_init(hdl, DS5_N_CONTROLS);
+	if (ret < 0) {
+		v4l2_err(sd, "cannot init ctrl handler (%d)\n", ret);
+		return ret;
+	}
+
+	if (sid == DEPTH_SID || sid == IR_SID) {
+		ctrls->laser_power = v4l2_ctrl_new_custom(hdl,
+						&ds5_ctrl_laser_power,
+						sensor);
+		ctrls->manual_laser_power = v4l2_ctrl_new_custom(hdl,
+						&ds5_ctrl_manual_laser_power,
+						sensor);
+	}
+
+	/* Total gain */
+	if (sid == DEPTH_SID || sid == IR_SID) {
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						16, 248, 1, 16);
+	} else if (sid == RGB_SID) {
+		ctrls->gain = v4l2_ctrl_new_std(hdl, ops,
+						V4L2_CID_ANALOGUE_GAIN,
+						0, 128, 1, 64);
+	}
+
+	if ((ctrls->gain) && (sid >= DEPTH_SID && sid < IMU_SID)) {
+		ctrls->gain->priv = sensor;
+		ctrls->gain->flags =
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+	}
+	if (sid >= DEPTH_SID && sid < IMU_SID) {
+
+		ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+				V4L2_CID_EXPOSURE_AUTO,
+				V4L2_EXPOSURE_APERTURE_PRIORITY,
+				~((1 << V4L2_EXPOSURE_MANUAL) |
+						(1 << V4L2_EXPOSURE_APERTURE_PRIORITY)),
+						V4L2_EXPOSURE_APERTURE_PRIORITY);
+
+		if (ctrls->auto_exp) {
+			ctrls->auto_exp->flags |=
+					V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+			ctrls->auto_exp->priv = sensor;
+		}
+	}
+
+	/* Exposure time: V4L2_CID_EXPOSURE_ABSOLUTE default unit: 100 us. */
+	if (sid == DEPTH_SID || sid == IR_SID) {
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_DEPTH_EXP, 1, DEF_DEPTH_EXP);
+	} else if (sid == RGB_SID) {
+		ctrls->exposure = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_EXPOSURE_ABSOLUTE,
+					1, MAX_RGB_EXP, 1, DEF_RGB_EXP);
+	}
+
+	if ((ctrls->exposure) && (sid >= DEPTH_SID && sid < IMU_SID)) {
+		ctrls->exposure->priv = sensor;
+		ctrls->exposure->flags |=
+				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+		/* override default int type to u32 to match SKU & UVC */
+		ctrls->exposure->type = V4L2_CTRL_TYPE_U32;
+	}
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	ctrls->link_freq = v4l2_ctrl_new_custom(hdl, &d4xx_controls_link_freq, sensor);
+
+	if (ctrls->link_freq)
+		ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	if (state->aggregated) {
+		d4xx_controls_q_sub_stream.def = NR_OF_DS5_SUB_STREAMS;
+		d4xx_controls_q_sub_stream.min = NR_OF_DS5_SUB_STREAMS;
+		d4xx_controls_q_sub_stream.max = NR_OF_DS5_SUB_STREAMS * 2 - 1;
+	}
+	ctrls->query_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_q_sub_stream, sensor);
+
+	if (ctrls->query_sub_stream)
+		ctrls->query_sub_stream->flags |=
+		V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
+
+	ctrls->set_sub_stream = v4l2_ctrl_new_custom(hdl, &d4xx_controls_s_sub_stream, sensor);
+#endif
+	if (hdl->error) {
+		v4l2_err(sd, "error creating controls (%d)\n", hdl->error);
+		ret = hdl->error;
+		v4l2_ctrl_handler_free(hdl);
+		return ret;
+	}
+
+	// Add these after v4l2_ctrl_handler_setup so they won't be set up
+	if (sid >= DEPTH_SID && sid < IMU_SID) {
+		ctrls->log = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_log, sensor);
+		ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, sensor);
+		ctrls->gvd = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_gvd, sensor);
+		ctrls->get_depth_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_depth_calib, sensor);
+		ctrls->set_depth_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_depth_calib, sensor);
+		ctrls->get_coeff_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_coeff_calib, sensor);
+		ctrls->set_coeff_calib =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_coeff_calib, sensor);
+		ctrls->ae_roi_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_get, sensor);
+		ctrls->ae_roi_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_set, sensor);
+		ctrls->ae_setpoint_get =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_get, sensor);
+		ctrls->ae_setpoint_set =
+				v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_set, sensor);
+		ctrls->erb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_erb, sensor);
+		ctrls->ewb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ewb, sensor);
+		ctrls->hwmc = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc, sensor);
+		v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc_rw, sensor);
+	}
+	// DEPTH custom
+	if (sid == DEPTH_SID)
+		v4l2_ctrl_new_custom(hdl, &ds5_ctrl_pwm, sensor);
+	// IMU custom
+	if (sid == IMU_SID)
+		ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, sensor);
+
+	switch (sid) {
+	case DEPTH_SID:
+		state->depth.sensor.sd.ctrl_handler = hdl;
+		dev_dbg(state->depth.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->depth.sensor.mux_pad);
+		break;
+	case RGB_SID:
+		state->rgb.sensor.sd.ctrl_handler = hdl;
+		dev_dbg(state->rgb.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->rgb.sensor.mux_pad);
+		break;
+	case IR_SID:
+		state->ir.sensor.sd.ctrl_handler = hdl;
+		dev_dbg(state->ir.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->ir.sensor.mux_pad);
+		break;
+	case IMU_SID:
+		state->imu.sensor.sd.ctrl_handler = hdl;
+		dev_dbg(state->imu.sensor.sd.dev,
+			"%s():%d set ctrl_handler pad:%d\n",
+			__func__, __LINE__, state->imu.sensor.mux_pad);
+		break;
+	default:
+		state->mux.sd.subdev.ctrl_handler = hdl;
+		dev_dbg(state->mux.sd.subdev.dev,
+			"%s():%d set ctrl_handler for MUX\n", __func__, __LINE__);
+		break;
+	}
+
+	return 0;
+}
+
+static int ds5_sensor_init(struct i2c_client *c, struct ds5 *state,
+		struct ds5_sensor *sensor, const struct v4l2_subdev_ops *ops,
+		const char *name)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	struct media_pad *pad = &sensor->pad;
+	dev_t *dev_num = &state->client->dev.devt;
+#ifndef CONFIG_OF
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+	char suffix = dpdata->suffix;
+#endif
+	v4l2_i2c_subdev_init(sd, c, ops);
+	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &ds5_sensor_internal_ops;
+	sd->grp_id = *dev_num;
+	v4l2_set_subdevdata(sd, state);
+#ifndef CONFIG_OF
+	/*
+	 * TODO: suffix for 2 D457 connected to 1 Deser
+	 */
+	if (state->aggregated & 1)
+		suffix += 4;
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %c", name, suffix);
+#else
+	snprintf(sd->name, sizeof(sd->name), "D4XX %s %d-%04x",
+		 name, i2c_adapter_id(c->adapter), c->addr);
+#endif
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pad->flags = MEDIA_PAD_FL_SOURCE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+	return media_entity_pads_init(entity, 1, pad);
+}
+
+static int ds5_sensor_register(struct ds5 *state, struct ds5_sensor *sensor)
+{
+	struct v4l2_subdev *sd = &sensor->sd;
+	struct media_entity *entity = &sensor->sd.entity;
+	int ret = -1;
+
+	// FIXME: is async needed?
+	ret = v4l2_device_register_subdev(state->mux.sd.subdev.v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = media_create_pad_link(entity, 0,
+			&state->mux.sd.subdev.entity, sensor->mux_pad,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
+		goto e_sd;
+	}
+
+	dev_dbg(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
+
+	return 0;
+
+e_sd:
+	v4l2_device_unregister_subdev(sd);
+
+	return ret;
+}
+
+static void ds5_sensor_remove(struct ds5_sensor *sensor)
+{
+	v4l2_device_unregister_subdev(&sensor->sd);
+
+	media_entity_cleanup(&sensor->sd.entity);
+}
+
+static int ds5_depth_init(struct i2c_client *c, struct ds5 *state)
+{
+	/* Which mux pad we're connecting to */
+	state->depth.sensor.mux_pad = DS5_MUX_PAD_DEPTH;
+	return ds5_sensor_init(c, state, &state->depth.sensor,
+		       &ds5_depth_subdev_ops, "depth");
+}
+
+static int ds5_ir_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->ir.sensor.mux_pad = DS5_MUX_PAD_IR;
+	return ds5_sensor_init(c, state, &state->ir.sensor,
+		       &ds5_ir_subdev_ops, "ir");
+}
+
+static int ds5_rgb_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->rgb.sensor.mux_pad = DS5_MUX_PAD_RGB;
+	return ds5_sensor_init(c, state, &state->rgb.sensor,
+		       &ds5_rgb_subdev_ops, "rgb");
+}
+
+static int ds5_imu_init(struct i2c_client *c, struct ds5 *state)
+{
+	state->imu.sensor.mux_pad = DS5_MUX_PAD_IMU;
+	return ds5_sensor_init(c, state, &state->imu.sensor,
+		       &ds5_imu_subdev_ops, "imu");
+}
+
+/* No locking needed */
+static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+				  struct v4l2_subdev_mbus_code_enum *mce)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_mbus_code_enum tmp = *mce;
+	struct v4l2_subdev *remote_sd;
+	int ret = -1;
+
+	dev_dbg(&state->client->dev, "%s(): %s \n", __func__, sd->name);
+	switch (mce->pad) {
+	case DS5_MUX_PAD_IR:
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		if (mce->index >= state->ir.sensor.n_formats +
+				state->depth.sensor.n_formats)
+			return -EINVAL;
+
+		/*
+		 * First list Left node / Motion Tracker formats, then depth.
+		 * This should also help because D16 doesn't have a direct
+		 * analog in MIPI CSI-2.
+		 */
+		if (mce->index < state->ir.sensor.n_formats) {
+			remote_sd = &state->ir.sensor.sd;
+		} else {
+			tmp.index = mce->index - state->ir.sensor.n_formats;
+			remote_sd = &state->depth.sensor.sd;
+		}
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+	if (state->is_rgb)
+		remote_sd = &state->rgb.sensor.sd;
+	if (state->is_depth)
+		remote_sd = &state->depth.sensor.sd;
+	if (state->is_y8)
+		remote_sd = &state->ir.sensor.sd;
+	if (state->is_imu)
+		remote_sd = &state->imu.sensor.sd;
+	/* Locks internally */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	ret = ds5_sensor_enum_mbus_code(remote_sd, cfg, &tmp);
+#else
+	ret = ds5_sensor_enum_mbus_code(remote_sd, v4l2_state, &tmp);
+#endif
+	if (!ret)
+		mce->code = tmp.code;
+
+	return ret;
+}
+static int ds5_state_to_pad(struct ds5 *state) {
+	int pad = -1;
+	if (state->is_depth)
+		pad = DS5_MUX_PAD_DEPTH;
+	if (state->is_y8)
+		pad = DS5_MUX_PAD_IR;
+	if (state->is_rgb)
+		pad = DS5_MUX_PAD_RGB;
+	if (state->is_imu)
+		pad = DS5_MUX_PAD_IMU;
+	return pad;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_size(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_size_enum tmp = *fse;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fse->pad;
+	int ret = -1;
+
+	tmp.pad = 0;
+	pad = ds5_state_to_pad(state);
+
+	switch (pad) {
+	case DS5_MUX_PAD_IR:
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/*
+		 * Assume, that different sensors don't support the same formats
+		 * Try the Depth sensor first, then the Motion Tracker
+		 */
+		remote_sd = &state->depth.sensor.sd;
+		ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fse = tmp;
+			fse->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_size(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fse = tmp;
+		fse->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+				     struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_frame_interval_enum tmp = *fie;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fie->pad;
+	int ret = -1;
+
+	tmp.pad = 0;
+
+	dev_dbg(state->depth.sensor.sd.dev,
+			"%s(): pad %d code %x width %d height %d\n",
+			__func__, pad, tmp.code, tmp.width, tmp.height);
+
+	pad = ds5_state_to_pad(state);
+
+	switch (pad) {
+	case DS5_MUX_PAD_IR:
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		/* Similar to ds5_mux_enum_frame_size() above */
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->ir.sensor.sd;
+		ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+		if (!ret) {
+			*fie = tmp;
+			fie->pad = pad;
+			return 0;
+		}
+
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Locks internally */
+	ret = ds5_sensor_enum_frame_interval(remote_sd, NULL, &tmp);
+	if (!ret) {
+		*fie = tmp;
+		fie->pad = pad;
+	}
+
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_set_fmt(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+		struct v4l2_subdev_pad_config *cfg,
+#else
+		struct v4l2_subdev_state *v4l2_state,
+#endif
+		struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_format tmp = *fmt;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fmt->pad;
+	int ret = 0;
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	struct v4l2_subdev *remote_sd;
+	struct ds5_sensor *sensor = state->mux.last_set;
+	pad = sensor->mux_pad;
+	int substream = -1;
+#endif
+	pad = ds5_state_to_pad(state);
+
+	dev_dbg(sd->dev, "%s(): pad: %x %x: %ux%u\n",
+			__func__, pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
+
+	switch (pad) {
+	case DS5_MUX_PAD_IR:
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		if (state->is_rgb)
+			remote_sd = &state->rgb.sensor.sd;
+		else
+			remote_sd = &state->mux.last_set->sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tmp.pad = 0;
+
+	/* Locks internally */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	ret = ds5_sensor_set_fmt(remote_sd, cfg, &tmp);
+#else
+	ret = ds5_sensor_set_fmt(remote_sd, v4l2_state, &tmp);
+#endif
+	if (!ret) {
+		*fmt = tmp;
+		fmt->pad = pad;
+	}
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	// substream = pad_to_substream[fmt->pad];
+	substream = state->pad_to_substream[pad];
+
+	if (substream != -1) {
+		set_sub_stream_fmt(substream, ffmt->code);
+		set_sub_stream_h(substream, ffmt->height);
+		set_sub_stream_w(substream, ffmt->width);
+		set_sub_stream_dt(substream, mbus_code_to_mipi(ffmt->code));
+	}
+
+	dev_dbg(sd->dev, "%s(): fmt->pad:%d, sensor->mux_pad: %d, \
+		code: 0x%x: %ux%u substream:%d for sensor: %s\n",
+		__func__,
+		fmt->pad, pad, fmt->format.code,
+		fmt->format.width, fmt->format.height,
+		substream, sensor->sd.name);
+#endif
+	return ret;
+}
+
+/* No locking needed */
+static int ds5_mux_get_fmt(struct v4l2_subdev *sd,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+				     struct v4l2_subdev_pad_config *cfg,
+#else
+				     struct v4l2_subdev_state *v4l2_state,
+#endif
+			   struct v4l2_subdev_format *fmt)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct v4l2_subdev_format tmp = *fmt;
+	struct v4l2_subdev *remote_sd;
+	u32 pad = fmt->pad;
+	int ret = 0;
+	struct ds5_sensor *sensor = state->mux.last_set;
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	pad = sensor->mux_pad;
+	if (pad != DS5_MUX_PAD_EXTERNAL)
+		ds5_s_state_pad(state, pad);
+#else
+	pad = ds5_state_to_pad(state);
+#endif
+	sensor = state->mux.last_set;
+	dev_dbg(sd->dev, "%s(): %u %s %p\n", __func__, pad, ds5_get_sensor_name(state), state->mux.last_set);
+
+	switch (pad) {
+	case DS5_MUX_PAD_IR:
+		remote_sd = &state->ir.sensor.sd;
+		break;
+	case DS5_MUX_PAD_DEPTH:
+		remote_sd = &state->depth.sensor.sd;
+		break;
+	case DS5_MUX_PAD_EXTERNAL:
+		remote_sd = &state->mux.last_set->sd;
+		break;
+	case DS5_MUX_PAD_RGB:
+		remote_sd = &state->rgb.sensor.sd;
+		break;
+	case DS5_MUX_PAD_IMU:
+		remote_sd = &state->imu.sensor.sd;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(sd->dev, "%s(): fmt->pad:%d, sensor->mux_pad:%u size:%d-%d, code:0x%x field:%d, color:%d\n",
+		__func__, fmt->pad, pad,
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.field, fmt->format.colorspace);
+	/* Locks internally */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	ret = ds5_sensor_get_fmt(remote_sd, cfg, &tmp);
+#else
+	ret = ds5_sensor_get_fmt(remote_sd, v4l2_state, &tmp);
+#endif
+	if (!ret) {
+		*fmt = tmp;
+		fmt->pad = pad;
+	}
+
+	return ret;
+}
+
+/* Video ops */
+static int ds5_mux_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = sensor->config.framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target)
+{
+	int i;
+	u16 framerate;
+
+	for (i = 0; i < res->n_framerates; i++) {
+		framerate = res->framerates[i];
+		if (target <= framerate)
+			return framerate;
+	}
+
+	return res->framerates[res->n_framerates - 1];
+}
+
+static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	struct ds5_sensor *sensor = NULL;
+	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	sensor = state->mux.last_set;
+
+	framerate = fi->interval.denominator / fi->interval.numerator;
+	framerate = __ds5_probe_framerate(sensor->config.resolution, framerate);
+	sensor->config.framerate = framerate;
+	fi->interval.numerator = 1;
+	fi->interval.denominator = framerate;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+#ifndef CONFIG_VIDEO_D4XX_SERDES
+int d4xx_reset_oneshot(struct ds5 *state)
+{
+	struct d4xx_pdata *dpdata = state->client->dev.platform_data;
+	struct i2c_board_info *deser = dpdata->deser_board_info;
+
+	int s_addr = state->client->addr;
+	int n_addr = deser->addr;
+	int ret = 0;
+
+	if (n_addr) {
+		state->client->addr = n_addr;
+		dev_warn(&state->client->dev, "One-shot reset 0x%x enable auto-link\n", n_addr);
+		/* One-shot reset  enable auto-link */
+		ret = max9296_write_8(state, MAX9296_CTRL0, RESET_ONESHOT | AUTO_LINK | LINK_A);
+		state->client->addr = s_addr;
+		/* delay to settle link */
+		msleep(100);
+	}
+
+	return ret;
+}
+#endif
+static int ds5_state_to_vc(struct ds5 *state) {
+	int pad = 0;
+	if (state->is_depth) {
+		pad = DS5_MUX_PAD_DEPTH;
+	}
+	if (state->is_rgb) {
+		pad = DS5_MUX_PAD_RGB;
+	}
+	if (state->is_y8) {
+		pad = DS5_MUX_PAD_IR;
+	}
+	if (state->is_imu) {
+		pad = DS5_MUX_PAD_IMU;
+	}
+
+	return state->pad_to_vc[pad];
+}
+#endif
+static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
+	u16 streaming, status;
+	int ret = 0;
+	unsigned int i = 0;
+	int restore_val = 0;
+	u16 config_status_base, stream_status_base, stream_id, vc_id;
+	struct ds5_sensor *sensor = state->mux.last_set;
+
+	// spare duplicate calls
+	if (sensor->streaming == on)
+		return 0;
+	if (state->is_depth) {
+		config_status_base = DS5_DEPTH_CONFIG_STATUS;
+		stream_status_base = DS5_DEPTH_STREAM_STATUS;
+		stream_id = DS5_STREAM_DEPTH;
+		vc_id = state->g_ctx.dst_vc;
+	} else if (state->is_rgb) {
+		config_status_base = DS5_RGB_CONFIG_STATUS;
+		stream_status_base = DS5_RGB_STREAM_STATUS;
+		stream_id = DS5_STREAM_RGB;
+		vc_id = state->g_ctx.dst_vc;
+	} else if (state->is_y8) {
+		config_status_base = DS5_IR_CONFIG_STATUS;
+		stream_status_base = DS5_IR_STREAM_STATUS;
+		stream_id = DS5_STREAM_IR;
+		vc_id = state->g_ctx.dst_vc;
+	} else if (state->is_imu) {
+		config_status_base = DS5_IMU_CONFIG_STATUS;
+		stream_status_base = DS5_IMU_STREAM_STATUS;
+		stream_id = DS5_STREAM_IMU;
+		vc_id = state->g_ctx.dst_vc;
+	} else {
+		return -EINVAL;
+	}
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	vc_id = ds5_state_to_vc(state);
+#endif
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	vc_id = state->g_ctx.dst_vc;
+#endif
+#endif
+	dev_dbg(&state->client->dev, "s_stream for stream %s, vc:%d, SENSOR=%s on = %d\n",
+			sensor->sd.name, vc_id, ds5_get_sensor_name(state), on);
+
+	restore_val = sensor->streaming;
+	sensor->streaming = on;
+
+	mutex_lock(&state->lock);
+
+	if (on) {
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+		// set manually, need to configure vc in pdata
+		state->g_ctx.dst_vc = vc_id;
+#endif
+		sensor->pipe_id =
+			max9296_get_available_pipe_id(state->dser_dev,
+					(int)state->g_ctx.dst_vc);
+		if (sensor->pipe_id < 0) {
+			dev_err(&state->client->dev,
+				"No free pipe in max9296\n");
+			ret = -(ENOSR);
+			goto restore_s_state;
+		}
+#endif
+
+		ret = ds5_configure(state);
+		if (ret)
+			goto restore_s_state;
+
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_START | stream_id);
+		if (ret < 0)
+			goto restore_s_state;
+		msleep_range(100);
+		// check streaming status from FW
+		for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+			ds5_read(state, stream_status_base, &streaming);
+			ds5_read(state, config_status_base, &status);
+			if ((status & DS5_STATUS_STREAMING) &&
+					streaming == DS5_STREAM_STREAMING)
+				break;
+
+			msleep_range(DS5_START_POLL_TIME);
+		}
+
+		if (DS5_START_MAX_COUNT == i) {
+			dev_err(&state->client->dev,
+				"start streaming failed, exit on timeout\n");
+			/* notify fw */
+			ret = ds5_write(state, DS5_START_STOP_STREAM,
+					DS5_STREAM_STOP | stream_id);
+			ret = -EAGAIN;
+			goto restore_s_state;
+		} else {
+			dev_dbg(&state->client->dev, "started after %dms\n",
+				i * DS5_START_POLL_TIME);
+		}
+	} else { // off
+		ret = ds5_write(state, DS5_START_STOP_STREAM,
+				DS5_STREAM_STOP | stream_id);
+		if (ret < 0)
+			goto restore_s_state;
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+		// reset data path when Y12I streaming is done
+		if (state->is_y8 &&
+			state->ir.sensor.config.format->data_type ==
+			GMSL_CSI_DT_RGB_888) {
+			max9296_reset_oneshot(state->dser_dev);
+		}
+#ifndef CONFIG_TEGRA_CAMERA_PLATFORM
+		// reset for IPU6
+		streaming = 0;
+		for (i = 0; i < ARRAY_SIZE(d4xx_set_sub_stream); i++) {
+			if (d4xx_set_sub_stream[i]) {
+				streaming = 1;
+				break;
+			}
+		}
+		if (!streaming) {
+			dev_warn(&state->client->dev, "max9296_reset_oneshot\n");
+				max9296_reset_oneshot(state->dser_dev);
+		}
+#endif
+		if (max9296_release_pipe(state->dser_dev, sensor->pipe_id) < 0)
+			dev_warn(&state->client->dev, "release pipe failed\n");
+		sensor->pipe_id = -1;
+#else
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+		d4xx_reset_oneshot(state);
+#endif
+#endif
+	}
+
+	ds5_read(state, config_status_base, &status);
+	ds5_read(state, stream_status_base, &streaming);
+	dev_dbg(&state->client->dev,
+			"%s %s, stream_status 0x%x:%x, config_status 0x%x:%x ret=%d\n",
+			ds5_get_sensor_name(state),
+			(on)?"START":"STOP",
+			stream_status_base, streaming,
+			config_status_base, status, ret);
+	mutex_unlock(&state->lock);
+	return ret;
+
+restore_s_state:
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	if (on && sensor->pipe_id >= 0) {
+		if (max9296_release_pipe(state->dser_dev, sensor->pipe_id) < 0)
+			dev_warn(&state->client->dev, "release pipe failed\n");
+		sensor->pipe_id = -1;
+	}
+#endif
+
+	ds5_read(state, config_status_base, &status);
+	dev_err(&state->client->dev,
+			"%s stream toggle failed! %x status 0x%04x\n",
+			ds5_get_sensor_name(state), restore_val, status);
+
+	sensor->streaming = restore_val;
+	mutex_unlock(&state->lock);
+	return ret;
+}
+
+static int ds5_mux_get_frame_desc(struct v4l2_subdev *sd,
+	unsigned int pad, struct v4l2_mbus_frame_desc *desc)
+{
+	unsigned int i;
+
+	desc->num_entries = V4L2_FRAME_DESC_ENTRY_MAX;
+
+	for (i = 0; i < desc->num_entries; i++) {
+		desc->entry[i].flags = 0;
+		desc->entry[i].pixelcode = MEDIA_BUS_FMT_FIXED;
+		desc->entry[i].length = 0;
+		if (i == desc->num_entries - 1) {
+			desc->entry[i].pixelcode = 0x12;
+			desc->entry[i].length = 68;
+		}
+	}
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ds5_mux_pad_ops = {
+	.enum_mbus_code		= ds5_mux_enum_mbus_code,
+	.enum_frame_size	= ds5_mux_enum_frame_size,
+	.enum_frame_interval	= ds5_mux_enum_frame_interval,
+	.get_fmt		= ds5_mux_get_fmt,
+	.set_fmt		= ds5_mux_set_fmt,
+	.get_frame_desc		= ds5_mux_get_frame_desc,
+};
+
+static const struct v4l2_subdev_core_ops ds5_mux_core_ops = {
+	//.s_power = ds5_mux_set_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+};
+
+static const struct v4l2_subdev_video_ops ds5_mux_video_ops = {
+	.g_frame_interval	= ds5_mux_g_frame_interval,
+	.s_frame_interval	= ds5_mux_s_frame_interval,
+	.s_stream		= ds5_mux_s_stream,
+};
+
+static const struct v4l2_subdev_ops ds5_mux_subdev_ops = {
+	.core = &ds5_mux_core_ops,
+	.pad = &ds5_mux_pad_ops,
+	.video = &ds5_mux_video_ops,
+};
+
+static int ds5_mux_registered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	int ret = ds5_sensor_register(state, &state->depth.sensor);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_sensor_register(state, &state->ir.sensor);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_sensor_register(state, &state->rgb.sensor);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_sensor_register(state, &state->imu.sensor);
+	if (ret < 0)
+		goto e_imu;
+
+	return 0;
+
+e_imu:
+	v4l2_device_unregister_subdev(&state->rgb.sensor.sd);
+
+e_rgb:
+	v4l2_device_unregister_subdev(&state->ir.sensor.sd);
+
+e_depth:
+	v4l2_device_unregister_subdev(&state->depth.sensor.sd);
+
+	return ret;
+}
+
+static void ds5_mux_unregistered(struct v4l2_subdev *sd)
+{
+	struct ds5 *state = v4l2_get_subdevdata(sd);
+	ds5_sensor_remove(&state->imu.sensor);
+	ds5_sensor_remove(&state->rgb.sensor);
+	ds5_sensor_remove(&state->ir.sensor);
+	ds5_sensor_remove(&state->depth.sensor);
+}
+
+static const struct v4l2_subdev_internal_ops ds5_mux_internal_ops = {
+	.open = ds5_mux_open,
+	.close = ds5_mux_close,
+	.registered = ds5_mux_registered,
+	.unregistered = ds5_mux_unregistered,
+};
+
+static int ds5_mux_register(struct i2c_client *c, struct ds5 *state)
+{
+	return v4l2_async_register_subdev(&state->mux.sd.subdev);
+}
+
+static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	u16 mipi_status, n_lanes, phy, drate_min, drate_max;
+	int ret = ds5_read(state, DS5_MIPI_SUPPORT_LINES, &n_lanes);
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_SUPPORT_PHY, &phy);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MIN, &drate_min);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_DATARATE_MAX, &drate_max);
+
+	if (!ret)
+		dev_dbg(sd->dev, "%s(): %d: %u lanes, phy %x, data rate %u-%u\n",
+			 __func__, __LINE__, n_lanes, phy, drate_min, drate_max);
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	n_lanes = state->mux.sd.numlanes;
+#else
+	n_lanes = 2;
+#endif
+
+	ret = ds5_write(state, DS5_MIPI_LANE_NUMS, n_lanes - 1);
+	if (!ret)
+		ret = ds5_write(state, DS5_MIPI_LANE_DATARATE, MIPI_LANE_RATE);
+
+	if (!ret)
+		ret = ds5_read(state, DS5_MIPI_CONF_STATUS, &mipi_status);
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	dev_dbg(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
+		 c->dev.of_node->phandle, c->dev.of_node->full_name, mipi_status);
+#endif
+
+	return ret;
+}
+
+static int ds5_mux_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct v4l2_subdev *sd = &state->mux.sd.subdev;
+	struct media_entity *entity = &state->mux.sd.subdev.entity;
+	struct media_pad *pads = state->mux.pads, *pad;
+	unsigned int i;
+	int ret;
+#ifndef CONFIG_OF
+	struct d4xx_pdata *dpdata = c->dev.platform_data;
+	char suffix = dpdata->suffix;
+#endif
+	v4l2_i2c_subdev_init(sd, c, &ds5_mux_subdev_ops);
+	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
+	// Set owner to NULL so we can unload the driver module
+	sd->owner = NULL;
+	sd->internal_ops = &ds5_mux_internal_ops;
+	v4l2_set_subdevdata(sd, state);
+#ifdef CONFIG_OF
+	snprintf(sd->name, sizeof(sd->name), "DS5 mux %d-%04x",
+		 i2c_adapter_id(c->adapter), c->addr);
+#else
+	if (state->aggregated)
+		suffix += 4;
+	snprintf(sd->name, sizeof(sd->name), "DS5 mux %c", suffix);
+#endif
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	entity->obj_type = MEDIA_ENTITY_TYPE_V4L2_SUBDEV;
+	entity->function = MEDIA_ENT_F_CAM_SENSOR;
+
+	pads[0].flags = MEDIA_PAD_FL_SOURCE;
+	for (i = 1, pad = pads + 1; i < ARRAY_SIZE(state->mux.pads); i++, pad++)
+		pad->flags = MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(entity, ARRAY_SIZE(state->mux.pads), pads);
+	if (ret < 0)
+		return ret;
+
+	/*set for mux*/
+	ret = ds5_ctrl_init(state, MUX_SID);
+	if (ret < 0)
+		goto e_entity;
+
+	/*set for depth*/
+	ret = ds5_ctrl_init(state, DEPTH_SID);
+	if (ret < 0)
+		return ret;
+	/*set for rgb*/
+	ret = ds5_ctrl_init(state, RGB_SID);
+	if (ret < 0)
+		return ret;
+	/*set for y8*/
+	ret = ds5_ctrl_init(state, IR_SID);
+	if (ret < 0)
+		return ret;
+	/*set for imu*/
+	ret = ds5_ctrl_init(state, IMU_SID);
+	if (ret < 0)
+		return ret;
+
+	ds5_set_state_last_set(state);
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	if (state->is_depth) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		v4l2_ctrl_add_handler(&state->ctrls.handler,
+					&state->ctrls.handler_depth, NULL);
+#else
+		v4l2_ctrl_add_handler(&state->ctrls.handler,
+					&state->ctrls.handler_depth, NULL, true);
+#endif
+		state->mux.last_set = &state->depth.sensor;
+	}
+	else if (state->is_rgb) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		v4l2_ctrl_add_handler(&state->ctrls.handler,
+					&state->ctrls.handler_rgb, NULL);
+#else
+		v4l2_ctrl_add_handler(&state->ctrls.handler,
+					&state->ctrls.handler_rgb, NULL, true);
+#endif
+		state->mux.last_set = &state->rgb.sensor;
+	}
+	else if (state->is_y8) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		v4l2_ctrl_add_handler(&state->ctrls.handler,
+					&state->ctrls.handler_y8, NULL);
+#else
+		v4l2_ctrl_add_handler(&state->ctrls.handler,
+					&state->ctrls.handler_y8, NULL, true);
+#endif
+		state->mux.last_set = &state->ir.sensor;
+	}
+	else
+		state->mux.last_set = &state->imu.sensor;
+
+	state->mux.sd.dev = &c->dev;
+	ret = camera_common_initialize(&state->mux.sd, "d4xx");
+	if (ret) {
+		dev_err(&c->dev, "Failed to initialize d4xx.\n");
+		goto e_ctrl;
+	}
+#endif
+
+	return 0;
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+e_ctrl:
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+#endif
+e_entity:
+	media_entity_cleanup(entity);
+
+	return ret;
+}
+
+#define USE_Y
+
+static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
+{
+	struct ds5_sensor *sensor;
+	u16 cfg0 = 0, cfg0_md = 0, cfg1 = 0, cfg1_md = 0;
+	u16 dw = 0, dh = 0, yw = 0, yh = 0, dev_type = 0;
+	int ret;
+
+	ret = ds5_read(state, DS5_DEPTH_STREAM_DT, &cfg0);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_STREAM_MD, &cfg0_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_WIDTH, &dw);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEPTH_RES_HEIGHT, &dh);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_DT, &cfg1);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_STREAM_MD, &cfg1_md);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_WIDTH, &yw);
+	if (!ret)
+		ret = ds5_read(state, DS5_IR_RES_HEIGHT, &yh);
+	if (!ret)
+		ret = ds5_read(state, DS5_DEVICE_TYPE, &dev_type);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "%s(): cfg0 %x %ux%u cfg0_md %x %ux%u\n", __func__,
+		 cfg0, dw, dh, cfg0_md, yw, yh);
+
+	dev_dbg(&client->dev, "%s(): cfg1 %x %ux%u cfg1_md %x %ux%u\n", __func__,
+		 cfg1, dw, dh, cfg1_md, yw, yh);
+
+	sensor = &state->depth.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = ds5_depth_formats_d43x;
+		break;
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = ds5_depth_formats_d46x;
+		break;
+	default:
+		sensor->formats = ds5_depth_formats_d46x;
+	}
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_DEPTH;
+
+	sensor = &state->ir.sensor;
+	sensor->formats = state->variant->formats;
+	sensor->n_formats = state->variant->n_formats;
+	sensor->mux_pad = DS5_MUX_PAD_IR;
+
+	sensor = &state->rgb.sensor;
+	switch (dev_type) {
+	case DS5_DEVICE_TYPE_D43X:
+	case DS5_DEVICE_TYPE_D46X:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+		break;
+	case DS5_DEVICE_TYPE_D45X:
+		sensor->formats = &ds5_rlt_rgb_format;
+		sensor->n_formats = DS5_RLT_RGB_N_FORMATS;
+		break;
+	default:
+		sensor->formats = &ds5_onsemi_rgb_format;
+		sensor->n_formats = DS5_ONSEMI_RGB_N_FORMATS;
+	}
+	sensor->mux_pad = DS5_MUX_PAD_RGB;
+
+	sensor = &state->imu.sensor;
+
+	/* For fimware version starting from: 5.16,
+	   IMU will have 32bit axis values.
+ 	   5.16.x.y = firmware version: 0x0510 */
+	if (state->fw_version >= 0x510)
+		sensor->formats = ds5_imu_formats_extended;
+	else
+		sensor->formats = ds5_imu_formats;
+	
+	sensor->n_formats = 1;
+	sensor->mux_pad = DS5_MUX_PAD_IMU;
+
+	/* Development: set a configuration during probing */
+	if ((cfg0 & 0xff00) == 0x1800) {
+		/* MIPI CSI-2 YUV420 isn't supported by V4L, reconfigure to Y8 */
+		struct v4l2_subdev_format fmt = {
+			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+			.pad = 0,
+			/* Use template to fill in .field, .colorspace etc. */
+			.format = ds5_mbus_framefmt_template,
+		};
+
+//#undef USE_Y
+#ifdef USE_Y
+		/* Override .width, .height, .code */
+		fmt.format.width = yw;
+		fmt.format.height = yh;
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_2X8;
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+		state->mux.sd.mode_prop_idx = 0;
+#endif
+		state->ir.sensor.streaming = true;
+		state->depth.sensor.streaming = true;
+		ret = __ds5_sensor_set_fmt(state, &state->ir.sensor, NULL, &fmt);
+#else
+		fmt.format.width = dw;
+		fmt.format.height = dh;
+		fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+		state->mux.sd.mode_prop_idx = 1;
+#endif
+		state->ir.sensor.streaming = false;
+		state->depth.sensor.streaming = true;
+		ret = __ds5_sensor_set_fmt(state, &state->depth.sensor, NULL, &fmt);
+#endif
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ds5_parse_cam(struct i2c_client *client, struct ds5 *state)
+{
+	int ret;
+
+	ret = ds5_fixed_configuration(client, state);
+	if (ret < 0)
+		return ret;
+
+	ds5_sensor_format_init(&state->depth.sensor);
+	ds5_sensor_format_init(&state->ir.sensor);
+	ds5_sensor_format_init(&state->rgb.sensor);
+	ds5_sensor_format_init(&state->imu.sensor);
+
+	return 0;
+}
+
+static void ds5_mux_remove(struct ds5 *state)
+{
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+	camera_common_cleanup(&state->mux.sd);
+#endif
+	v4l2_async_unregister_subdev(&state->mux.sd.subdev);
+	v4l2_ctrl_handler_free(state->mux.sd.subdev.ctrl_handler);
+	media_entity_cleanup(&state->mux.sd.subdev.entity);
+}
+
+static const struct regmap_config ds5_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+	.reg_format_endian = REGMAP_ENDIAN_NATIVE,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static int ds5_dfu_wait_for_status(struct ds5 *state)
+{
+	int i, ret = 0;
+	u16 status;
+
+	for (i = 0; i < DS5_START_MAX_COUNT; i++) {
+		ds5_read(state, 0x5000, &status);
+		if (status == 0x0001 || status == 0x0002) {
+			dev_err(&state->client->dev,
+					"%s(): dfu failed status(0x%4x)\n",
+					__func__, status);
+			ret = -EREMOTEIO;
+			break;
+		}
+		if (!status)
+			break;
+		msleep_range(DS5_START_POLL_TIME);
+	}
+
+	return ret;
+};
+
+static int ds5_dfu_switch_to_dfu(struct ds5 *state)
+{
+	int ret;
+	int i = DS5_START_MAX_COUNT;
+	u16 status;
+
+	ds5_raw_write_with_check(state, 0x4900,
+			&cmd_switch_to_dfu, sizeof(cmd_switch_to_dfu));
+	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
+	/*Wait for DFU fw to boot*/
+	do {
+		msleep_range(DS5_START_POLL_TIME*10);
+		ret = ds5_read(state, 0x5000, &status);
+	} while (ret && i--);
+	return ret;
+};
+
+static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state,
+		enum dfu_fw_state exp_state)
+{
+	int ret = 0;
+	u16 status, dfu_state_len = 0x0000;
+	unsigned char dfu_asw_buf[DFU_WAIT_RET_LEN];
+	unsigned int dfu_wr_wait_msec = 0;
+
+	do {
+		ds5_write_with_check(state, 0x5008, 0x0003); // Get Write state
+		do {
+			ds5_read_with_check(state, 0x5000, &status);
+			if (status == 0x0001) {
+				dev_err(&state->client->dev,
+						"%s(): Write status error I2C_STATUS_ERROR(1)\n",
+						__func__);
+				return -EINVAL;
+			} else
+				if (status == 0x0002 && dfu_wr_wait_msec)
+					msleep_range(dfu_wr_wait_msec);
+
+		} while (status);
+
+		ds5_read_with_check(state, 0x5004, &dfu_state_len);
+		if (dfu_state_len != DFU_WAIT_RET_LEN) {
+			dev_err(&state->client->dev,
+					"%s(): Wrong answer len (%d)\n", __func__, dfu_state_len);
+			return -EINVAL;
+		}
+		ds5_raw_read_with_check(state, 0x4e00, &dfu_asw_buf, DFU_WAIT_RET_LEN);
+		if (dfu_asw_buf[0]) {
+			dev_err(&state->client->dev,
+					"%s(): Wrong dfu_status (%d)\n", __func__, dfu_asw_buf[0]);
+			return -EINVAL;
+		}
+		dfu_wr_wait_msec = (((unsigned int)dfu_asw_buf[3]) << 16)
+						| (((unsigned int)dfu_asw_buf[2]) << 8)
+						| dfu_asw_buf[1];
+	} while (dfu_asw_buf[4] == dfuDNBUSY && exp_state == dfuDNLOAD_IDLE);
+
+	if (dfu_asw_buf[4] != exp_state) {
+		dev_notice(&state->client->dev,
+				"%s(): Wrong dfu_state (%d) while expected(%d)\n",
+				__func__, dfu_asw_buf[4], exp_state);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_get_dev_info(struct ds5 *state, struct __fw_status *buf)
+{
+	int ret = 0;
+	u16 len = 0;
+
+	ret = ds5_write(state, 0x5008, 0x0002); //Upload DFU cmd
+	if (!ret)
+		ret = ds5_dfu_wait_for_status(state);
+	if (!ret)
+		ds5_read_with_check(state, 0x5004, &len);
+	/*Sanity check*/
+	if (len == sizeof(struct __fw_status)) {
+		ds5_raw_read_with_check(state, 0x4e00, buf, len);
+	} else {
+		dev_err(&state->client->dev,
+				"%s(): Wrong state size (%d)\n",
+				__func__, len);
+		ret = -EINVAL;
+	}
+	return ret;
+};
+
+static int ds5_dfu_detach(struct ds5 *state)
+{
+	int ret;
+	struct __fw_status buf = {0};
+
+	ds5_write_with_check(state, 0x500c, 0x00);
+	ret = ds5_dfu_wait_for_get_dfu_status(state, dfuIDLE);
+	if (!ret)
+		ret = ds5_dfu_get_dev_info(state, &buf);
+	dev_notice(&state->client->dev, "%s():DFU ver (0x%x) received\n",
+			__func__, buf.DFU_version);
+	dev_notice(&state->client->dev, "%s():FW last version (0x%x) received\n",
+			__func__, buf.FW_lastVersion);
+	dev_notice(&state->client->dev, "%s():FW status (%s)\n",
+			__func__, buf.DFU_isLocked ? "locked" : "unlocked");
+	return ret;
+};
+
+/* When a process reads from our device, this gets called. */
+static ssize_t ds5_dfu_device_read(struct file *flip,
+		char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	u16 fw_ver, fw_build;
+	char msg[32];
+	int ret = 0;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	ret |= ds5_read(state, DS5_FW_VERSION, &fw_ver);
+	ret |= ds5_read(state, DS5_FW_BUILD, &fw_build);
+	if (ret < 0)
+		goto e_dfu_read_failed;
+	snprintf(msg, sizeof(msg) ,"DFU info: \tver:  %d.%d.%d.%d\n",
+			(fw_ver >> 8) & 0xff, fw_ver & 0xff,
+			(fw_build >> 8) & 0xff, fw_build & 0xff);
+
+	if (copy_to_user(buffer, msg, strlen(msg)))
+		ret = -EFAULT;
+	else {
+		state->dfu_dev.msg_write_once = ~state->dfu_dev.msg_write_once;
+		ret = strlen(msg) & state->dfu_dev.msg_write_once;
+	}
+
+e_dfu_read_failed:
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static ssize_t ds5_dfu_device_write(struct file *flip,
+		const char __user *buffer, size_t len, loff_t *offset)
+{
+	struct ds5 *state = flip->private_data;
+	int ret = 0;
+	(void)offset;
+
+	if (mutex_lock_interruptible(&state->lock))
+		return -ERESTARTSYS;
+	switch (state->dfu_dev.dfu_state_flag) {
+
+	case DS5_DFU_OPEN:
+		ret = ds5_dfu_switch_to_dfu(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n",
+					__func__, ret);
+			goto dfu_write_error;
+		}
+	/* fallthrough - procceed to recovery */
+	__attribute__((__fallthrough__));
+	case DS5_DFU_RECOVERY:
+		ret = ds5_dfu_detach(state);
+		if (ret < 0) {
+			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n",
+					__func__, ret);
+			goto dfu_write_error;
+		}
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IN_PROGRESS;
+		state->dfu_dev.init_v4l_f = 1;
+	/* fallthrough - procceed to download */
+	__attribute__((__fallthrough__));
+	case DS5_DFU_IN_PROGRESS: {
+		unsigned int dfu_full_blocks = len / DFU_BLOCK_SIZE;
+		unsigned int dfu_part_blocks = len % DFU_BLOCK_SIZE;
+
+		while (dfu_full_blocks--) {
+			if (copy_from_user(state->dfu_dev.dfu_msg, buffer, DFU_BLOCK_SIZE)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+			}
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, DFU_BLOCK_SIZE);
+			if (ret < 0)
+				goto dfu_write_error;
+			ret = ds5_dfu_wait_for_get_dfu_status(state, dfuDNLOAD_IDLE);
+			if (ret < 0)
+				goto dfu_write_error;
+			buffer += DFU_BLOCK_SIZE;
+		}
+		if (copy_from_user(state->dfu_dev.dfu_msg, buffer, dfu_part_blocks)) {
+				ret = -EFAULT;
+				goto dfu_write_error;
+		}
+		if (dfu_part_blocks) {
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, dfu_part_blocks);
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status(state, dfuDNLOAD_IDLE);
+			if (!ret)
+				ret = ds5_write(state, 0x4a04, 0x00); /*Download complete */
+			if (!ret)
+				ret = ds5_dfu_wait_for_get_dfu_status(state, dfuMANIFEST);
+			if (ret < 0)
+				goto dfu_write_error;
+			state->dfu_dev.dfu_state_flag = DS5_DFU_DONE;
+		}
+		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n",
+				__func__, (int)len);
+		break;
+	}
+	default:
+		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n",
+				__func__, state->dfu_dev.dfu_state_flag);
+		ret = -EINVAL;
+		goto dfu_write_error;
+
+	};
+	mutex_unlock(&state->lock);
+	return len;
+
+dfu_write_error:
+	state->dfu_dev.dfu_state_flag = DS5_DFU_ERROR;
+	// Reset DFU device to IDLE states
+	if (!ds5_write(state, 0x5010, 0x0))
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	mutex_unlock(&state->lock);
+	return ret;
+};
+
+static int ds5_dfu_device_open(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5,
+			dfu_dev.ds5_cdev);
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(
+			state->client->adapter);
+#endif
+#endif
+	if (state->dfu_dev.device_open_count)
+		return -EBUSY;
+	state->dfu_dev.device_open_count++;
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_OPEN;
+	state->dfu_dev.dfu_msg = devm_kzalloc(&state->client->dev,
+			DFU_BLOCK_SIZE, GFP_KERNEL);
+	if (!state->dfu_dev.dfu_msg)
+		return -ENOMEM;
+
+	file->private_data = state;
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	/* get i2c controller and set dfu bus clock rate */
+	while (parent && i2c_parent_is_i2c_adapter(parent))
+		parent = i2c_parent_is_i2c_adapter(state->client->adapter);
+
+	if (!parent)
+		return 0;
+
+	dev_dbg(&state->client->dev, "%s(): i2c-%d bus_clk = %d, set %d\n",
+			__func__,
+			i2c_adapter_id(parent),
+			i2c_get_adapter_bus_clk_rate(parent),
+			DFU_I2C_BUS_CLK_RATE);
+
+	state->dfu_dev.bus_clk_rate = i2c_get_adapter_bus_clk_rate(parent);
+	i2c_set_adapter_bus_clk_rate(parent, DFU_I2C_BUS_CLK_RATE);
+#endif
+#endif
+	return 0;
+};
+
+static int ds5_v4l_init(struct i2c_client *c, struct ds5 *state)
+{
+	int ret;
+
+	ret = ds5_parse_cam(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_depth_init(c, state);
+	if (ret < 0)
+		return ret;
+
+	ret = ds5_ir_init(c, state);
+	if (ret < 0)
+		goto e_depth;
+
+	ret = ds5_rgb_init(c, state);
+	if (ret < 0)
+		goto e_ir;
+
+	ret = ds5_imu_init(c, state);
+	if (ret < 0)
+		goto e_rgb;
+
+	ret = ds5_mux_init(c, state);
+	if (ret < 0)
+		goto e_imu;
+
+	ret = ds5_hw_init(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	ret = ds5_mux_register(c, state);
+	if (ret < 0)
+		goto e_mux;
+
+	return 0;
+e_mux:
+	ds5_mux_remove(state);
+e_imu:
+	media_entity_cleanup(&state->imu.sensor.sd.entity);
+e_rgb:
+	media_entity_cleanup(&state->rgb.sensor.sd.entity);
+e_ir:
+	media_entity_cleanup(&state->ir.sensor.sd.entity);
+e_depth:
+	media_entity_cleanup(&state->depth.sensor.sd.entity);
+	return ret;
+}
+
+static int ds5_dfu_device_release(struct inode *inode, struct file *file)
+{
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5, dfu_dev.ds5_cdev);
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(
+			state->client->adapter);
+#endif
+#endif
+	int ret = 0, retry = 10;
+	state->dfu_dev.device_open_count--;
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
+		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_DONE
+			&& state->dfu_dev.init_v4l_f)
+		ds5_v4l_init(state->client, state);
+	state->dfu_dev.init_v4l_f = 0;
+	if (state->dfu_dev.dfu_msg)
+		devm_kfree(&state->client->dev, state->dfu_dev.dfu_msg);
+	state->dfu_dev.dfu_msg = NULL;
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 15, 10)
+	/* get i2c controller and restore bus clock rate */
+	while (parent && i2c_parent_is_i2c_adapter(parent))
+		parent = i2c_parent_is_i2c_adapter(state->client->adapter);
+	if (!parent)
+		return 0;
+	dev_dbg(&state->client->dev, "%s(): i2c-%d bus_clk %d, restore to %d\n",
+			__func__, i2c_adapter_id(parent),
+			i2c_get_adapter_bus_clk_rate(parent),
+			state->dfu_dev.bus_clk_rate);
+
+	i2c_set_adapter_bus_clk_rate(parent, state->dfu_dev.bus_clk_rate);
+#endif
+#endif
+	/* Verify communication */
+	do {
+		ret = ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+		if (ret)
+			msleep_range(10);
+	} while (retry-- && ret != 0 );
+	if (ret) {
+		dev_warn(&state->client->dev,
+			"%s(): no communication with d4xx\n", __func__);
+		return ret;
+	}
+	ret = ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+	return ret;
+};
+
+static const struct file_operations ds5_device_file_ops = {
+	.owner = THIS_MODULE,
+	.read = &ds5_dfu_device_read,
+	.write = &ds5_dfu_device_write,
+	.open = &ds5_dfu_device_open,
+	.release = &ds5_dfu_device_release
+};
+
+struct class *g_ds5_class;
+atomic_t primary_chardev = ATOMIC_INIT(0);
+
+static int ds5_chrdev_init(struct i2c_client *c, struct ds5 *state)
+{
+	struct cdev *ds5_cdev = &state->dfu_dev.ds5_cdev;
+	struct class **ds5_class = &state->dfu_dev.ds5_class;
+#ifndef CONFIG_OF
+	struct d4xx_pdata *pdata = c->dev.platform_data;
+	char suffix = pdata->suffix;
+#endif
+	struct device *chr_dev;
+	char dev_name[sizeof(DS5_DRIVER_NAME_DFU) + 8];
+	dev_t *dev_num = &c->dev.devt;
+	int ret;
+
+	dev_dbg(&c->dev, "%s()\n", __func__);
+	/* Request the kernel for N_MINOR devices */
+	ret = alloc_chrdev_region(dev_num, 0, 1, DS5_DRIVER_NAME_DFU);
+	if (ret < 0)
+		return ret;
+
+	if (!atomic_cmpxchg(&primary_chardev, 0, MAJOR(*dev_num))) {
+		dev_dbg(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n",
+				__func__, MAJOR(*dev_num), MINOR(*dev_num));
+		/* Create a class : appears at /sys/class */
+		*ds5_class = class_create(THIS_MODULE, DS5_DRIVER_NAME_CLASS);
+		dev_warn(&state->client->dev, "%s() class_create\n", __func__);
+		if (IS_ERR(*ds5_class)) {
+			dev_err(&c->dev, "Could not create class device\n");
+			unregister_chrdev_region(0, 1);
+			ret = PTR_ERR(*ds5_class);
+			return ret;
+		}
+		g_ds5_class = *ds5_class;
+	} else
+		*ds5_class = g_ds5_class;
+	/* Associate the cdev with a set of file_operations */
+	cdev_init(ds5_cdev, &ds5_device_file_ops);
+	/* Build up the current device number. To be used further */
+	*dev_num = MKDEV(MAJOR(*dev_num), MINOR(*dev_num));
+	/* Create a device node for this device. */
+#ifndef CONFIG_OF
+	if (state->aggregated)
+		suffix += 4;
+	snprintf(dev_name, sizeof(dev_name), "%s-%c",
+		DS5_DRIVER_NAME_DFU, suffix);
+#else
+	snprintf (dev_name, sizeof(dev_name), "%s-%d-%04x",
+			DS5_DRIVER_NAME_DFU, i2c_adapter_id(c->adapter), c->addr);
+#endif
+	chr_dev = device_create(*ds5_class, NULL, *dev_num, NULL, dev_name);
+	if (IS_ERR(chr_dev)) {
+		ret = PTR_ERR(chr_dev);
+		dev_err(&c->dev, "Could not create device\n");
+		class_destroy(*ds5_class);
+		unregister_chrdev_region(0, 1);
+		return ret;
+	}
+	cdev_add(ds5_cdev, *dev_num, 1);
+	
+	return 0;
+};
+
+static int ds5_chrdev_remove(struct ds5 *state)
+{
+	struct class **ds5_class = &state->dfu_dev.ds5_class;
+	dev_t *dev_num = &state->client->dev.devt;
+	if (!ds5_class) {
+		return 0;
+	}
+	dev_dbg(&state->client->dev, "%s()\n", __func__);
+	unregister_chrdev_region(*dev_num, 1);
+	device_destroy(*ds5_class, *dev_num);
+	if (atomic_cmpxchg(&primary_chardev, MAJOR(*dev_num), 0) == MAJOR(*dev_num))
+		class_destroy(*ds5_class);
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+static void ds5_substream_init(struct ds5 *state)
+{
+	int i;
+	state->pad_to_vc[DS5_MUX_PAD_EXTERNAL]= -1;
+	if (!state->aggregated) {
+		state->pad_to_vc[DS5_MUX_PAD_DEPTH]   = sensor_vc[0];
+		state->pad_to_vc[DS5_MUX_PAD_RGB]     = sensor_vc[1];
+		state->pad_to_vc[DS5_MUX_PAD_IR]      = sensor_vc[2];
+		state->pad_to_vc[DS5_MUX_PAD_IMU]     = sensor_vc[3];
+	} else {
+		state->pad_to_vc[DS5_MUX_PAD_DEPTH] = sensor_vc[4];
+		state->pad_to_vc[DS5_MUX_PAD_RGB]   = sensor_vc[5];
+		state->pad_to_vc[DS5_MUX_PAD_IR]    = sensor_vc[6];
+		state->pad_to_vc[DS5_MUX_PAD_IMU]   = sensor_vc[7];
+	}
+
+	for (i = 0; i < ARRAY_SIZE(state->pad_to_substream); i++)
+		state->pad_to_substream[i] = -1;
+	/* match for IPU6 CSI2 BE SOC video capture pads */
+	if (!state->aggregated) {
+		state->pad_to_substream[DS5_MUX_PAD_DEPTH]   = 0;
+		state->pad_to_substream[DS5_MUX_PAD_RGB]     = 2;
+		state->pad_to_substream[DS5_MUX_PAD_IR]      = 4;
+		state->pad_to_substream[DS5_MUX_PAD_IMU]     = 5;
+	}
+	else {
+		state->pad_to_substream[DS5_MUX_PAD_DEPTH] = 6;
+		state->pad_to_substream[DS5_MUX_PAD_RGB]   = 8;
+		state->pad_to_substream[DS5_MUX_PAD_IR]    = 10;
+		state->pad_to_substream[DS5_MUX_PAD_IMU]   = 11;
+	}
+	/*
+	 * 0, vc 0, depth
+	 * 1, vc 0, meta data
+	 * 2, vc 1, RGB
+	 * 3, vc 1, meta data
+	 * 4, vc 2, IR
+	 * 5, vc 3, IMU
+	 */
+	/* aggreagated */
+	/*
+	 * 6, vc 2, depth
+	 * 7, vc 2, meta data
+	 * 8, vc 3, RGB
+	 * 9, vc 3, meta data
+	 * 10, vc 0, IR
+	 * 11, vc 1, IMU
+	 */
+	/*DEPTH*/
+	set_sub_stream_fmt  (state->pad_to_substream[DS5_MUX_PAD_DEPTH], MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h    (state->pad_to_substream[DS5_MUX_PAD_DEPTH], 480);
+	set_sub_stream_w    (state->pad_to_substream[DS5_MUX_PAD_DEPTH], 640);
+	set_sub_stream_dt   (state->pad_to_substream[DS5_MUX_PAD_DEPTH], mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(state->pad_to_substream[DS5_MUX_PAD_DEPTH], state->pad_to_vc[DS5_MUX_PAD_DEPTH]);
+	/*DEPTH MD*/
+	set_sub_stream_fmt  (state->pad_to_substream[DS5_MUX_PAD_DEPTH] + 1, MEDIA_BUS_FMT_SGRBG8_1X8);
+	set_sub_stream_h    (state->pad_to_substream[DS5_MUX_PAD_DEPTH] + 1, 1);
+	set_sub_stream_w    (state->pad_to_substream[DS5_MUX_PAD_DEPTH] + 1, 68);
+	set_sub_stream_dt   (state->pad_to_substream[DS5_MUX_PAD_DEPTH] + 1, MIPI_CSI2_TYPE_EMBEDDED8);
+	set_sub_stream_vc_id(state->pad_to_substream[DS5_MUX_PAD_DEPTH] + 1, state->pad_to_vc[DS5_MUX_PAD_DEPTH]);
+
+	/*RGB*/
+	set_sub_stream_fmt  (state->pad_to_substream[DS5_MUX_PAD_RGB], MEDIA_BUS_FMT_YUYV8_1X16);
+	set_sub_stream_h    (state->pad_to_substream[DS5_MUX_PAD_RGB], 640);
+	set_sub_stream_w    (state->pad_to_substream[DS5_MUX_PAD_RGB], 480);
+	set_sub_stream_dt   (state->pad_to_substream[DS5_MUX_PAD_RGB], mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(state->pad_to_substream[DS5_MUX_PAD_RGB], state->pad_to_vc[DS5_MUX_PAD_RGB]);
+	/*RGB MD*/
+	set_sub_stream_fmt  (state->pad_to_substream[DS5_MUX_PAD_RGB] + 1, MEDIA_BUS_FMT_SGRBG8_1X8);
+	set_sub_stream_h    (state->pad_to_substream[DS5_MUX_PAD_RGB] + 1, 1);
+	set_sub_stream_w    (state->pad_to_substream[DS5_MUX_PAD_RGB] + 1, 68);
+	set_sub_stream_dt   (state->pad_to_substream[DS5_MUX_PAD_RGB] + 1, MIPI_CSI2_TYPE_EMBEDDED8);
+	set_sub_stream_vc_id(state->pad_to_substream[DS5_MUX_PAD_RGB] + 1, state->pad_to_vc[DS5_MUX_PAD_RGB]);
+	/*IR*/
+	set_sub_stream_fmt  (state->pad_to_substream[DS5_MUX_PAD_IR], MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h    (state->pad_to_substream[DS5_MUX_PAD_IR], 640);
+	set_sub_stream_w    (state->pad_to_substream[DS5_MUX_PAD_IR], 480);
+	set_sub_stream_dt   (state->pad_to_substream[DS5_MUX_PAD_IR], mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(state->pad_to_substream[DS5_MUX_PAD_IR], state->pad_to_vc[DS5_MUX_PAD_IR]);
+	/*IMU*/
+	set_sub_stream_fmt  (state->pad_to_substream[DS5_MUX_PAD_IMU], MEDIA_BUS_FMT_UYVY8_1X16);
+	set_sub_stream_h    (state->pad_to_substream[DS5_MUX_PAD_IMU], 640);
+	set_sub_stream_w    (state->pad_to_substream[DS5_MUX_PAD_IMU], 480);
+	set_sub_stream_dt   (state->pad_to_substream[DS5_MUX_PAD_IMU], mbus_code_to_mipi(MEDIA_BUS_FMT_UYVY8_1X16));
+	set_sub_stream_vc_id(state->pad_to_substream[DS5_MUX_PAD_IMU], state->pad_to_vc[DS5_MUX_PAD_IMU]);
+}
+#endif
+
+/* SYSFS attributes */
+#ifdef CONFIG_SYSFS
+static ssize_t ds5_fw_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+
+	ds5_read(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read(state, DS5_FW_BUILD, &state->fw_build);
+
+	return snprintf(buf, PAGE_SIZE, "D4XX Sensor: %s, Version: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
+}
+
+static DEVICE_ATTR_RO(ds5_fw_ver);
+
+/* Derive 'device_attribute' structure for a read register's attribute */
+struct dev_ds5_reg_attribute {
+	struct device_attribute attr;
+	u16 reg;	// register
+	u8 valid;	// validity of above data
+};
+
+/** Read DS5 register.
+ * ds5_read_reg_show will actually read register from ds5 while
+ * ds5_read_reg_store will store register to read
+ * Example:
+ * echo -n "0xc03c" >ds5_read_reg
+ * Read register result:
+ * cat ds5_read_reg
+ * Expected:
+ * reg:0xc93c, result:0x11
+ */
+static ssize_t ds5_read_reg_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u16 rbuf;
+	int n;
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+	struct dev_ds5_reg_attribute *ds5_rw_attr = container_of(attr,
+			struct dev_ds5_reg_attribute, attr);
+	if (ds5_rw_attr->valid != 1)
+		return -EINVAL;
+	ds5_read(state, ds5_rw_attr->reg, &rbuf);
+
+	n = snprintf(buf, PAGE_SIZE, "register:0x%4x, value:0x%02x\n",
+			ds5_rw_attr->reg, rbuf);
+
+	return n;
+}
+
+/** Read DS5 register - Store reg to attr struct pointer
+ * ds5_read_reg_show will actually read register from ds5 while
+ * ds5_read_reg_store will store module, offset and length
+ */
+static ssize_t ds5_read_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct dev_ds5_reg_attribute *ds5_rw_attr = container_of(attr,
+			struct dev_ds5_reg_attribute, attr);
+	int rc = -1;
+	u32 reg;
+	ds5_rw_attr->valid = 0;
+	/* Decode input */
+	rc = sscanf(buf, "0x%04x", &reg);
+	if (rc != 1)
+		return -EINVAL;
+	ds5_rw_attr->reg = reg;
+	ds5_rw_attr->valid = 1;
+	return count;
+}
+
+#define DS5_RW_REG_ATTR(_name) \
+		struct dev_ds5_reg_attribute dev_attr_##_name = { \
+			__ATTR(_name, S_IRUGO | S_IWUSR, \
+			ds5_read_reg_show, ds5_read_reg_store), \
+			0, 0 }
+
+static DS5_RW_REG_ATTR(ds5_read_reg);
+
+static ssize_t ds5_write_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *c = to_i2c_client(dev);
+	struct ds5 *state = container_of(i2c_get_clientdata(c),
+			struct ds5, mux.sd.subdev);
+
+	int rc = -1;
+	u32 reg, w_val = 0;
+	u16 val = -1;
+	/* Decode input */
+	rc = sscanf(buf, "0x%04x 0x%04x", &reg, &w_val);
+	if (rc != 2)
+		return -EINVAL;
+	val = w_val & 0xffff;
+	mutex_lock(&state->lock);
+	ds5_write(state, reg, val);
+	mutex_unlock(&state->lock);
+	return count;
+}
+
+static DEVICE_ATTR_WO(ds5_write_reg);
+
+static struct attribute *ds5_attributes[] = {
+	&dev_attr_ds5_fw_ver.attr,
+	&dev_attr_ds5_read_reg.attr.attr,
+	&dev_attr_ds5_write_reg.attr,
+	NULL
+};
+
+static const struct attribute_group ds5_attr_group = {
+	.attrs = ds5_attributes,
+};
+#endif
+
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+#define NR_DESER 4
+#endif //CONFIG_VIDEO_INTEL_IPU6
+struct regmap *cam_regmap[4];
+static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
+{
+	struct ds5 *state = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);
+	u16 rec_state;
+	int ret,  retry,err = 0;
+#ifdef CONFIG_OF
+	const char *str;
+#endif
+	if (!state)
+		return -ENOMEM;
+
+	mutex_init(&state->lock);
+
+	state->client = c;
+	dev_warn(&c->dev, "Probing driver for D45x, id = %ld, name = %s\n", id->driver_data, id->name);
+	state->device_id = id->driver_data;
+	state->variant = ds5_variants + 0;//id->driver_data;
+#ifdef CONFIG_OF
+	state->vcc = devm_regulator_get(&c->dev, "vcc");
+	if (IS_ERR(state->vcc)) {
+		ret = PTR_ERR(state->vcc);
+		dev_warn(&c->dev, "failed %d to get vcc regulator\n", ret);
+		return ret;
+	}
+
+	if (state->vcc) {
+		ret = regulator_enable(state->vcc);
+		if (ret < 0) {
+			dev_warn(&c->dev, "failed %d to enable the vcc regulator\n", ret);
+			return ret;
+		}
+	}
+#endif
+	err = of_property_read_u32(c->dev.of_node, "def-d4m-addr", &state->g_ctx.sdev_reg);
+	if (err < 0)
+	{
+		dev_err(&c->dev, "def-d4m-addr not found, but continue\n");
+	}
+	else
+	{
+		state->client->addr = state->g_ctx.sdev_reg;
+	}
+
+	if(cam_regmap[id->driver_data] == NULL){
+		cam_regmap[id->driver_data] = devm_regmap_init_i2c(c, &ds5_regmap_config);
+		if (IS_ERR(cam_regmap[id->driver_data])) {
+			ret = PTR_ERR(cam_regmap[id->driver_data]);
+			dev_err(&c->dev, "regmap init failed: %d\n", ret);
+			goto e_regulator;
+		}
+	}
+	
+	state->regmap = cam_regmap[id->driver_data];
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	ret = ds5_serdes_setup(state);
+	if (ret < 0)
+		goto e_regulator;
+#endif
+	// Verify communication
+	retry = 5;
+	do {
+		ret = ds5_read(state, 0x5020, &rec_state);
+	} while (retry-- && ret < 0);
+	if (ret < 0) {
+		dev_err(&c->dev,
+			"%s(): cannot communicate with D4XX: %d on addr: 0x%x\n",
+			__func__, ret, c->addr);
+		goto e_regulator;
+	}
+
+	state->is_depth = 0;
+	state->is_y8 = 0;
+	state->is_rgb = 0;
+	state->is_imu = 0;
+#ifdef CONFIG_OF
+	ret = of_property_read_string(c->dev.of_node, "cam-type", &str);
+	if (!ret && !strncmp(str, "Depth", strlen("Depth"))) {
+		state->is_depth = 1;
+	}
+	if (!ret && !strncmp(str, "Y8", strlen("Y8"))) {
+		state->is_y8 = 1;
+	}
+	if (!ret && !strncmp(str, "RGB", strlen("RGB"))) {
+		state->is_rgb = 1;
+	}
+	if (!ret && !strncmp(str, "IMU", strlen("IMU"))) {
+		state->is_imu = 1;
+	}
+#else
+ 	state->is_depth = 1;
+#endif
+	/* create DFU chardev once */
+	if (state->is_depth) {
+		ret = ds5_chrdev_init(c, state);
+		if (ret < 0)
+			goto e_regulator;
+	}
+
+	ret = ds5_read(state, 0x5020, &rec_state);
+	if (ret < 0) {
+		dev_err(&c->dev, "%s(): cannot communicate with D4XX: %d\n",
+				__func__, ret);
+		goto e_chardev;
+	}
+
+	if (rec_state == 0x201) {
+		dev_info(&c->dev, "%s(): D4XX recovery state\n", __func__);
+		state->dfu_dev.dfu_state_flag = DS5_DFU_RECOVERY;
+		return 0;
+	}
+
+	ds5_read_with_check(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read_with_check(state, DS5_FW_BUILD, &state->fw_build);
+
+	dev_info(&c->dev, "D4XX Sensor: %s, firmware build: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
+
+	ret = ds5_v4l_init(c, state);
+	if (ret < 0)
+		goto e_chardev;
+	/* Override I2C drvdata */
+	/* i2c_set_clientdata(c, state); */
+
+/*	regulators? clocks?
+ *	devm_regulator_bulk_get(&c->dev, DS5_N_SUPPLIES, state->supplies);
+ *	state->clock = devm_clk_get(&c->dev, DS5_CLK_NAME);
+ *	if (IS_ERR(state->clock)) {
+ *		ret = -EPROBE_DEFER;
+ *		goto err;
+ *	}
+ */
+#ifdef CONFIG_SYSFS
+	/* Custom sysfs attributes */
+	/* create the sysfs file group */
+	err = sysfs_create_group(&state->client->dev.kobj, &ds5_attr_group);
+#endif
+#ifdef CONFIG_VIDEO_INTEL_IPU6
+	ds5_substream_init(state);
+#endif
+	return 0;
+
+e_chardev:
+	if (state->dfu_dev.ds5_class)
+		ds5_chrdev_remove(state);
+e_regulator:
+	if (state->vcc)
+		regulator_disable(state->vcc);
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	if (state->ser_i2c)
+		i2c_unregister_device(state->ser_i2c);
+	if (state->dser_i2c && !state->aggregated)
+		i2c_unregister_device(state->dser_i2c);
+#endif
+	return ret;
+}
+
+static int ds5_remove(struct i2c_client *c)
+{
+	struct ds5 *state = container_of(i2c_get_clientdata(c), struct ds5, mux.sd.subdev);
+
+#ifdef CONFIG_VIDEO_D4XX_SERDES
+	int ret;//i, 
+	// for (i = 0; i < MAX_DEV_NUM; i++) {
+	// 	if (serdes_inited[i] && serdes_inited[i] == state) {
+	// 		serdes_inited[i] = NULL;
+		if ((state->ser_dev != NULL) || (state->dser_dev != NULL)) {
+			mutex_lock(&serdes_lock__);
+
+			ret = max9295_reset_control(state->ser_dev);
+			if (ret)
+				dev_warn(&c->dev,
+				  "failed in 9295 reset control\n");
+			ret = max9296_reset_control(state->dser_dev,
+				state->g_ctx.s_dev);
+			if (ret)
+				dev_warn(&c->dev,
+				  "failed in 9296 reset control\n");
+
+			ret = max9295_sdev_unpair(state->ser_dev,
+				state->g_ctx.s_dev);
+			if (ret) 
+				dev_warn(&c->dev, "failed to unpair sdev\n");
+			ret = max9296_sdev_unregister(state->dser_dev,
+				state->g_ctx.s_dev);
+			if (ret)
+				dev_warn(&c->dev,
+				  "failed to sdev unregister sdev\n");
+			max9296_power_off(state->dser_dev);
+
+			mutex_unlock(&serdes_lock__);
+			//break;
+		}
+	//}
+	d4xx_gmsl_init_flag[state->device_id] = false;
+	if (state->ser_i2c)
+		i2c_unregister_device(state->ser_i2c);
+	if (state->dser_i2c)
+		i2c_unregister_device(state->dser_i2c);
+#endif
+#ifndef CONFIG_TEGRA_CAMERA_PLATFORM
+	state->is_depth = 1;
+#endif
+	dev_info(&c->dev, "D4XX remove %s\n",
+			ds5_get_sensor_name(state));
+	if (state->vcc)
+		regulator_disable(state->vcc);
+//	gpio_free(state->pwdn_gpio);
+
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY) {
+#ifdef CONFIG_SYSFS
+		sysfs_remove_group(&c->dev.kobj, &ds5_attr_group);
+#endif
+		ds5_mux_remove(state);
+		if (state->is_depth) {
+			ds5_chrdev_remove(state);
+		}
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id ds5_id[] = {
+	// { DS5_DRIVER_NAME, DS5_DS5U },
+	// { DS5_DRIVER_NAME_ASR, DS5_ASR },
+	// { DS5_DRIVER_NAME_AWG, DS5_AWG },
+	{ "d4xx_0", 0 },
+	{ "d4xx_1", 1 },
+	{ "d4xx_2", 2 },
+	{ "d4xx_3", 3 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ds5_id);
+
+static const struct of_device_id d4xx_of_match[] = {
+	{ .compatible = "intel,d4xx", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, d4xx_of_match);
+
+static struct i2c_driver ds5_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DS5_DRIVER_NAME
+	},
+	.probe		= ds5_probe,
+	.remove		= ds5_remove,
+	.id_table	= ds5_id,
+};
+
+module_i2c_driver(ds5_i2c_driver);
+
+MODULE_DESCRIPTION("Intel RealSense D4XX Camera Driver");
+MODULE_AUTHOR("Guennadi Liakhovetski <guennadi.liakhovetski@intel.com>,\n\
+				Nael Masalha <nael.masalha@intel.com>,\n\
+				Alexander Gantman <alexander.gantman@intel.com>,\n\
+				Emil Jahshan <emil.jahshan@intel.com>,\n\
+				Xin Zhang <xin.x.zhang@intel.com>,\n\
+				Qingwu Zhang <qingwu.zhang@intel.com>,\n\
+				Evgeni Raikhel <evgeni.raikhel@intel.com>,\n\
+				Shikun Ding <shikun.ding@intel.com>,\n\
+ 				Ethan chen <chenxinhai@sensing-world.com>");
+MODULE_AUTHOR("Dmitry Perchanov <dmitry.perchanov@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.1.21");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/Makefile b/kernel/nvidia/drivers/media/i2c/isx031/Makefile
new file mode 100644
index 0000000..5269512
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/Makefile
@@ -0,0 +1,8 @@
+subdir-ccflags-y += -Werror
+
+ccflags-y += -I$(srctree)/drivers/media/platform/tegra
+ccflags-y += -I$(srctree)/drivers/video/tegra/camera
+
+obj-y += serdes.o serdesa.o
+obj-m += fzcam.o
+obj-m += fzcama.o
\ No newline at end of file
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c b/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
new file mode 100644
index 0000000..89a5dc2
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcam.c
@@ -0,0 +1,819 @@
+/*
+ * sgcam.c - sgcam sensor driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include "fzcam_mode_tbls.h"
+
+//#define USE_RESET_GPIO
+#define SGCAM_DEFAULT_MODE		SGCAM_MODE_1920X1536_CROP_30FPS
+#define SGCAM_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_1X16
+
+
+#define SGCAM_DEFAULT_WIDTH		1920
+#define SGCAM_DEFAULT_HEIGHT	1536
+#define SGCAM_DEFAULT_CLK_FREQ	37125000
+
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define sgcam_subdev camera_common_data
+#else
+struct sgcam_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct sgcam {
+	int 	channel;
+	u32					sensor_def_addr;
+	u32					sensor_map_addr;
+	struct 	camera_common_power_rail	power;
+	int		numctrls;
+	struct 	v4l2_ctrl_handler	ctrl_handler;
+	struct 	i2c_client	*i2c_client;
+	struct 	v4l2_subdev	*subdev;
+	struct 	sgcam_subdev sd;
+	struct 	media_pad	pad;
+	u32				frame_length;
+	s32		group_hold_prev;
+	bool	group_hold_en;
+	s64 	last_wdr_et_val;
+	struct regmap	*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	.use_single_rw = true,
+#else
+	.use_single_read = true,
+	.use_single_write = true,
+#endif
+};
+
+static int sgcam_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int sgcam_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static const struct v4l2_ctrl_ops sgcam_ctrl_ops = {
+	.g_volatile_ctrl = sgcam_g_volatile_ctrl,
+	.s_ctrl = sgcam_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+};
+
+static inline void sgcam_get_frame_length_regs(sgcam_reg *regs,
+				u32 frame_length)
+{
+	return;
+}
+
+static inline void sgcam_get_coarse_time_regs_shs1(sgcam_reg *regs,
+				u32 coarse_time)
+{
+	return ;
+}
+
+static inline void sgcam_get_coarse_time_regs_shs2(sgcam_reg *regs,
+				u32 coarse_time)
+{
+	return; 
+}
+
+static inline void sgcam_get_gain_reg(sgcam_reg *regs,
+				u8 gain)
+{
+
+}
+
+static inline int sgcam_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int sgcam_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct device *dev = &priv->i2c_client->dev;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int sgcam_write_table(struct sgcam *priv,
+		const sgcam_reg table[])
+{		
+	return 0;
+	
+	/*
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 sgcam_TABLE_WAIT_MS,
+					 sgcam_TABLE_END);
+	*/
+}
+
+static int sgcam_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	
+#ifdef USE_RESET_GPIO
+	/*exit reset mode: XCLR */
+	if (pw->reset_gpio) {
+		gpio_set_value(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_set_value(pw->reset_gpio, 1);
+		usleep_range(30, 50);
+	}
+#endif
+
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int sgcam_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err)
+			goto power_off_done;
+		else
+			dev_err(dev, "%s failed.\n", __func__);
+		return err;
+	}
+#ifdef USE_RESET_GPIO
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_set_value(pw->reset_gpio, 0);
+#endif
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int sgcam_power_get(struct sgcam *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	#ifdef USE_RESET_GPIO
+	struct camera_common_pdata *pdata = priv->pdata;
+	#endif
+	struct device *dev = &priv->i2c_client->dev;
+	const char *mclk_name;
+	struct clk *parent;
+	int err = 0;
+
+	mclk_name = priv->pdata->mclk_name ?
+		    priv->pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
+
+#ifdef USE_RESET_GPIO
+	pw->reset_gpio = pdata->reset_gpio;
+#endif
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+static int sgcam_set_gain(struct sgcam *priv, s64 val);
+static int sgcam_set_frame_rate(struct sgcam *priv, s64 val);
+static int sgcam_set_exposure(struct sgcam *priv, s64 val);
+
+/* Video ops */
+static int sgcam_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static int sgcam_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+static int sgcam_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	int err = 0;
+
+	dev_dbg(dev, "%s++ enable %d\n", __func__, enable);
+
+	if (!enable) {
+		err = sgcam_write_table(priv, mode_table[SGCAM_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+		else 
+			return 0;
+	}
+
+	err = sgcam_write_table(priv, mode_table[SGCAM_MODE_START_STREAM]);
+	if (err)
+		return err;
+	else
+		return 0;
+}
+
+static int sgcam_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops sgcam_subdev_video_ops = {
+	.g_frame_interval	= sgcam_g_frame_interval,
+	.s_frame_interval	= sgcam_s_frame_interval,
+	.s_stream	= sgcam_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = sgcam_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops sgcam_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int sgcam_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int sgcam_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	int ret = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops sgcam_subdev_pad_ops = {
+	.set_fmt = sgcam_set_fmt,
+	.get_fmt = sgcam_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.get_mbus_config	= camera_common_get_mbus_config,
+#endif
+};
+
+static struct v4l2_subdev_ops sgcam_subdev_ops = {
+	.core	= &sgcam_subdev_core_ops,
+	.video	= &sgcam_subdev_video_ops,
+	.pad = &sgcam_subdev_pad_ops,
+};
+
+const static struct of_device_id sgcam_of_match[] = {
+	{ .compatible = "nvidia,fzcam",},
+	{ },
+};
+
+static struct camera_common_sensor_ops sgcam_common_ops = {
+	.power_on = sgcam_power_on,
+	.power_off = sgcam_power_off,
+	.write_reg = sgcam_write_reg,
+	.read_reg = sgcam_read_reg,
+};
+
+static int sgcam_set_group_hold(struct sgcam *priv, s32 val)
+{
+	return 0;
+}
+
+static int sgcam_set_gain(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcam_set_frame_rate(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcam_set_exposure(struct sgcam *priv, s64 val)
+{
+	return 0;
+}
+
+
+static int sgcam_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcam *priv =
+		container_of(ctrl->handler, struct sgcam, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+
+	default:
+			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcam_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcam *priv =
+		container_of(ctrl->handler, struct sgcam, ctrl_handler);
+	struct camera_common_data	*s_data = priv->s_data;
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = sgcam_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		err = sgcam_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		err = sgcam_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		err = sgcam_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		s_data->sensor_mode_id = (int) (*ctrl->p_new.p_s64);
+		break;
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcam_ctrls_init(struct sgcam *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err = 0;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = num_ctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, sgcam_of_match);
+
+static struct camera_common_pdata *sgcam_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err = 0;
+	const char *str;
+	
+	#ifdef USE_RESET_GPIO
+	int gpio;
+	#endif
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(sgcam_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(&client->dev, "mclk not in DT\n");
+
+#ifdef USE_RESET_GPIO
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+#endif
+
+	return board_priv_pdata;
+}
+
+static int sgcam_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops sgcam_subdev_internal_ops = {
+	.open = sgcam_open,
+};
+
+static const struct media_entity_operations sgcam_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int sgcam_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct sgcam *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "probing fzcam v4l2 sensor\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct sgcam) + sizeof(struct v4l2_ctrl *),
+			    GFP_KERNEL);
+
+	if (!priv) {
+		dev_err(&client->dev, "unable to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_dbg(&client->dev, "channel not found\n");
+		
+	err = device_property_read_u32(&client->dev, "reg", &priv->sensor_map_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "reg not found\n");
+		priv->sensor_map_addr = 0x00;
+	}
+
+	err = device_property_read_u32(&client->dev,  "def-addr", &priv->sensor_def_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "def-addr not found\n");
+		priv->sensor_def_addr = 0x00;
+	}
+	
+	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = sgcam_parse_dt(client, common_data);
+
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &sgcam_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &sgcam_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  SGCAM_DEFAULT_DATAFMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = (void *)priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(sgcam_frmfmt);
+	common_data->def_mode = SGCAM_DEFAULT_MODE;
+	common_data->def_width = SGCAM_DEFAULT_WIDTH;
+	common_data->def_height = SGCAM_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = SGCAM_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	priv->last_wdr_et_val = 0;
+
+	err = sgcam_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "sgcam");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize sgcam.\n");
+		return err;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &sgcam_subdev_ops);
+
+	err = sgcam_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &sgcam_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		     V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &sgcam_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1,
+				&priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_info(&client->dev, "Detected Sensor\n");
+
+	return 0;
+}
+
+static int
+sgcam_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcam *priv = (struct sgcam *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+static const struct i2c_device_id sgcam_id[] = {
+	{ "fzcam", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sgcam_id);
+
+static struct i2c_driver sgcam_i2c_driver = {
+	.driver = {
+		.name = "fzcam",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(sgcam_of_match),
+	},
+	.probe = sgcam_probe,
+	.remove = sgcam_remove,
+	.id_table = sgcam_id,
+};
+
+module_i2c_driver(sgcam_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sensing-World MAXIM GMSL");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
new file mode 100644
index 0000000..a6f605a
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcam_mode_tbls.h
@@ -0,0 +1,78 @@
+/*
+ * SGCAM_mode_tbls.h - fzcam sensor mode tables
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __SGCAM_I2C_TABLES__
+#define __SGCAM_I2C_TABLES__
+
+#include <media/camera_common.h>
+#include <linux/miscdevice.h>
+
+#define SGCAM_TABLE_WAIT_MS	0
+#define SGCAM_TABLE_END		1
+#define SGCAM_MAX_RETRIES	3
+#define SGCAM_WAIT_MS_STOP	1
+#define SGCAM_WAIT_MS_START	30
+#define SGCAM_WAIT_MS_STREAM	210
+#define SGCAM_GAIN_TABLE_SIZE 255
+
+#define sgcam_reg struct reg_8
+
+static sgcam_reg SGCAM_start[] = {
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_START},
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_STREAM},
+	{SGCAM_TABLE_END, 0x00}
+};
+
+static sgcam_reg SGCAM_stop[] = {
+	{SGCAM_TABLE_WAIT_MS, SGCAM_WAIT_MS_STOP},
+	{SGCAM_TABLE_END, 0x00}
+};
+
+static sgcam_reg SGCAM_1920x1536_crop_30fps[] = {
+
+	{SGCAM_TABLE_END, 0x00},
+};
+
+enum {
+	SGCAM_MODE_1920X1536_CROP_30FPS,
+	SGCAM_MODE_START_STREAM,
+	SGCAM_MODE_STOP_STREAM,
+};
+
+static sgcam_reg *mode_table[] = {
+	[SGCAM_MODE_1920X1536_CROP_30FPS]
+		= SGCAM_1920x1536_crop_30fps,
+	[SGCAM_MODE_START_STREAM]
+		= SGCAM_start,
+	[SGCAM_MODE_STOP_STREAM]
+		= SGCAM_stop,
+};
+
+static const int SGCAM_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in device tree!
+ */
+static const struct camera_common_frmfmt sgcam_frmfmt[] = {
+	{{1920, 1536}, SGCAM_30fps, 1, 0, SGCAM_MODE_1920X1536_CROP_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __SGCAM_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c b/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
new file mode 100644
index 0000000..13d0783
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcama.c
@@ -0,0 +1,819 @@
+/*
+ * sgcama.c - sgcama sensor driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include "fzcama_mode_tbls.h"
+
+//#define USE_RESET_GPIO
+#define SGCAMA_DEFAULT_MODE		SGCAMA_MODE_1920X1536_CROP_30FPS
+#define SGCAMA_DEFAULT_DATAFMT	MEDIA_BUS_FMT_UYVY8_1X16
+
+
+#define SGCAMA_DEFAULT_WIDTH	1920
+#define SGCAMA_DEFAULT_HEIGHT	1536
+#define SGCAMA_DEFAULT_CLK_FREQ	37125000
+
+
+#ifdef CONFIG_TEGRA_CAMERA_PLATFORM
+#include <media/camera_common.h>
+#define sgcama_subdev camera_common_data
+#else
+struct sgcama_subdev {
+	struct v4l2_subdev subdev;
+};
+#endif
+
+struct sgcama {
+	int 	channel;
+	u32					sensor_def_addr;
+	u32					sensor_map_addr;
+	struct 	camera_common_power_rail	power;
+	int		numctrls;
+	struct 	v4l2_ctrl_handler	ctrl_handler;
+	struct 	i2c_client	*i2c_client;
+	struct 	v4l2_subdev	*subdev;
+	struct 	sgcama_subdev sd;
+	struct 	media_pad	pad;
+	u32				frame_length;
+	s32		group_hold_prev;
+	bool	group_hold_en;
+	s64 	last_wdr_et_val;
+	struct regmap	*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+static const struct regmap_config sensor_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	.use_single_rw = true,
+#else
+	.use_single_read = true,
+	.use_single_write = true,
+#endif
+};
+
+static int sgcama_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int sgcama_s_ctrl(struct v4l2_ctrl *ctrl);
+
+static const struct v4l2_ctrl_ops sgcama_ctrl_ops = {
+	.g_volatile_ctrl = sgcama_g_volatile_ctrl,
+	.s_ctrl = sgcama_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &sgcama_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+};
+
+static inline void sgcama_get_frame_length_regs(sgcama_reg *regs,
+				u32 frame_length)
+{
+	return;
+}
+
+static inline void sgcama_get_coarse_time_regs_shs1(sgcama_reg *regs,
+				u32 coarse_time)
+{
+	return ;
+}
+
+static inline void sgcama_get_coarse_time_regs_shs2(sgcama_reg *regs,
+				u32 coarse_time)
+{
+	return; 
+}
+
+static inline void sgcama_get_gain_reg(sgcama_reg *regs,
+				u8 gain)
+{
+
+}
+
+static inline int sgcama_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int sgcama_write_reg(struct camera_common_data *s_data,
+				u16 addr, u8 val)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct device *dev = &priv->i2c_client->dev;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		dev_err(dev, "%s: i2c write failed, 0x%x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+static int sgcama_write_table(struct sgcama *priv,
+		const sgcama_reg table[])
+{		
+	return 0;
+	
+	/*
+	struct camera_common_data *s_data = priv->s_data;
+
+	return regmap_util_write_table_8(s_data->regmap,
+					 table,
+					 NULL, 0,
+					 SGCAMAA_TABLE_WAIT_MS,
+					 SGCAMAA_TABLE_END);
+	*/
+}
+
+static int sgcama_power_on(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			dev_err(dev, "%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+	
+#ifdef USE_RESET_GPIO
+	/*exit reset mode: XCLR */
+	if (pw->reset_gpio) {
+		gpio_set_value(pw->reset_gpio, 0);
+		usleep_range(30, 50);
+		gpio_set_value(pw->reset_gpio, 1);
+		usleep_range(30, 50);
+	}
+#endif
+
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int sgcama_power_off(struct camera_common_data *s_data)
+{
+	int err = 0;
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	struct device *dev = &priv->i2c_client->dev;
+
+	dev_dbg(dev, "%s: power off\n", __func__);
+
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err)
+			goto power_off_done;
+		else
+			dev_err(dev, "%s failed.\n", __func__);
+		return err;
+	}
+#ifdef USE_RESET_GPIO
+	/* enter reset mode: XCLR */
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		gpio_set_value(pw->reset_gpio, 0);
+#endif
+
+power_off_done:
+	pw->state = SWITCH_OFF;
+
+	return 0;
+}
+
+static int sgcama_power_get(struct sgcama *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	#ifdef USE_RESET_GPIO
+	struct camera_common_pdata *pdata = priv->pdata;
+	#endif
+	struct device *dev = &priv->i2c_client->dev;
+	const char *mclk_name;
+	struct clk *parent;
+	int err = 0;
+
+	mclk_name = priv->pdata->mclk_name ?
+		    priv->pdata->mclk_name : "extperiph1";
+	pw->mclk = devm_clk_get(dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(dev, "unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parent = devm_clk_get(dev, "pllp_grtba");
+	if (IS_ERR(parent))
+		dev_err(dev, "devm_clk_get failed for pllp_grtba");
+	else
+		clk_set_parent(pw->mclk, parent);
+
+#ifdef USE_RESET_GPIO
+	pw->reset_gpio = pdata->reset_gpio;
+#endif
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+static int sgcama_set_gain(struct sgcama *priv, s64 val);
+static int sgcama_set_frame_rate(struct sgcama *priv, s64 val);
+static int sgcama_set_exposure(struct sgcama *priv, s64 val);
+
+/* Video ops */
+static int sgcama_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{
+	if (NULL == sd || NULL == fi)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
+
+	return 0;
+}
+
+static int sgcama_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *fi)
+{	u16 framerate = 1;
+
+	if (NULL == sd || NULL == fi || fi->interval.numerator == 0)
+		return -EINVAL;
+
+	fi->interval.numerator = 1;
+	fi->interval.denominator = 30;
+
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+
+	return 0;
+}
+static int sgcama_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *dev = &client->dev;
+	struct camera_common_data *s_data = to_camera_common_data(dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	int err = 0;
+
+	dev_dbg(dev, "%s++ enable %d\n", __func__, enable);
+
+	if (!enable) {
+		err = sgcama_write_table(priv, mode_table[SGCAMA_MODE_STOP_STREAM]);
+		if (err)
+			return err;
+		else 
+			return 0;
+	}
+
+	err = sgcama_write_table(priv, mode_table[SGCAMA_MODE_START_STREAM]);
+	if (err)
+		return err;
+	else
+		return 0;
+}
+
+static int sgcama_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops sgcama_subdev_video_ops = {
+	.g_frame_interval	= sgcama_g_frame_interval,
+	.s_frame_interval	= sgcama_s_frame_interval,
+	.s_stream	= sgcama_s_stream,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	.g_mbus_config	= camera_common_g_mbus_config,
+#endif
+	.g_input_status = sgcama_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops sgcama_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int sgcama_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int sgcama_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_format *format)
+{
+	int ret = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops sgcama_subdev_pad_ops = {
+	.set_fmt = sgcama_set_fmt,
+	.get_fmt = sgcama_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.get_mbus_config	= camera_common_get_mbus_config,
+#endif
+};
+
+static struct v4l2_subdev_ops sgcama_subdev_ops = {
+	.core	= &sgcama_subdev_core_ops,
+	.video	= &sgcama_subdev_video_ops,
+	.pad = &sgcama_subdev_pad_ops,
+};
+
+const static struct of_device_id sgcama_of_match[] = {
+	{ .compatible = "nvidia,fzcama",},
+	{ },
+};
+
+static struct camera_common_sensor_ops sgcama_common_ops = {
+	.power_on = sgcama_power_on,
+	.power_off = sgcama_power_off,
+	.write_reg = sgcama_write_reg,
+	.read_reg = sgcama_read_reg,
+};
+
+static int sgcama_set_group_hold(struct sgcama *priv, s32 val)
+{
+	return 0;
+}
+
+static int sgcama_set_gain(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcama_set_frame_rate(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+static int sgcama_set_exposure(struct sgcama *priv, s64 val)
+{
+	return 0;
+}
+
+
+static int sgcama_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcama *priv =
+		container_of(ctrl->handler, struct sgcama, ctrl_handler);
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+
+	default:
+			dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+			return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcama_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct sgcama *priv =
+		container_of(ctrl->handler, struct sgcama, ctrl_handler);
+	struct camera_common_data	*s_data = priv->s_data;
+	struct device *dev = &priv->i2c_client->dev;
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = sgcama_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		err = sgcama_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		err = sgcama_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		err = sgcama_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		s_data->sensor_mode_id = (int) (*ctrl->p_new.p_s64);
+		break;
+	default:
+		dev_err(dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int sgcama_ctrls_init(struct sgcama *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls;
+	int err = 0;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = num_ctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, sgcama_of_match);
+
+static struct camera_common_pdata *sgcama_parse_dt(struct i2c_client *client,
+				struct camera_common_data *s_data)
+{
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err = 0;
+	const char *str;
+	
+	#ifdef USE_RESET_GPIO
+	int gpio;
+	#endif
+
+	if (!np)
+		return NULL;
+
+	match = of_match_device(sgcama_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	err = of_property_read_string(np, "use_sensor_mode_id", &str);
+	if (!err) {
+		if (!strcmp(str, "true"))
+			s_data->use_sensor_mode_id = true;
+		else
+			s_data->use_sensor_mode_id = false;
+	}
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(np, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_err(&client->dev, "mclk not in DT\n");
+
+#ifdef USE_RESET_GPIO
+	gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio < 0) {
+		dev_err(&client->dev, "reset-gpios not found %d\n", gpio);
+		gpio = 0;
+	}
+	board_priv_pdata->reset_gpio = (unsigned int)gpio;
+#endif
+
+	return board_priv_pdata;
+}
+
+static int sgcama_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops sgcama_subdev_internal_ops = {
+	.open = sgcama_open,
+};
+
+static const struct media_entity_operations sgcama_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int sgcama_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct sgcama *priv;
+	int err = 0;
+
+	dev_info(&client->dev, "probing sgcama v4l2 sensor\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct sgcama) + sizeof(struct v4l2_ctrl *),
+			    GFP_KERNEL);
+
+	if (!priv) {
+		dev_err(&client->dev, "unable to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_dbg(&client->dev, "channel not found\n");
+		
+	err = device_property_read_u32(&client->dev, "reg", &priv->sensor_map_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "reg not found\n");
+		priv->sensor_map_addr = 0x00;
+	}
+
+	err = device_property_read_u32(&client->dev,  "def-addr", &priv->sensor_def_addr);
+	if (err < 0) {
+		dev_dbg(&client->dev, "def-addr not found\n");
+		priv->sensor_def_addr = 0x00;
+	}
+	
+	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = sgcama_parse_dt(client, common_data);
+
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+	common_data->ops = &sgcama_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &sgcama_frmfmt[0];
+	common_data->colorfmt = camera_common_find_datafmt(
+					  SGCAMA_DEFAULT_DATAFMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = (void *)priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(sgcama_frmfmt);
+	common_data->def_mode = SGCAMA_DEFAULT_MODE;
+	common_data->def_width = SGCAMA_DEFAULT_WIDTH;
+	common_data->def_height = SGCAMA_DEFAULT_HEIGHT;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = SGCAMA_DEFAULT_CLK_FREQ;
+
+	priv->i2c_client = client;
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+	priv->last_wdr_et_val = 0;
+
+	err = sgcama_power_get(priv);
+	if (err)
+		return err;
+
+	err = camera_common_initialize(common_data, "sgcama");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize sgcama.\n");
+		return err;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &sgcama_subdev_ops);
+
+	err = sgcama_ctrls_init(priv);
+	if (err)
+		return err;
+
+	priv->subdev->internal_ops = &sgcama_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		     V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->subdev->entity.ops = &sgcama_media_ops;
+	err = tegra_media_entity_init(&priv->subdev->entity, 1,
+				&priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+#endif
+
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err)
+		return err;
+
+	dev_info(&client->dev, "Detected Sensor\n");
+
+	return 0;
+}
+
+static int
+sgcama_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct sgcama *priv = (struct sgcama *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+static const struct i2c_device_id sgcama_id[] = {
+	{ "fzcama", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, sgcama_id);
+
+static struct i2c_driver sgcama_i2c_driver = {
+	.driver = {
+		.name = "fzcama",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(sgcama_of_match),
+	},
+	.probe = sgcama_probe,
+	.remove = sgcama_remove,
+	.id_table = sgcama_id,
+};
+
+module_i2c_driver(sgcama_i2c_driver);
+
+MODULE_DESCRIPTION("Media Controller driver for Sensing-World MAXIM GMSL");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
new file mode 100644
index 0000000..f93dd23
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/fzcama_mode_tbls.h
@@ -0,0 +1,78 @@
+/*
+ * sgcama_mode_tbls.h - sgcama sensor mode tables
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __SGCAMA_I2C_TABLES__
+#define __SGCAMA_I2C_TABLES__
+
+#include <media/camera_common.h>
+#include <linux/miscdevice.h>
+
+#define SGCAMA_TABLE_WAIT_MS	0
+#define SGCAMA_TABLE_END		1
+#define SGCAMA_MAX_RETRIES	3
+#define SGCAMA_WAIT_MS_STOP	1
+#define SGCAMA_WAIT_MS_START	30
+#define SGCAMA_WAIT_MS_STREAM	210
+#define SGCAMA_GAIN_TABLE_SIZE 255
+
+#define sgcama_reg struct reg_8
+
+static sgcama_reg sgcama_start[] = {
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_START},
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_STREAM},
+	{SGCAMA_TABLE_END, 0x00}
+};
+
+static sgcama_reg sgcama_stop[] = {
+	{SGCAMA_TABLE_WAIT_MS, SGCAMA_WAIT_MS_STOP},
+	{SGCAMA_TABLE_END, 0x00}
+};
+
+static sgcama_reg sgcama_1920x1536_crop_30fps[] = {
+
+	{SGCAMA_TABLE_END, 0x00},
+};
+
+enum {
+	SGCAMA_MODE_1920X1536_CROP_30FPS,
+	SGCAMA_MODE_START_STREAM,
+	SGCAMA_MODE_STOP_STREAM,
+};
+
+static sgcama_reg *mode_table[] = {
+	[SGCAMA_MODE_1920X1536_CROP_30FPS]
+		= sgcama_1920x1536_crop_30fps,
+	[SGCAMA_MODE_START_STREAM]
+		= sgcama_start,
+	[SGCAMA_MODE_STOP_STREAM]
+		= sgcama_stop,
+};
+
+static const int sgcama_30fps[] = {
+	30,
+};
+
+/*
+ * WARNING: frmfmt ordering need to match mode definition in device tree!
+ */
+static const struct camera_common_frmfmt sgcama_frmfmt[] = {
+	{{1920, 1536}, sgcama_30fps, 1, 0, SGCAMA_MODE_1920X1536_CROP_30FPS},
+	/* Add modes with no device tree support after below */
+};
+
+#endif /* __SGCAMA_I2C_TABLES__ */
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdes.c b/kernel/nvidia/drivers/media/i2c/isx031/serdes.c
new file mode 100644
index 0000000..485c913
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdes.c
@@ -0,0 +1,369 @@
+/*
+ * serdes.c - serdes GMSL Expander driver
+ *
+ * Copyright (c) 2021, Fangzhu Tech Corp. All rights reserved.
+ * Based on Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include "serdes.h"
+
+#define SERDES_MODULE_VERSION "1.0.0.0"
+
+#define IS_LINK     (1)
+#define NO_LINK     (0)
+#define SENYUN_ISX031  (0)
+#define SENYUN_ISX031F (1)
+
+struct serdes {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct gpio_desc *pwdn_gpio;
+	int channel;
+	int camA_type, camB_type; //0=Senyun ISX031, 1=Senyun ISX031F(need mfp8 trigger)
+	unsigned char linka,linkb; //0x45, 0x46
+};
+struct serdes *global_priv[2];
+
+#define DBG
+//#define DBG_REG
+static int Deser_write_reg(int channel, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err;
+	int addr_bak;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priv[channel]->i2c_client;
+
+	if(slave_addr != DESERILIAER_ADDR) {
+		addr_bak = global_priv[channel]->i2c_client->addr;
+		global_priv[channel]->i2c_client->addr = slave_addr;
+	}
+	err = regmap_write(global_priv[channel]->regmap, reg, val);
+	#ifdef DBG_REG
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, reg, val);
+	#endif
+
+	if(slave_addr != DESERILIAER_ADDR)
+		global_priv[channel]->i2c_client->addr = addr_bak;
+	usleep_range(200, 500);
+	#ifdef DBG_REG
+	dev_info(&i2c_client->dev, "Serdes [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, slave_addr, reg, val );
+	#endif
+	return err;
+}
+
+int Deser_write_reg_list(int channel, struct deser_reg *table, int size)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err = 0, i;
+	u8 slave_addr;
+	u16 reg;
+	u16 val;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priv[channel]->i2c_client;
+	
+	for(i=0; i<size; i++)
+	{
+		slave_addr = table[i].slave_addr;
+		reg = table[i].reg;
+		val = table[i].val;
+		
+		if(global_priv[channel]->linka == IS_LINK && global_priv[channel]->linkb == NO_LINK){
+		    /* Only Port A Link */
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x21)
+		    {
+		        val = 0x31;
+		    }
+		    if(slave_addr == SERILIAER_ADDR && reg == 0x0000 && val == (SERILIAER_ADDR_B << 1))
+		    {
+		        continue;
+		    }
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x23)
+		    {
+		        /* disable split mode */
+		        continue;
+		    }
+		    if(slave_addr == SERILIAER_ADDR_B){
+		        /* skip configure port B */
+		        continue;
+		    }
+		}
+		else if(global_priv[channel]->linka == NO_LINK && global_priv[channel]->linkb == IS_LINK)
+		{
+		    /* Only Port B Link */
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x21)
+		    {
+		        val = 0x32;
+		    }
+		    if(slave_addr == SERILIAER_ADDR && reg == 0x0000 && val == (SERILIAER_ADDR_A << 1))
+		    {
+		        continue;
+		    }
+		    if(slave_addr == DESERILIAER_ADDR && reg == 0x0010 && val == 0x23)
+		    {
+		        /* disable split mode */
+		        continue;
+		    }
+		    if(slave_addr == SERILIAER_ADDR_A){
+		        /* skip configure port A */
+		        continue;
+		    }
+		}
+		else if(global_priv[channel]->linka == NO_LINK && global_priv[channel]->linkb == NO_LINK)
+		{
+		    /* No Port Link */
+		    return 0;
+		}
+		if(slave_addr == GMSL_ADDR) {
+			//dev_info(&i2c_client->dev, "mdelay = %d(ms)\n", val);
+			msleep(val);
+		}
+        else if(slave_addr == SERILIAER_ADDR && reg == 0x0000)
+        {
+            err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+            if(err){
+                slave_addr = (val >> 1); 
+                err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+                if(err){
+                    dev_dbg(&i2c_client->dev, "MAX929x Write failed [0x%02x]:[0x%04x=0x%02x]\n", slave_addr, reg, val);
+                    return err;
+                }
+            }
+        }
+		else
+			err = Deser_write_reg(channel, slave_addr, reg, (u8)val);
+
+		if(err!=0)
+			break;
+	}
+
+	return err;
+}
+
+static  struct regmap_config deser_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int Deser_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device dev = client->dev;
+	struct serdes *priv;
+	int err;
+
+	dev_dbg(&dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &deser_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pwdn_gpio = devm_gpiod_get(&client->dev, "pwdn", GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwdn_gpio)) {
+		//dev_info(&dev, "get pwdn value :%d\n", gpiod_get_value(priv->pwdn_gpio));
+		//gpiod_set_value(priv->pwdn_gpio, false);
+		//msleep(200);
+		gpiod_set_value(priv->pwdn_gpio, true);
+		msleep(200);
+	}
+	
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_err(&dev, "channel not found\n");
+	
+	global_priv[priv->channel] = priv;
+	
+	//Set MAX9296 3Gbps
+	err = Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0313, 0x00); 	//disable csi output
+	if (err) {
+		dev_err(&dev, "%s: fail\n", __func__);
+		return 0;
+	}
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0005, 0x80); //LOCK output enabled, disable the others
+	
+	/*detect GMSL Link A */
+	priv->camA_type = SENYUN_ISX031;
+	priv->linka = IS_LINK;
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21);
+	mdelay(200);
+	err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_A<<1);
+	if (err) {
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0006, 0xDF);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x01);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21);
+
+		mdelay(200);
+		priv->camA_type = SENYUN_ISX031F;
+		err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_A<<1);
+		if (err) {
+			priv->camA_type = SENYUN_ISX031;
+			priv->linka = NO_LINK;
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*2);
+			#endif
+		}
+		else {
+			priv->linka = IS_LINK;
+			if(priv->camA_type == SENYUN_ISX031F)
+				err = Deser_write_reg_list(priv->channel, SG_linkA_SY_ISX031F_Ser_init,
+					sizeof(SG_linkA_SY_ISX031F_Ser_init)/sizeof(struct deser_reg));
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2, priv->camB_type);
+			#endif
+		}
+	}
+	else {
+		priv->linka = IS_LINK;
+			if(priv->camA_type == SENYUN_ISX031)
+				err = Deser_write_reg_list(priv->channel, SG_linkA_SY_ISX031_Ser_init,
+					sizeof(SG_linkA_SY_ISX031_Ser_init)/sizeof(struct deser_reg));
+		#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2, priv->camA_type);
+		#endif
+	}
+	
+	/*detect GMSL Link B */
+	priv->camB_type = SENYUN_ISX031;
+	priv->linkb = IS_LINK;
+	Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x22);
+	mdelay(200);
+	err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_B<<1);
+	if (err) {
+		priv->camB_type = SENYUN_ISX031F;
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0006, 0xDF);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x01);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0011, 0x0F);
+		Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x22);
+		mdelay(200);
+		err = Deser_write_reg(priv->channel, SERILIAER_ADDR, 0x0000, SERILIAER_ADDR_B<<1);
+		if (err) {
+			priv->camB_type = SENYUN_ISX031;
+			priv->linkb = NO_LINK;
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0010, 0x21); //switch to linkA
+			Deser_write_reg(priv->channel, DESERILIAER_ADDR, 0x0001, 0x02);
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*2+1);
+			#endif
+		}
+		else {
+			priv->linkb = IS_LINK;
+			if(priv->camB_type == SENYUN_ISX031F)
+				err = Deser_write_reg_list(priv->channel, SG_linkB_SY_ISX031F_Ser_init,
+					sizeof(SG_linkB_SY_ISX031F_Ser_init)/sizeof(struct deser_reg));
+			#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2+1, priv->camB_type);
+			#endif
+		}
+	}
+	else {
+		priv->linkb = IS_LINK;
+		if(priv->camB_type == SENYUN_ISX031)
+			err = Deser_write_reg_list(priv->channel, SG_linkB_SY_ISX031_Ser_init,
+				sizeof(SG_linkB_SY_ISX031_Ser_init)/sizeof(struct deser_reg));
+		#ifdef DBG
+			dev_info(&client->dev, "/dev/video%d[%d]is connected!\n", priv->channel*2+1, priv->camA_type);
+		#endif
+	}
+	if(priv->linka == IS_LINK || priv->linkb == IS_LINK) {
+		err = Deser_write_reg_list(priv->channel, SG_Deser_MAX9296_init,
+				sizeof(SG_Deser_MAX9296_init)/sizeof(struct deser_reg));
+	}
+
+	return 0;
+}
+
+int Deser_lock(int channel)
+{
+	if(global_priv[channel]->linka == IS_LINK || global_priv[channel]->linkb == IS_LINK)
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(Deser_lock);
+
+static int Deser_remove(struct i2c_client *client)
+{
+	if (client != NULL) {
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id Deser_id[] = {
+	{ "serdes", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, Deser_id);
+
+const struct of_device_id Deser_of_match[] = {
+	{ .compatible = "nvidia,serdes", },
+	{ },
+};
+
+static struct i2c_driver Deser_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "serdes",
+		.of_match_table = of_match_ptr(Deser_of_match),
+	},
+	.probe = Deser_probe,
+	.remove = Deser_remove,
+	.id_table = Deser_id,
+};
+
+static int __init Deser_init(void)
+{
+	return i2c_add_driver(&Deser_i2c_driver);
+}
+
+static void __exit Deser_exit(void)
+{
+	i2c_del_driver(&Deser_i2c_driver);
+}
+
+module_init(Deser_init);
+module_exit(Deser_exit);
+
+MODULE_DESCRIPTION("IO Expander Driver MAX9296 Sensing-World");
+MODULE_AUTHOR("Sensing-World Tech Corporation");
+MODULE_VERSION(SERDES_MODULE_VERSION);
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdes.h b/kernel/nvidia/drivers/media/i2c/isx031/serdes.h
new file mode 100644
index 0000000..e4ae6dd
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdes.h
@@ -0,0 +1,196 @@
+#ifndef __SERDES_H__
+#define __SERDES_H__
+
+#define GMSL_TABLE_END 0xffff
+#define GMSL_WAIT_MS 0x55
+#define GMSL_ADDR 0x08
+
+struct deser_reg
+{
+	u16 slave_addr;
+	u16 reg;
+	u16 val;
+};
+
+#define DESERILIAER_ADDR    0x48
+#define SERILIAER_ADDR      0x62
+#define SERILIAER_ADDR_A    0x41
+#define SERILIAER_ADDR_B    0x42
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkA_SY_ISX031_Ser_init[] = {
+	{SERILIAER_ADDR_A, 0x0010, 0x21},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+
+	{SERILIAER_ADDR_A, 0x006b, 0x16},
+	{SERILIAER_ADDR_A, 0x0073, 0x17},
+	{SERILIAER_ADDR_A, 0x007b, 0x36},
+	{SERILIAER_ADDR_A, 0x0083, 0x36},
+	{SERILIAER_ADDR_A, 0x008b, 0x36},
+	{SERILIAER_ADDR_A, 0x0093, 0x36},
+	{SERILIAER_ADDR_A, 0x009b, 0x36},
+	{SERILIAER_ADDR_A, 0x00a3, 0x36},
+	{SERILIAER_ADDR_A, 0x00ab, 0x36},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x02be, 0x10},
+	{SERILIAER_ADDR_A, 0x02d3, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 500},
+
+	// {SERILIAER_ADDR_A, 0x02d3, 0x00},
+	{SERILIAER_ADDR_A, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 300},
+	{SERILIAER_ADDR_A, 0x0308, 0x62},
+	{SERILIAER_ADDR_A, 0x0311, 0xF0}, //Start Video Pipeline on CSI PortB
+	{SERILIAER_ADDR_A, 0x0316, 0x5E}, //Set DT
+	{SERILIAER_ADDR_A, 0x0318, 0x62},
+	{SERILIAER_ADDR_A, 0x0002, 0xF3}, //Turn on all pipeline
+	// {SERILIAER_ADDR_A, 0x02d3, 0x84},
+	// {SERILIAER_ADDR_A, 0x02d5, 0x07},
+	{SERILIAER_ADDR_A, 0x02d6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{SERILIAER_ADDR_A, 0x02d6, 0x84},
+	{SERILIAER_ADDR_A, 0x02d8, 0x07}, // mfp8 trigger
+
+};
+
+static struct deser_reg SG_linkA_SY_ISX031F_Ser_init[] = {
+	{SERILIAER_ADDR_A, 0x02d3, 0x00},
+	{SERILIAER_ADDR_A, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+	{SERILIAER_ADDR_A, 0x02d3, 0x10},
+	//{SERILIAER_ADDR_A, 0x02d3, 0x84},
+	{SERILIAER_ADDR_A, 0x02d5, 0x07}, // mfp7 trigger
+	{SERILIAER_ADDR_A, 0x02d6, 0x10},
+	//{SERILIAER_ADDR_A, 0x02d6, 0x84},
+	{SERILIAER_ADDR_A, 0x02d8, 0x07}, // mfp8 trigger
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x006b, 0x16},
+	{SERILIAER_ADDR_A, 0x0073, 0x17},
+	{SERILIAER_ADDR_A, 0x007b, 0x36},
+	{SERILIAER_ADDR_A, 0x0083, 0x36},
+	{SERILIAER_ADDR_A, 0x008b, 0x36},
+	{SERILIAER_ADDR_A, 0x0093, 0x36},
+	{SERILIAER_ADDR_A, 0x009b, 0x36},
+	{SERILIAER_ADDR_A, 0x00a3, 0x36},
+	{SERILIAER_ADDR_A, 0x00ab, 0x36},
+	{SERILIAER_ADDR_A, 0x0044, 0x36},
+	{SERILIAER_ADDR_A, 0x0045, 0x20},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_A, 0x005B, 0x01}, // Stream ID
+	{SERILIAER_ADDR_A, 0x0318, 0x5e}, // Set DT YUV-422 8Bit
+	{SERILIAER_ADDR_A, 0x0331, 0x33}, // 4Lanes
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkB_SY_ISX031_Ser_init[] = {
+	{SERILIAER_ADDR_B, 0x0010, 0x22},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+
+	{SERILIAER_ADDR_B, 0x006b, 0x16},
+	{SERILIAER_ADDR_B, 0x0073, 0x17},
+	{SERILIAER_ADDR_B, 0x007b, 0x37},
+	{SERILIAER_ADDR_B, 0x0083, 0x37},
+	{SERILIAER_ADDR_B, 0x008b, 0x37},
+	{SERILIAER_ADDR_B, 0x0093, 0x37},
+	{SERILIAER_ADDR_B, 0x009b, 0x37},
+	{SERILIAER_ADDR_B, 0x00a3, 0x37},
+	{SERILIAER_ADDR_B, 0x00ab, 0x37},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x02be, 0x10},
+	{SERILIAER_ADDR_B, 0x02d3, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 500},
+
+	// {SERILIAER_ADDR_B, 0x02d3, 0x00},
+	{SERILIAER_ADDR_B, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 300},
+	{SERILIAER_ADDR_B, 0x0308, 0x64},
+	{SERILIAER_ADDR_B, 0x0311, 0xF0}, //Start Video Pipeline on CSI PortB
+	{SERILIAER_ADDR_B, 0x0316, 0x62},
+	{SERILIAER_ADDR_B, 0x0318, 0x5E}, //Set DT
+	{SERILIAER_ADDR_B, 0x0002, 0xF3}, //Turn on all pipeline
+	// {SERILIAER_ADDR_B, 0x02d3, 0x84},
+	// {SERILIAER_ADDR_B, 0x02d5, 0x07},
+	{SERILIAER_ADDR_B, 0x02d6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{SERILIAER_ADDR_B, 0x02d6, 0x84},
+	{SERILIAER_ADDR_B, 0x02d8, 0x07}, // mfp8 trigger
+};
+
+static struct deser_reg SG_linkB_SY_ISX031F_Ser_init[] = {
+	{SERILIAER_ADDR_B, 0x02d3, 0x00},
+	{SERILIAER_ADDR_B, 0x02d6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 200},
+	{SERILIAER_ADDR_B, 0x02d3, 0x10},
+	//{SERILIAER_ADDR_B, 0x02d3, 0x84},
+	{SERILIAER_ADDR_B, 0x02d5, 0x07}, // mfp7 trigger
+	{SERILIAER_ADDR_B, 0x02d6, 0x10},
+	//{SERILIAER_ADDR_B, 0x02d6, 0x84},
+	{SERILIAER_ADDR_B, 0x02d8, 0x07}, // mfp8 trigger
+
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x006b, 0x16},
+	{SERILIAER_ADDR_B, 0x0073, 0x17},
+	{SERILIAER_ADDR_B, 0x007b, 0x37},
+	{SERILIAER_ADDR_B, 0x0083, 0x37},
+	{SERILIAER_ADDR_B, 0x008b, 0x37},
+	{SERILIAER_ADDR_B, 0x0093, 0x37},
+	{SERILIAER_ADDR_B, 0x009b, 0x37},
+	{SERILIAER_ADDR_B, 0x00a3, 0x37},
+	{SERILIAER_ADDR_B, 0x00ab, 0x37},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+	{SERILIAER_ADDR_B, 0x0318, 0x5e}, // Set DT YUV-422 8Bit
+	{SERILIAER_ADDR_B, 0x005B, 0x02}, // Stream ID
+	{SERILIAER_ADDR_B, 0x0331, 0x33}, // 4Lanes
+};
+
+static struct deser_reg SG_Deser_MAX9296_init[] = {
+	{DESERILIAER_ADDR, 0x0010, 0x23},
+	
+	{DESERILIAER_ADDR, 0x0320, 0x2F}, 
+	// Deserializer MIPI MAP SRC->DST three
+	{DESERILIAER_ADDR, 0x044B, 0x07}, // Pipe Y MAP enable - three
+	{DESERILIAER_ADDR, 0x048B, 0x07}, // Pipe Z MAP enable - three
+
+	{DESERILIAER_ADDR, 0x042D, 0x00},
+	{DESERILIAER_ADDR, 0x046D, 0x15}, // Pipe Y To MIPI port A -> 0X44B
+	{DESERILIAER_ADDR, 0x04AD, 0x15}, // Pipe Z To MIPI port A -> 0X48B
+	{DESERILIAER_ADDR, 0x04ED, 0x00},
+	// Pipeline Y -> VC=0, DT=1E
+	{DESERILIAER_ADDR, 0x044D, 0x1e}, // Pipeline Y mapping src (YUV422 8Bit) 
+	{DESERILIAER_ADDR, 0x044E, 0x1e}, // Pipeline Y YUV422 8Bit mapping
+	{DESERILIAER_ADDR, 0x044F, 0x00}, // Pipeline Y FS mapping
+	{DESERILIAER_ADDR, 0x0450, 0x00}, // Pipeline Y FS mapping
+	{DESERILIAER_ADDR, 0x0451, 0x01}, // Pipeline Y FE mapping
+	{DESERILIAER_ADDR, 0x0452, 0x01}, // Pipeline Y FE mapping
+	// Pipeline Z -> VC=1, DT=1E
+	{DESERILIAER_ADDR, 0x048D, 0x1e}, // Pipeline Z mapping src (YUV422 8Bit) 
+	{DESERILIAER_ADDR, 0x048E, 0x5e}, // Pipeline Z YUV422 8Bit mapping
+	{DESERILIAER_ADDR, 0x048F, 0x00}, // Pipeline Z FS mapping
+	{DESERILIAER_ADDR, 0x0490, 0x40}, // Pipeline Z FS mapping
+	{DESERILIAER_ADDR, 0x0491, 0x01}, // Pipeline Z FE mapping
+	{DESERILIAER_ADDR, 0x0492, 0x41}, // Pipeline Z FE mapping
+
+	{DESERILIAER_ADDR, 0x044A, 0xC0}, // four lane output from MIPI Port A
+	{DESERILIAER_ADDR, 0x048A, 0xC0}, // four lane output from MIPI Port A
+
+	{DESERILIAER_ADDR, 0x0003, 0x40}, // MFP6 used as GPI, disable UTART1 function
+	{DESERILIAER_ADDR, 0x0B08, 0x20}, // GPI-to-GPO
+	{DESERILIAER_ADDR, 0x02C2, 0x83}, // mfp6 config MAX9296->MAX9295 mfp8 passthrough
+	{DESERILIAER_ADDR, 0x02C3, 0xA7}, // mfp6 config
+	{GMSL_ADDR, GMSL_WAIT_MS, 10},
+	{DESERILIAER_ADDR, 0x0313, 0x02}, // Enable MIPI output
+};
+
+#endif
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
new file mode 100644
index 0000000..cb08d22
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.c
@@ -0,0 +1,325 @@
+/*
+ * serdesaa.c - serdesaa GMSL Expander driver
+ *
+ * Copyright (c) 2021-2023, Fangzhu Tech Corp. All rights reserved.
+ * Copyright (c) 2021-2023, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/seq_file.h>
+#include <linux/debugfs.h>
+#include <media/camera_common.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include "serdesa.h"
+
+#define SERDESA_MODULE_VERSION "1.0.1.0"
+
+#define IS_LINK     (1)
+#define NO_LINK     (0)
+//MAX96712
+
+struct serdesa {
+	struct i2c_client *i2c_client;
+	struct regmap *regmap;
+	struct gpio_desc *pwdn_gpio;
+	int channel;
+	unsigned char videoa,videob,videoc,videod; //0x41, 0x42, 0x43, 0x44
+};
+struct serdesa *global_priva[2];
+
+#define DBG
+//#define DBG_REG
+static int serdesa_write_reg(int channel, u8 slave_addr, u16 reg, u8 val)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err;
+	int addr_bak;
+
+	if(channel > 2 || channel < 0)
+		return -1;
+	
+
+	i2c_client = global_priva[channel]->i2c_client;
+	if(slave_addr != DESERILIAER_ADDR) {
+		addr_bak = global_priva[channel]->i2c_client->addr;
+		global_priva[channel]->i2c_client->addr = slave_addr;
+	}
+	err = regmap_write(global_priva[channel]->regmap, reg, val);
+	#ifdef DBG_REG
+	if (err)
+		dev_err(&i2c_client->dev, "%s:i2c write failed, 0x%x = %x\n",
+			__func__, reg, val);
+	#endif
+
+	usleep_range(200, 500);
+	#ifdef DBG_REG
+	if(slave_addr != DESERILIAER_ADDR) 
+		dev_info(&i2c_client->dev, "serdesa: [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, global_priva[channel]->i2c_client->addr, reg, val );
+	else 
+		dev_info(&i2c_client->dev, "serdesa: [%d-0x%02x]:[0x%04x=0x%02x]\n", channel, global_priva[channel]->i2c_client->addr, reg, val );
+	#endif
+
+	if(slave_addr != DESERILIAER_ADDR)
+		global_priva[channel]->i2c_client->addr = addr_bak;
+	
+	return err;
+}
+// static int serdesa_read_reg(int channel, u8 slave_addr, u16 reg, unsigned int *val)
+// {
+// 	struct i2c_client *i2c_client = NULL;
+// 	int err;
+// 	int addr_bak;
+// 	if(channel > 3 || channel < 0)
+// 		return -1;
+// 	i2c_client = global_priva[channel]->i2c_client;
+// 	addr_bak = global_priva[channel]->i2c_client->addr;
+// 	global_priva[channel]->i2c_client->addr = slave_addr;
+// 	err = regmap_read(global_priva[channel]->regmap, reg, val);
+// 	if (err)
+// 		dev_err(&i2c_client->dev, "%s:i2c read failed, 0x%x = %x\n",
+// 			__func__, reg, *val);
+// 	global_priva[channel]->i2c_client->addr = addr_bak;
+// 	#ifndef DBG_REG
+// 	dev_info(&i2c_client->dev, "MAX929x[%d-0x%02x]:[0x%04x=0x%02x]\n", channel, slave_addr, reg, *val);
+// 	#endif
+// 	if(err)
+// 		return 0;
+// 	return 1;
+// }
+
+int serdesa_write_reg_list(int channel, struct deser_reg *table, int size)
+{
+	struct i2c_client *i2c_client = NULL;
+	int err = 0, i;
+	u8 slave_addr;
+	u16 reg;
+	u16 val;
+
+	if(channel > 3 || channel < 0)
+		return -1;
+
+	i2c_client = global_priva[channel]->i2c_client;
+	
+	for(i=0; i<size; i++)
+	{
+		slave_addr = table[i].slave_addr;
+		reg = table[i].reg;
+		val = table[i].val;
+		
+		if(slave_addr == GMSL_ADDR) {
+			//dev_info(&i2c_client->dev, "mdelay = %d(ms)\n", val);
+			msleep(val);
+		}
+        else if(slave_addr == SERILIAER_ADDR && reg == 0x0000)
+        {
+            err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+            if(err){
+                slave_addr = (val >> 1); 
+                err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+                if(err){
+                    dev_dbg(&i2c_client->dev, "MAX929x Write failed [0x%02x]:[0x%04x=0x%02x]\n", slave_addr, reg, val);
+                    return err;
+                }
+            }
+        }
+		else
+			err = serdesa_write_reg(channel, slave_addr, reg, (u8)val);
+
+		if(err!=0)
+			break;
+	}
+
+	return err;
+}
+
+static  struct regmap_config deser_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int serdesa_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct device dev = client->dev;
+	struct serdesa *priv;
+	int err, cnt=0;//, tmp;
+
+	dev_dbg(&dev, "%s: enter\n", __func__);
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	priv->i2c_client = client;
+	priv->regmap = devm_regmap_init_i2c(priv->i2c_client, &deser_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pwdn_gpio = devm_gpiod_get(&client->dev, "pwdn", GPIOD_OUT_HIGH);
+	if (!IS_ERR(priv->pwdn_gpio)) {
+		//dev_info(&dev, "get pwdn value :%d\n", gpiod_get_value(priv->pwdn_gpio));
+		//gpiod_set_value(priv->pwdn_gpio, false);
+		//msleep(200);
+		gpiod_set_value(priv->pwdn_gpio, true);
+		msleep(200);
+	}
+	
+	priv->channel = 0;
+	err = device_property_read_u32(&client->dev, "channel", &priv->channel);
+	if (err) 
+		dev_err(&dev, "channel not found\n");
+	
+	global_priva[priv->channel] = priv;
+	
+	//sensing camera
+	// err = serdesa_write_reg_list(priv->channel, SG_Deser_6G_init,
+	// 		sizeof(SG_Deser_6G_init)/sizeof(struct deser_reg));
+	// err = serdesa_read_reg(priv->channel, SERILIAER_ADDR, 0x00, &tmp);
+	// if(tmp != 0x80)
+	// 	err = serdesa_write_reg_list(priv->channel, SG_Deser_3G_init,
+	// 		sizeof(SG_Deser_3G_init)/sizeof(struct deser_reg));
+	// err = serdesa_write_reg_list(priv->channel, SG_Deser_init,
+	// 		sizeof(SG_Deser_init)/sizeof(struct deser_reg));
+	//otobrite camera
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_6G_init,
+			sizeof(SG_Deser_6G_init)/sizeof(struct deser_reg));
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_init,
+			sizeof(SG_Deser_init)/sizeof(struct deser_reg));
+			
+	/*detect GMSL Link A */
+	priv->videoa = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkA_Dser_Ser_init,
+		sizeof(SG_linkA_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videoa = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4);
+		#endif
+	}
+	else {
+		priv->videoa = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4);
+		#endif
+	}
+	/*detect GMSL Link B */
+	priv->videob = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkB_Dser_Ser_init,
+		sizeof(SG_linkB_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videob = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+1);
+		#endif
+	}
+	else {
+		priv->videob = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+1);
+		#endif
+	}
+	/*detect GMSL Link C */
+	priv->videoc = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkC_Dser_Ser_init,
+		sizeof(SG_linkC_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videoc = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+2);
+		#endif
+	}
+	else {
+		priv->videoc = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+2);
+		#endif
+	}
+	/*detect GMSL Link D */
+	priv->videod = IS_LINK;
+	err = serdesa_write_reg_list(priv->channel, SG_linkD_Dser_Ser_init,
+		sizeof(SG_linkD_Dser_Ser_init)/sizeof(struct deser_reg));
+	if (err) {
+		priv->videod = NO_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is disconnected!\n", priv->channel*4+3);
+		#endif
+	}
+	else {
+		priv->videod = IS_LINK;
+		#ifdef DBG
+		dev_info(&client->dev, "/dev/video%d is connected!\n", priv->channel*4+3);
+		#endif
+	}
+
+	cnt = priv->videoa + priv->videob + priv->videoc + priv->videod;
+    if(cnt > 3)
+    {
+		serdesa_write_reg(priv->channel, DESERILIAER_ADDR, 0x0418, 0x33);
+    }
+	err = serdesa_write_reg_list(priv->channel, SG_Deser_End_init,
+		sizeof(SG_Deser_End_init)/sizeof(struct deser_reg));
+	return 0;
+}
+
+static int serdesa_remove(struct i2c_client *client)
+{
+	if (client != NULL) {
+		i2c_unregister_device(client);
+		client = NULL;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id serdesa_id[] = {
+	{ "serdesa", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, serdesa_id);
+
+const struct of_device_id serdesa_of_match[] = {
+	{ .compatible = "nvidia,serdesa", },
+	{ },
+};
+
+static struct i2c_driver serdesa_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "serdesa",
+		.of_match_table = of_match_ptr(serdesa_of_match),
+	},
+	.probe = serdesa_probe,
+	.remove = serdesa_remove,
+	.id_table = serdesa_id,
+};
+
+static int __init serdesa_init(void)
+{
+	return i2c_add_driver(&serdesa_i2c_driver);
+}
+
+static void __exit serdesa_exit(void)
+{
+	i2c_del_driver(&serdesa_i2c_driver);
+}
+
+module_init(serdesa_init);
+module_exit(serdesa_exit);
+
+MODULE_DESCRIPTION("IO Expander Driver MAX96712 Sensing-World");
+MODULE_AUTHOR("Sensing-World Corporation");
+MODULE_VERSION(SERDESA_MODULE_VERSION);
+MODULE_LICENSE("GPL v2");
diff --git a/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h
new file mode 100644
index 0000000..c447969
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/isx031/serdesa.h
@@ -0,0 +1,239 @@
+#ifndef __SERDESA_H__
+#define __SERDESA_H__
+/*
+* 2023-02-12 4-IMX390 need set CSI Rate to 0x2F 
+* 0x2D3 Rising
+* 0x2D6 Rising
+*
+*/
+
+#define GMSL_TABLE_END  0xffff
+#define GMSL_WAIT_MS 	0x55
+#define GMSL_ADDR 		0x08
+
+struct deser_reg {
+	u16 slave_addr;
+	u16 reg;
+	u16 val;
+};
+
+#define DESERILIAER_ADDR    0x29
+#define SERILIAER_ADDR      0x62
+#define SERILIAER_ADDR_A    0x41
+#define SERILIAER_ADDR_B    0x42
+#define SERILIAER_ADDR_C    0x43
+#define SERILIAER_ADDR_D    0x44
+#define WR_PARAM
+
+// static struct deser_reg SG_Deser_3G_init[] = {
+// 	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+// 	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable link A
+// 	{DESERILIAER_ADDR, 0x0010, 0x11},
+// 	{DESERILIAER_ADDR, 0x0011, 0x11},
+// };
+static struct deser_reg SG_Deser_6G_init[] = {
+	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable link A
+	{DESERILIAER_ADDR, 0x0010, 0x22},
+	{DESERILIAER_ADDR, 0x0011, 0x22},
+};
+static struct deser_reg SG_Deser_init[] = {
+	{DESERILIAER_ADDR, 0x040b, 0x00}, // Disable MIPI Output
+	{DESERILIAER_ADDR, 0x0006, 0xF0}, // Enable link A
+	
+	//3G Settings
+
+	{DESERILIAER_ADDR, 0x00F0, 0x62},
+	{DESERILIAER_ADDR, 0x00F1, 0xEA},
+	{DESERILIAER_ADDR, 0x00F4, 0x0F},
+
+	// Video Pipe to MIPI Controller Mapping
+	// YUV422 8bit, video pipe 0, map FS/FE, Four pipiline in and PortA csi output
+	{DESERILIAER_ADDR, 0x090B, 0x07}, 
+	{DESERILIAER_ADDR, 0x092D, 0x15}, //map to MIPI Controller 0
+	{DESERILIAER_ADDR, 0x090D, 0x1E}, //map to VC0
+	{DESERILIAER_ADDR, 0x090E, 0x1E},
+	{DESERILIAER_ADDR, 0x090F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0910, 0x00},
+	{DESERILIAER_ADDR, 0x0911, 0x01},
+	{DESERILIAER_ADDR, 0x0912, 0x01},
+	
+	// YUV422 8bit, video pipe 1, map FS/FE
+	{DESERILIAER_ADDR, 0x094B, 0x07},
+	{DESERILIAER_ADDR, 0x096D, 0x15}, //map to MIPI Controller 1
+	{DESERILIAER_ADDR, 0x094D, 0x1E}, //map to VC1
+	{DESERILIAER_ADDR, 0x094E, 0x5E},
+	{DESERILIAER_ADDR, 0x094F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0950, 0x40},
+	{DESERILIAER_ADDR, 0x0951, 0x01},
+	{DESERILIAER_ADDR, 0x0952, 0x41},
+	
+	// YUV422 8bit, video pipe 2, map FS/FE
+	{DESERILIAER_ADDR, 0x098B, 0x07},
+	{DESERILIAER_ADDR, 0x09AD, 0x15}, //map to MIPI Controller 2
+	{DESERILIAER_ADDR, 0x098D, 0x1E}, //map to VC2
+	{DESERILIAER_ADDR, 0x098E, 0x9E},
+	{DESERILIAER_ADDR, 0x098F, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x0990, 0x80},
+	{DESERILIAER_ADDR, 0x0991, 0x01},
+	{DESERILIAER_ADDR, 0x0992, 0x81},
+	
+	// YUV422 8bit, video pipe 3, map FS/FE
+	{DESERILIAER_ADDR, 0x09CB, 0x07},
+	{DESERILIAER_ADDR, 0x09ED, 0x15}, //map to MIPI Controller 3
+	{DESERILIAER_ADDR, 0x09CD, 0x1E}, //map to VC3
+	{DESERILIAER_ADDR, 0x09CE, 0xDE},
+	{DESERILIAER_ADDR, 0x09CF, 0x00}, //frame start
+	{DESERILIAER_ADDR, 0x09D0, 0xC0},
+	{DESERILIAER_ADDR, 0x09D1, 0x01},
+	{DESERILIAER_ADDR, 0x09D2, 0xC1},
+
+	{GMSL_ADDR, GMSL_WAIT_MS, 20}, 
+	{DESERILIAER_ADDR, 0x08A0, 0x04}, //PHY 2x4 MIPI output configured as two ports with four data lanes each. PHY0 and PHY1 combined, and PHY2 and PHY3 combined.
+	{DESERILIAER_ADDR, 0x08A3, 0xE4}, //default 0x4E, 0xE4:MIPI PHY1/PHY0 lane mapping PHY1:D1-D3/D0-D2, PHY0:D1-D1/D0-D0
+	{DESERILIAER_ADDR, 0x08A4, 0xE4}, //default 0xE4, 0xE4:MIPI PHY3/PHY2 lane mapping PHY3:D1-D3/D0-D2, PHY2:D1-D1/D0-D0
+
+	// Set 4 lane D-PHY (Default setting)
+	{DESERILIAER_ADDR, 0x090A, 0xC0},
+	{DESERILIAER_ADDR, 0x094A, 0xC0},
+	{DESERILIAER_ADDR, 0x098A, 0xC0},
+	{DESERILIAER_ADDR, 0x09CA, 0xC0},
+
+	// Turn on MIPI PHYs
+	{DESERILIAER_ADDR, 0x08A2, 0xF0},
+	
+	// Set MIPI Data rate to be 2400Mbps/lane for port A and enable software override
+	{DESERILIAER_ADDR, 0x0415, 0x2F}, //Lower than 8M set to 0x2F
+	{DESERILIAER_ADDR, 0x0418, 0x2F},
+	{DESERILIAER_ADDR, 0x041B, 0x2F},
+	{DESERILIAER_ADDR, 0x041E, 0x2F},
+	{GMSL_ADDR, GMSL_WAIT_MS, 20},
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkA_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF1}, // Turn on GMSL2 mode for link A 
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 10}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7},
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x82},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkB_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF2}, // Turn on GMSL2 mode for link B
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7},
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x84},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkC_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF4}, // Turn on GMSL2 mode for link C
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100},
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7}, 
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x86},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+// NOTE:
+//		for SENSING ISX031
+//			MFP0 is used as camera reset, need to set high
+//			MFP7 & MFP8 is used as frame sync trigger
+// 		for OTOBRITES ISX031
+//			MFP0 & MFP7 is used as camera reset, need to set high
+//			MFP8 is used as frame sync trigger
+static struct deser_reg SG_linkD_Dser_Ser_init[] = {
+	{DESERILIAER_ADDR, 0x0006, 0xF8}, // Turn on GMSL2 mode for link D 
+	{GMSL_ADDR, GMSL_WAIT_MS, 200}, 
+	{SERILIAER_ADDR, 0x02be, 0x10}, // Camera reset
+	{SERILIAER_ADDR, 0x02D3, 0x10}, // Camera reset
+	{GMSL_ADDR, GMSL_WAIT_MS, 300}, 
+	{SERILIAER_ADDR, 0x0318, 0x5e}, // Set DT
+	// {SERILIAER_ADDR, 0x02D3, 0x00},
+	{SERILIAER_ADDR, 0x02D6, 0x00},
+	{GMSL_ADDR, GMSL_WAIT_MS, 100}, 
+	// {SERILIAER_ADDR, 0x02D3, 0x10},
+	{SERILIAER_ADDR, 0x02D6, 0x10},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30},
+	// {SERILIAER_ADDR, 0x02d3, 0x84},
+	// {SERILIAER_ADDR, 0x02d5, 0xA7}, 
+	{SERILIAER_ADDR, 0x02d6, 0x84},
+	{SERILIAER_ADDR, 0x02d8, 0xA7},
+	{SERILIAER_ADDR, 0x0000, 0x88},
+	{GMSL_ADDR, GMSL_WAIT_MS, 30}, 
+};
+
+
+static struct deser_reg SG_Deser_End_init[] = {
+	{DESERILIAER_ADDR, 0x0313, 0x83},
+	{DESERILIAER_ADDR, 0x0314, 0xa7}, //LinkA
+	{DESERILIAER_ADDR, 0x034A, 0xa7}, //LinkB
+	{DESERILIAER_ADDR, 0x0381, 0xa7}, //LinkC
+	{DESERILIAER_ADDR, 0x03B7, 0xa7}, //LinkD
+	{DESERILIAER_ADDR, 0x0006, 0xFF}, // Enable all links back
+	{DESERILIAER_ADDR, 0x0018, 0x0F}, // One-shot link reset for all links
+	{GMSL_ADDR, GMSL_WAIT_MS, 100},
+	{DESERILIAER_ADDR, 0x040b, 0x02}, // Enable MIPI Output
+	{DESERILIAER_ADDR, 0x08a0, 0x84},
+};
+
+#endif
diff --git a/kernel/nvidia/drivers/media/i2c/max9295.c b/kernel/nvidia/drivers/media/i2c/max9295.c
index 110f861..0e6ff80 100644
--- a/kernel/nvidia/drivers/media/i2c/max9295.c
+++ b/kernel/nvidia/drivers/media/i2c/max9295.c
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-
+// #define DEBUG 1
 #include <media/camera_common.h>
 #include <linux/module.h>
 #include <media/max9295.h>
@@ -111,9 +111,10 @@ struct max9295 {
 	/* primary serializer properties */
 	__u32 def_addr;
 	__u32 pst2_ref;
+	u8 prim_id;
 };
 
-static struct max9295 *prim_priv__;
+static struct max9295 *prim_priv__[4];
 
 struct map_ctx {
 	u8 dt;
@@ -131,7 +132,9 @@ static int max9295_write_reg(struct device *dev, u16 addr, u8 val)
 	if (err)
 		dev_err(dev, "%s:i2c write failed, 0x%x = %x\n",
 			__func__, addr, val);
-
+	else
+		dev_dbg(dev, "%s:i2c write, 0x%x = %x\n",
+			__func__, addr, val);
 	/* delay before next i2c command as required for SERDES link */
 	usleep_range(100, 110);
 
@@ -311,9 +314,9 @@ int max9295_setup_control(struct device *dev)
 
 	g_ctx = priv->g_client.g_ctx;
 
-	if (prim_priv__) {
+	if (prim_priv__[priv->prim_id]) {
 		/* update address reassingment */
-		max9295_write_reg(&prim_priv__->i2c_client->dev,
+		max9295_write_reg(&prim_priv__[priv->prim_id]->i2c_client->dev,
 				MAX9295_DEV_ADDR, (g_ctx->ser_reg << 1));
 	}
 
@@ -350,16 +353,16 @@ int max9295_setup_control(struct device *dev)
 		i2c_ovrd[i+1] += (i < 4) ? offset1 : offset2;
 
 		/* i2c passthrough2 must be configured once for all devices */
-		if ((i2c_ovrd[i] == 0x8B) && prim_priv__ &&
-				prim_priv__->pst2_ref)
+		if ((i2c_ovrd[i] == 0x8B) && prim_priv__[priv->prim_id] &&
+				prim_priv__[priv->prim_id]->pst2_ref)
 			continue;
 
 		max9295_write_reg(dev, i2c_ovrd[i], i2c_ovrd[i+1]);
 	}
 
 	/* dev addr pass-through2 ref */
-	if (prim_priv__)
-		prim_priv__->pst2_ref++;
+	if (prim_priv__[priv->prim_id])
+		prim_priv__[priv->prim_id]->pst2_ref++;
 
 	max9295_write_reg(dev, MAX9295_I2C4_ADDR, (g_ctx->sdev_reg << 1));
 	max9295_write_reg(dev, MAX9295_I2C5_ADDR, (g_ctx->sdev_def << 1));
@@ -390,14 +393,15 @@ int max9295_reset_control(struct device *dev)
 
 	priv->g_client.st_done = false;
 
-	if (prim_priv__) {
-		prim_priv__->pst2_ref--;
+	if (prim_priv__[priv->prim_id]) {
+		prim_priv__[priv->prim_id]->pst2_ref--;
 
 		max9295_write_reg(dev, MAX9295_DEV_ADDR,
-					(prim_priv__->def_addr << 1));
-
-		max9295_write_reg(&prim_priv__->i2c_client->dev,
-					MAX9295_CTRL0_ADDR, MAX9295_RESET_ALL);
+					(prim_priv__[priv->prim_id]->def_addr << 1));
+		if (prim_priv__[priv->prim_id]->pst2_ref == 0){
+			max9295_write_reg(&prim_priv__[priv->prim_id]->i2c_client->dev,
+						MAX9295_CTRL0_ADDR, MAX9295_RESET_ALL);
+		}	
 	}
 
 error:
@@ -472,9 +476,170 @@ EXPORT_SYMBOL(max9295_sdev_unpair);
 static  struct regmap_config max9295_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
+	.cache_type = REGCACHE_NONE,
+};
+
+struct reg_pair {
+	u16 addr;
+	u8 val;
 };
 
+static int max9295_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	int err = 0;
+	u32 j = 0;
+
+	for (j = 0; j < count; j++) {
+		err = max9295_write_reg(dev,
+			map[j].addr, map[j].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+static int __max9295_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+			      u8 data_type2, u32 vc_id)
+{
+	int err = 0;
+	u8 bpp = 0x30;
+	static u8 pipe_x_val = 0x0;
+	struct reg_pair map_multi_pipe_en[] = {
+		{0x0315, 0x80},
+	};
+	struct reg_pair map_bpp8dbl[] = {
+		{0x0312, 0x0F},
+	};
+	struct reg_pair map_pipe_control[] = {
+		/* addr, val */
+		{MAX9295_PIPE_X_DT_ADDR, 0x5E}, // Pipe X pulls data_type1
+		{0x0315, 0x52}, // Pipe X pulls data_type2
+		{0x0309, 0x01}, // # Pipe X pulls vc_id
+		{0x030A, 0x00},
+		{0x031C, 0x30}, // BPP in pipe X
+		{0x0102, 0x0E}, // LIM_HEART Pipe X: Disabled
+	};
+
+	if (data_type1 == GMSL_CSI_DT_RAW_8 || data_type1 == GMSL_CSI_DT_EMBED
+	    || data_type2 == GMSL_CSI_DT_RAW_8 || data_type2 == GMSL_CSI_DT_EMBED) {
+		map_bpp8dbl[0].val |= (1 << pipe_id);
+	} else {
+		map_bpp8dbl[0].val &= ~(1 << pipe_id);
+	}
+	err |= max9295_set_registers(dev, map_bpp8dbl, ARRAY_SIZE(map_bpp8dbl));
+
+	if (data_type1 == GMSL_CSI_DT_RGB_888)
+		bpp = 0x18;
+
+	map_pipe_control[0].addr += 0x2 * pipe_id;
+	map_pipe_control[1].addr += 0x2 * pipe_id;
+	map_pipe_control[2].addr += 0x2 * pipe_id;
+	map_pipe_control[3].addr += 0x2 * pipe_id;
+	map_pipe_control[4].addr += 0x1 * pipe_id;
+	map_pipe_control[5].addr += 0x8 * pipe_id;
+
+	map_pipe_control[0].val = 0x40 | data_type1;
+	map_pipe_control[1].val = 0x40 | data_type2;
+	map_pipe_control[2].val = 1 << vc_id;
+	map_pipe_control[3].val = 0x00;
+	map_pipe_control[4].val = bpp;
+	map_pipe_control[5].val = 0x0E;
+
+	if (pipe_id == 0)
+		pipe_x_val = map_pipe_control[1].val;
+
+	err |= max9295_set_registers(dev, map_pipe_control,
+				     ARRAY_SIZE(map_pipe_control));
+
+	map_multi_pipe_en[0].val = 0x80 | pipe_x_val;
+	err |= max9295_set_registers(dev, map_multi_pipe_en,
+				     ARRAY_SIZE(map_multi_pipe_en));
+
+	return err;
+}
+
+int max9295_init_settings(struct device *dev)
+{
+	int err = 0;
+	int i;
+	struct max9295 *priv = dev_get_drvdata(dev);
+
+	struct reg_pair map_pipe_opt[] = {
+		// Enable all pipes
+		{MAX9295_PIPE_EN_ADDR, 0xF3},
+		// Write 0x33 for 4 lanes
+		{MAX9295_MIPI_RX1_ADDR, 0x11},
+		// All pipes pull clock from port B
+		{MAX9295_CSI_PORT_SEL_ADDR, 0x6F},
+		// All pipes pull data from port B
+		{MAX9295_START_PIPE_ADDR, 0xF0},
+	};
+
+	static struct reg_pair map_depth_trigger[] = {
+	//	{0x02D6, 0x84}, // #MFP8
+	//	{0x02D7, 0x60}, // #OUT_TYPE bit to 1
+	//	{0x02D8, 0x1F},
+		{0x02C1, 0x84}, // #MFP1
+		{0x02C2, 0x20}, // #OUT_TYPE bit to 1 (no pullup)
+		{0x02C3, 0x1F},
+	};
+
+	static struct reg_pair map_rgb_trigger[] = {
+		{0x02BE, 0x84}, // #MFP0
+		{0x02BF, 0x20}, // #OUT_TYPE bit to 1  (no pullup)
+		{0x02C0, 0x1B},
+	};
+
+	mutex_lock(&priv->lock);
+	
+	// Init control
+	err |= max9295_set_registers(dev, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+
+	for (i = 0; i < MAX9295_MAX_PIPES; i++)
+		err |= __max9295_set_pipe(dev, i, GMSL_CSI_DT_YUV422_8,
+					  GMSL_CSI_DT_EMBED, i);
+
+	// Trigger Depth
+	err |= max9295_set_registers(dev, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	// Trigger RGB
+	err |= max9295_set_registers(dev, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9295_init_settings);
+
+int max9295_set_pipe(struct device *dev, int pipe_id,
+		     u8 data_type1, u8 data_type2, u32 vc_id)
+{
+	struct max9295 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (pipe_id > (MAX9295_MAX_PIPES - 1)) {
+		dev_info(dev, "%s, input pipe_id: %d exceed max9295 max pipes\n",
+			 __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s pipe_id %d, data_type1 %u, data_type2 %u, vc_id %u\n",
+		__func__, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max9295_set_pipe(dev, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9295_set_pipe);
+
 static int max9295_probe(struct i2c_client *client,
 				const struct i2c_device_id *id)
 {
@@ -495,9 +660,9 @@ static int max9295_probe(struct i2c_client *client,
 	}
 
 	mutex_init(&priv->lock);
-
+	priv->prim_id = id->driver_data;
 	if (of_get_property(node, "is-prim-ser", NULL)) {
-		if (prim_priv__) {
+		if (prim_priv__[priv->prim_id]) {
 			dev_err(&client->dev,
 				"prim-ser already exists\n");
 				return -EEXIST;
@@ -509,7 +674,7 @@ static int max9295_probe(struct i2c_client *client,
 			return -EINVAL;
 		}
 
-		prim_priv__ = priv;
+		prim_priv__[priv->prim_id] = priv;
 	}
 
 	dev_set_drvdata(&client->dev, priv);
@@ -535,7 +700,8 @@ static int max9295_remove(struct i2c_client *client)
 }
 
 static const struct i2c_device_id max9295_id[] = {
-	{ "max9295", 0 },
+	{ "max9295_0", 0 },
+	{ "max9295_1", 1 },
 	{ },
 };
 
diff --git a/kernel/nvidia/drivers/media/i2c/max9296.c b/kernel/nvidia/drivers/media/i2c/max9296.c
index 5f48c9b..e0e1b86 100644
--- a/kernel/nvidia/drivers/media/i2c/max9296.c
+++ b/kernel/nvidia/drivers/media/i2c/max9296.c
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-
+// #define DEBUG 1
 #include <linux/gpio.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -44,6 +44,8 @@
 #define MAX9296_PIPE_X_DST_1_MAP_ADDR 0x410
 #define MAX9296_PIPE_X_SRC_2_MAP_ADDR 0x411
 #define MAX9296_PIPE_X_DST_2_MAP_ADDR 0x412
+#define MAX9296_PIPE_X_SRC_3_MAP_ADDR 0x413
+#define MAX9296_PIPE_X_DST_3_MAP_ADDR 0x414
 
 #define MAX9296_PIPE_X_ST_SEL_ADDR 0x50
 
@@ -123,9 +125,25 @@ struct max9296 {
 	u8 lane_mp2;
 	int reset_gpio;
 	int pw_ref;
+	int init_flag;
 	struct regulator *vdd_cam_1v2;
 };
 
+static inline int max9296_read_reg(struct device *dev,
+		u16 addr, u8 *val)
+{
+	struct max9296 *priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	priv = dev_get_drvdata(dev);
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
 static int max9296_write_reg(struct device *dev,
 	u16 addr, u8 val)
 {
@@ -139,6 +157,10 @@ static int max9296_write_reg(struct device *dev,
 		dev_err(dev,
 		"%s:i2c write failed, 0x%x = %x\n",
 		__func__, addr, val);
+	else
+		dev_dbg(dev,
+		"%s:i2c write, 0x%x = %x\n",
+		__func__, addr, val);
 
 	/* delay before next i2c command as required for SERDES link */
 	usleep_range(100, 110);
@@ -206,6 +228,7 @@ static void max9296_reset_ctx(struct max9296 *priv)
 	priv->num_src_found = 0;
 	priv->src_link = 0;
 	priv->splitter_enabled = false;
+	priv->init_flag = false;
 	max9296_pipes_reset(priv);
 	for (i = 0; i < priv->num_src; i++)
 		priv->sources[i].st_enabled = false;
@@ -260,6 +283,9 @@ void max9296_power_off(struct device *dev)
 	mutex_lock(&priv->lock);
 	priv->pw_ref--;
 
+	if (priv->pw_ref < 0)
+		priv->pw_ref = 0;
+
 	if (priv->pw_ref == 0) {
 		/* enter reset mode: XCLR */
 		usleep_range(1, 2);
@@ -346,7 +372,7 @@ int max9296_setup_control(struct device *dev, struct device *s_dev)
 
 	/* Enable splitter mode */
 	if ((priv->max_src > 1U) &&
-		(priv->num_src_found > 0U) &&
+		(priv->num_src_found > 1U) &&
 		(priv->splitter_enabled == false)) {
 		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x03);
 		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x23);
@@ -446,7 +472,7 @@ int max9296_sdev_register(struct device *dev, struct gmsl_link_ctx *g_ctx)
 			priv->sources[i].g_ctx->serdes_csi_link) {
 			dev_err(dev,
 				"%s: serdes csi link is in use\n", __func__);
-			err = -EINVAL;
+			err = 0;
 			goto error;
 		}
 		/*
@@ -780,6 +806,214 @@ ret:
 }
 EXPORT_SYMBOL(max9296_setup_streaming);
 
+static int max9296_set_registers(struct device *dev, struct reg_pair *map,
+				 u32 count)
+{
+	int err = 0;
+	u32 j = 0;
+
+	for (j = 0; j < count; j++) {
+		err = max9296_write_reg(dev,
+			map[j].addr, map[j].val);
+		if (err != 0)
+			break;
+	}
+
+	return err;
+}
+
+int max9296_get_available_pipe_id(struct device *dev, int vc_id)
+{
+	int i;
+	int pipe_id = -ENOMEM;
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	for (i = 0; i < MAX9296_MAX_PIPES; i++) {
+		if (i == vc_id && !priv->pipe[i].st_count) {
+			priv->pipe[i].st_count++;
+			pipe_id = i;
+			break;
+		}
+	}
+	mutex_unlock(&priv->lock);
+
+	return pipe_id;
+}
+EXPORT_SYMBOL(max9296_get_available_pipe_id);
+
+int max9296_release_pipe(struct device *dev, int pipe_id)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	if (pipe_id < 0 || pipe_id >= MAX9296_MAX_PIPES)
+		return -EINVAL;
+
+	mutex_lock(&priv->lock);
+	priv->pipe[pipe_id].st_count = 0;
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(max9296_release_pipe);
+
+void max9296_reset_oneshot(struct device *dev)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	mutex_lock(&priv->lock);
+	if (priv->splitter_enabled) {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x03);
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x23);
+	} else {
+		max9296_write_reg(dev, MAX9296_CTRL0_ADDR, 0x31);
+	}
+	/* delay to settle link */
+	msleep(500);
+	mutex_unlock(&priv->lock);
+}
+EXPORT_SYMBOL(max9296_reset_oneshot);
+
+static int __max9296_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+			      u8 data_type2, u32 vc_id)
+{
+	int err = 0;
+	int i = 0;
+	u8 en_mapping_num = 0x0F;
+	u8 all_mapping_phy = 0x55;
+	struct reg_pair map_pipe_opt[] = {
+		{0x1458, 0x28}, // PHY A Optimization
+		{0x1459, 0x68}, // PHY A Optimization
+		{0x1558, 0x28}, // PHY B Optimization
+		{0x1559, 0x68}, // PHY B Optimization
+		// 4 lanes on port A, write 0x50 for 2 lanes
+		{MAX9296_LANE_CTRL1_ADDR, 0x50},
+		// 1500Mbps/lane on port A
+		{MAX9296_PHY1_CLK_ADDR, 0x2F},
+		// Do not un-double 8bpp (Un-double 8bpp data)
+		//{0x031C, 0x00},
+		// Do not un-double 8bpp
+		//{0x031F, 0x00},
+		// 0x02: ALT_MEM_MAP8, 0x10: ALT2_MEM_MAP8
+		{0x0473, 0x10},
+	};
+	struct reg_pair map_pipe_control[] = {
+		// Enable 4 mappings for Pipe X
+		{MAX9296_TX11_PIPE_X_EN_ADDR, 0x0F},
+		// Map data_type1 on vc_id
+		{MAX9296_PIPE_X_SRC_0_MAP_ADDR, 0x1E},
+		{MAX9296_PIPE_X_DST_0_MAP_ADDR, 0x1E},
+		// Map frame_start on vc_id
+		{MAX9296_PIPE_X_SRC_1_MAP_ADDR, 0x00},
+		{MAX9296_PIPE_X_DST_1_MAP_ADDR, 0x00},
+		// Map frame end on vc_id
+		{MAX9296_PIPE_X_SRC_2_MAP_ADDR, 0x01},
+		{MAX9296_PIPE_X_DST_2_MAP_ADDR, 0x01},
+		// Map data_type2 on vc_id
+		{MAX9296_PIPE_X_SRC_3_MAP_ADDR, 0x12},
+		{MAX9296_PIPE_X_DST_3_MAP_ADDR, 0x12},
+		// All mappings to PHY1 (master for port A)
+		{MAX9296_TX45_PIPE_X_DST_CTRL_ADDR, 0x55},
+		// SEQ_MISS_EN: Disabled / DIS_PKT_DET: Disabled
+		{0x0100, 0x23}, // pipe X
+	};
+
+	for (i = 0; i < 10; i++) {
+		map_pipe_control[i].addr += 0x40 * pipe_id;
+	}
+	map_pipe_control[10].addr += 0x12 * pipe_id;
+
+	if (data_type2 == 0x0) {
+		en_mapping_num = 0x07;
+		all_mapping_phy = 0x15;
+	}
+	map_pipe_control[0].val = en_mapping_num;
+	map_pipe_control[1].val = (vc_id << 6) | data_type1;
+	map_pipe_control[2].val = (vc_id << 6) | data_type1;
+	map_pipe_control[3].val = (vc_id << 6) | 0x00;
+	map_pipe_control[4].val = (vc_id << 6) | 0x00;
+	map_pipe_control[5].val = (vc_id << 6) | 0x01;
+	map_pipe_control[6].val = (vc_id << 6) | 0x01;
+	map_pipe_control[7].val = (vc_id << 6) | data_type2;
+	map_pipe_control[8].val = (vc_id << 6) | data_type2;
+	map_pipe_control[9].val = all_mapping_phy;
+	map_pipe_control[10].val = 0x23;
+
+	err |= max9296_set_registers(dev, map_pipe_control,
+				     ARRAY_SIZE(map_pipe_control));
+
+	err |= max9296_set_registers(dev, map_pipe_opt,
+				     ARRAY_SIZE(map_pipe_opt));
+
+	return err;
+}
+int max9296_init_settings(struct device *dev)
+{
+	int err = 0;
+	int i;
+	struct max9296 *priv = dev_get_drvdata(dev);
+
+	static struct reg_pair map_depth_trigger[] = {
+		// For GMSL_10CH_first board (isx031 and d457 use one trig gpio)
+		{0x02C2, 0x82}, // #MFP6  
+		{0x02C3, 0x1F},
+		// For GMSL_10CH_SCH_V1.1 version (isx031 and d457 use diffrent trig gpio )
+		// {0x02C5, 0x82}, #MFP7
+		// {0x02C6, 0x1F},
+	};
+
+	static struct reg_pair map_rgb_trigger[] = {
+		{0x02CB, 0x82}, // #MFP9
+		{0x02CC, 0x1B},
+	};
+
+	mutex_lock(&priv->lock);
+
+	if(priv->init_flag == false){
+		for (i = 0; i < MAX9296_MAX_PIPES; i++)
+			err |= __max9296_set_pipe(dev, i, GMSL_CSI_DT_YUV422_8,
+						GMSL_CSI_DT_EMBED, i);
+		priv->init_flag = true;
+	}
+
+	// Trigger Depth
+	err |= max9296_set_registers(dev, map_depth_trigger,
+				     ARRAY_SIZE(map_depth_trigger));
+	// Trigger RGB
+	err |= max9296_set_registers(dev, map_rgb_trigger,
+				     ARRAY_SIZE(map_rgb_trigger));
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_init_settings);
+
+int max9296_set_pipe(struct device *dev, int pipe_id,
+		     u8 data_type1, u8 data_type2, u32 vc_id)
+{
+	struct max9296 *priv = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (pipe_id > (MAX9296_MAX_PIPES - 1)) {
+		dev_info(dev, "%s, input pipe_id: %d exceed max9296 max pipes\n",
+			 __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s pipe_id %d, data_type1 %u, data_type2 %u, vc_id %u\n",
+		__func__, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_lock(&priv->lock);
+
+	err = __max9296_set_pipe(dev, pipe_id, data_type1, data_type2, vc_id);
+
+	mutex_unlock(&priv->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(max9296_set_pipe);
+
 static const struct of_device_id max9296_of_match[] = {
 	{ .compatible = "maxim,max9296", },
 	{ },
@@ -856,7 +1090,7 @@ static int max9296_parse_dt(struct max9296 *priv,
 static struct regmap_config max9296_regmap_config = {
 	.reg_bits = 16,
 	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
+	.cache_type = REGCACHE_NONE,
 };
 
 static int max9296_probe(struct i2c_client *client,
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c b/kernel/nvidia/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c
index c340a9c..a6e3eca 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/fusa-capture/capture-vi-channel.c
@@ -271,7 +271,7 @@ int vi_channel_close_ex(
 
 	mutex_lock(&chan_drv->lock);
 
-	WARN_ON(rcu_access_pointer(chan_drv->channels[channel]) != chan);
+	//WARN_ON(rcu_access_pointer(chan_drv->channels[channel]) != chan);
 	RCU_INIT_POINTER(chan_drv->channels[channel], NULL);
 
 	mutex_unlock(&chan_drv->lock);
@@ -326,7 +326,8 @@ static int vi_channel_release(
 	struct tegra_vi_channel *chan = file->private_data;
 	unsigned int channel = iminor(inode);
 
-	vi_channel_close_ex(channel, chan);
+	if(chan != NULL)
+		vi_channel_close_ex(channel, chan);
 
 	return 0;
 }
@@ -449,8 +450,10 @@ static long vi_channel_ioctl(
 		if (err < 0) {
 			dev_err(chan->dev,
 				"%s: memory setup failed\n", __func__);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) {
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			return -EFAULT;
 		}
 
@@ -461,8 +464,10 @@ static long vi_channel_ioctl(
 				"%s: descriptor buffer is too small for given queue depth\n",
 				__func__);
 			capture_common_unpin_memory(&capture->requests);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) {
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			return -ENOMEM;
 		}
 
@@ -471,8 +476,10 @@ static long vi_channel_ioctl(
 		if (err < 0) {
 			dev_err(chan->dev, "vi capture setup failed\n");
 			capture_common_unpin_memory(&capture->requests);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) {
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			return err;
 		}
 		break;
@@ -510,8 +517,10 @@ static long vi_channel_ioctl(
 			for (i = 0; i < capture->queue_depth; i++)
 				vi_capture_request_unpin(chan, i);
 			capture_common_unpin_memory(&capture->requests);
-			destroy_buffer_table(capture->buf_ctx);
-			capture->buf_ctx = NULL;
+			if(capture->buf_ctx != NULL) {
+				destroy_buffer_table(capture->buf_ctx);
+				capture->buf_ctx = NULL;
+			}
 			vfree(capture->unpins_list);
 			capture->unpins_list = NULL;
 		}
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c b/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
index 038c312..e7fc3d8 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
@@ -282,6 +282,10 @@ static int extract_pixel_format(
 		*format = V4L2_PIX_FMT_UYVY;
 	else if (strncmp(pixel_t, "yuv_vyuy16", size) == 0)
 		*format = V4L2_PIX_FMT_VYUY;
+	else if (strncmp(pixel_t, "grey_y8", size) == 0)
+		*format = V4L2_PIX_FMT_GREY;
+	else if (strncmp(pixel_t, "grey_y16", size) == 0)
+		*format = V4L2_PIX_FMT_Y16;
 	else {
 		pr_err("%s: Need to extend format%s\n", __func__, pixel_t);
 		return -EINVAL;
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c
index 03de768..5801984 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/channel.c
@@ -215,7 +215,12 @@ static void tegra_channel_fmt_align(struct tegra_channel *chan,
 	 * different. Aligned width also may force a sensor mode change other
 	 * than the requested one
 	 */
-	*height = clamp(*height, TEGRA_MIN_HEIGHT, TEGRA_MAX_HEIGHT);
+    /* For D4XX IMU, the total size of one frame is 32 while the width:height
+     * should be set to 32:1. Therefore, ignored the clamping on height here by
+     * replacing TEGRA_MIN_HEIGHT with 1U ((unsigned int) 1).
+     */
+    *height = clamp(*height, 1U /*TEGRA_MIN_HEIGHT*/, TEGRA_MAX_HEIGHT);
+
 
 	/* Clamp the requested bytes per line value. If the maximum bytes per
 	 * line value is zero, the module doesn't support user configurable line
@@ -1044,7 +1049,8 @@ tegra_channel_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 
 	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 	cap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;
-	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_META_CAPTURE;
 
 	strlcpy(cap->driver, "tegra-video", sizeof(cap->driver));
 	strlcpy(cap->card, chan->video->name, sizeof(cap->card));
@@ -2072,6 +2078,15 @@ __tegra_channel_try_format(struct tegra_channel *chan,
 	v4l2_fill_mbus_format(&fmt.format, pix, vfmt->code);
 
 	ret = v4l2_subdev_call(sd, pad, set_fmt, &cfg, &fmt);
+	/* if set_fmt not found target format and specify the default one, update
+	* pix->pixelformat and vfmt to keep aligned with format set by set_fmt
+	*/
+	if (!ret && fmt.format.code != vfmt->code) {
+		int idx = tegra_core_get_idx_by_code(chan, fmt.format.code, 0);
+		pix->pixelformat = tegra_core_get_fourcc_by_idx(chan, idx);
+		vfmt = tegra_core_get_format_by_fourcc(chan, pix->pixelformat);
+	}
+
 	if (ret == -ENOIOCTLCMD)
 		return -ENOTTY;
 
@@ -2237,6 +2252,62 @@ static long tegra_channel_default_ioctl(struct file *file, void *fh,
 	return ret;
 }
 
+static int
+__tegra_channel_get_parm(struct tegra_channel *chan,
+                        struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+	struct v4l2_subdev_frame_interval interval;
+
+	/* dmipx: fixing G_PARM EINVAL error */
+//	ret = v4l2_subdev_call(sd, video, g_frame_interval, &interval);
+	ret = sd->ops->video->g_frame_interval(sd, &interval);
+
+	a->parm.capture.timeperframe.numerator = interval.interval.numerator;
+	a->parm.capture.timeperframe.denominator = interval.interval.denominator;
+
+	return ret;
+}
+
+static int tegra_channel_get_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	a->parm.capture.timeperframe.numerator = 1;
+	a->parm.capture.timeperframe.denominator = 12;
+
+	return __tegra_channel_get_parm(chan, a);
+}
+
+static int
+__tegra_channel_set_parm(struct tegra_channel *chan,
+                        struct v4l2_streamparm *a)
+{
+	struct v4l2_subdev *sd = chan->subdev_on_csi;
+	int ret = 0;
+
+	struct v4l2_subdev_frame_interval interval;
+	interval.pad = 1;
+	interval.interval.numerator = a->parm.capture.timeperframe.numerator;
+	interval.interval.denominator = a->parm.capture.timeperframe.denominator;
+
+	ret = v4l2_subdev_call(sd, video, s_frame_interval, &interval);
+	if (ret == -ENOIOCTLCMD)
+			return -ENOTTY;
+
+	return ret;
+}
+static int tegra_channel_set_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
+{
+	struct tegra_channel *chan = video_drvdata(file);
+
+	if (vb2_is_busy(&chan->queue))
+			return -EBUSY;
+
+	return __tegra_channel_set_parm(chan, a);
+}
+
 #ifdef CONFIG_COMPAT
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
 static long tegra_channel_compat_ioctl(struct file *filp,
@@ -2293,6 +2364,9 @@ static const struct v4l2_ioctl_ops tegra_channel_ioctl_ops = {
 	.vidioc_s_input			= tegra_channel_s_input,
 	.vidioc_log_status		= tegra_channel_log_status,
 	.vidioc_default			= tegra_channel_default_ioctl,
+	.vidioc_g_parm			= tegra_channel_get_parm,
+	.vidioc_s_parm			= tegra_channel_set_parm,
+
 };
 
 static int tegra_channel_close(struct file *fp);
@@ -2429,6 +2503,331 @@ static int tegra_channel_csi_init(struct tegra_channel *chan)
 	return ret;
 }
 
+static int tegra_metadata_open(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret;
+
+	mutex_lock(&chan->embedded.lock);
+	ret = v4l2_fh_open(fp);
+	mutex_unlock(&chan->embedded.lock);
+
+	return ret;
+}
+
+static int tegra_metadata_close(struct file *fp)
+{
+	struct video_device *vdev = video_devdata(fp);
+	struct tegra_channel *chan = video_get_drvdata(vdev);
+	int ret = _vb2_fop_release(fp, &chan->embedded.lock);
+
+	return ret;
+}
+
+static const struct v4l2_file_operations tegra_metadata_fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.open           = tegra_metadata_open,
+	.release        = tegra_metadata_close,
+	.read           = vb2_fop_read,
+	.poll           = vb2_fop_poll,
+	.mmap           = vb2_fop_mmap,
+};
+
+static int tegra_metadata_querycap(struct file *file, void *fh,
+                                 struct v4l2_capability *cap)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct tegra_channel *chan = video_drvdata(file);
+
+	/* FIXME: why do Device Caps show V4L2_CAP_EXT_PIX_FORMAT? */
+	cap->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |
+			V4L2_CAP_EXT_PIX_FORMAT | V4L2_CAP_VIDEO_CAPTURE;
+
+	strlcpy(cap->driver, "tegra-embedded", sizeof(cap->driver));
+	strlcpy(cap->card, vfh->vdev->name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",
+			dev_name(chan->vi->dev), chan->port[0]);
+
+	return 0;
+}
+
+static int tegra_metadata_enum_format(struct file *file, void *fh,
+                                     struct v4l2_fmtdesc *f)
+{
+	if (f->index)
+		return -EINVAL;
+
+	f->pixelformat = V4L2_META_FMT_D4XX;
+	strlcpy(f->description, "D4XX metadata format", sizeof(f->description));
+
+	return 0;
+}
+
+static int tegra_metadata_get_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct v4l2_meta_format *fmt = &format->fmt.meta;
+
+	if (format->type != vfh->vdev->queue->type)
+		return -EINVAL;
+
+	memset(fmt, 0, sizeof(*fmt));
+
+	fmt->dataformat = V4L2_META_FMT_D4XX;
+	fmt->buffersize = 255;
+
+	return 0;
+}
+static int tegra_metadata_set_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+   return 0;
+}
+
+static int tegra_metadata_try_format(struct file *file, void *fh,
+                                    struct v4l2_format *format)
+{
+    return 0;
+}
+static const struct v4l2_ioctl_ops tegra_metadata_ioctl_ops = {
+	.vidioc_querycap                = tegra_metadata_querycap,
+	.vidioc_enum_fmt_meta_cap       = tegra_metadata_enum_format,
+	.vidioc_g_fmt_meta_cap          = tegra_metadata_get_format,
+	.vidioc_s_fmt_meta_cap          = tegra_metadata_set_format,
+	.vidioc_try_fmt_meta_cap        = tegra_metadata_try_format,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+};
+
+static int tegra_metadata_queue_setup(struct vb2_queue *vq,
+                    unsigned int *nbuffers, unsigned int *nplanes,
+                    unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+
+	if (*nplanes) {
+		if (*nplanes != 1)
+			return -EINVAL;
+
+		if (sizes[0] < 255)
+			return -EINVAL;
+
+		return 0;
+	}
+
+	*nplanes = 1;
+	sizes[0] = 255;
+	alloc_devs[0] = chan->vi->dev;
+
+
+	return 0;
+}
+
+static int tegra_metadata_buffer_prepare(struct vb2_buffer *vb)
+{
+	if (vb->num_planes != 1)
+		return -EINVAL;
+
+	if (vb2_plane_size(vb, 0) < 255)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void tegra_metadata_buffer_queue(struct vb2_buffer *vb)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vb->vb2_queue);
+
+	spin_lock(&chan->embedded.spin_lock);
+	if (chan->embedded.num_buffers < 16) {
+		chan->embedded.buffers[chan->embedded.head] = vb;
+		chan->embedded.head++;
+		if (chan->embedded.head > 15)
+			chan->embedded.head = chan->embedded.head - 16;
+		chan->embedded.num_buffers++;
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+}
+
+static int tegra_metadata_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	return 0;
+}
+
+static void tegra_metadata_stop_streaming(struct vb2_queue *vq)
+{
+	struct tegra_channel *chan = vb2_get_drv_priv(vq);
+	int i = 0;
+
+	spin_lock(&chan->embedded.spin_lock);
+	for (i = 0; i < chan->embedded.num_buffers; i++) {
+		struct vb2_buffer *evb;
+		evb = chan->embedded.buffers[chan->embedded.tail];
+		chan->embedded.buffers[chan->embedded.tail] = NULL;
+		chan->embedded.tail++;
+		if (chan->embedded.tail > 15)
+			chan->embedded.tail = chan->embedded.tail - 16;
+		vb2_buffer_done(evb, VB2_BUF_STATE_ERROR);
+	}
+	spin_unlock(&chan->embedded.spin_lock);
+
+	chan->embedded.head = 0;
+	chan->embedded.tail = 0;;
+	chan->embedded.num_buffers = 0;
+}
+
+static const struct vb2_ops tegra_metadata_qops = {
+	.queue_setup            = tegra_metadata_queue_setup,
+	.buf_prepare            = tegra_metadata_buffer_prepare,
+	.buf_queue              = tegra_metadata_buffer_queue,
+	.wait_prepare           = vb2_ops_wait_prepare,
+	.wait_finish            = vb2_ops_wait_finish,
+	.start_streaming        = tegra_metadata_start_streaming,
+	.stop_streaming         = tegra_metadata_stop_streaming,
+};
+
+int tegra_channel_init_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct tegra_mc_vi *vi = chan->vi;
+	int ret;
+
+	mutex_init(&chan->embedded.lock);
+	spin_lock_init(&chan->embedded.spin_lock);
+
+	video = chan->embedded.video = video_device_alloc();
+	chan->embedded.pad.flags = MEDIA_PAD_FL_SINK;
+
+	ret = tegra_media_entity_init(&video->entity, 1,
+									&chan->embedded.pad, false, false);
+	if (ret < 0) {
+		video_device_release(video);
+		dev_err(vi->dev, "%s(): metadata entity init: %d\n",
+				__func__, ret);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_handler_init(&chan->embedded.ctrl_handler,
+									MAX_CID_CONTROLS);
+	if (chan->embedded.ctrl_handler.error) {
+		dev_err(&video->dev, "failed to init control handler\n");
+		return ret;
+	}
+
+	video->fops = &tegra_metadata_fops;
+	video->v4l2_dev = &vi->v4l2_dev;
+	video->queue = queue;
+	snprintf(video->name, sizeof(video->name), "%s-metadata-%u",
+			dev_name(vi->dev), chan->port[0]);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	video->vfl_type = VFL_TYPE_GRABBER;
+#else
+	video->vfl_type = VFL_TYPE_VIDEO;
+	video->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING;
+#endif
+	video->vfl_dir = VFL_DIR_RX;
+	video->release = video_device_release_empty;
+	video->ioctl_ops = &tegra_metadata_ioctl_ops;
+	video->ctrl_handler = &chan->embedded.ctrl_handler;
+	video->lock = &chan->embedded.lock;
+
+	video_set_drvdata(video, chan);
+
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+	ret = tegra_vb2_dma_init(vi->dev, &chan->embedded.alloc_ctx,
+					SZ_64K, &vi->vb2_dma_alloc_refcnt);
+	if (ret < 0)
+		goto ctx_alloc_error;
+
+#endif
+//#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	/* get the buffers queue... */
+//     chan->embedded.alloc_ctx = vb2_dma_contig_init_ctx(vi->dev);
+//     if (IS_ERR(chan->embedded.alloc_ctx)) {
+//             dev_err(vi->dev, "%s(): vb2 buffer init: %ld\n", __func__,
+//                     PTR_ERR(chan->embedded.alloc_ctx));
+//             goto ctx_alloc_error;
+//     }
+//#endif
+
+	queue->type = V4L2_BUF_TYPE_META_CAPTURE;
+	queue->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ | VB2_USERPTR;
+	queue->lock = &chan->embedded.lock;
+	queue->drv_priv = chan;
+	queue->buf_struct_size = sizeof(struct tegra_channel_buffer);
+	queue->ops = &tegra_metadata_qops;
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	queue->mem_ops = &vb2_dma_contig_memops;
+#endif
+	queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC |
+			V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	ret = vb2_queue_init(queue);
+	if (ret < 0) {
+		dev_err(vi->dev, "%s(): metadata queue initialize: %d\n",
+				__func__, ret);
+		goto vb2_queue_error;
+	}
+
+	return 0;
+
+vb2_queue_error:
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+	tegra_vb2_dma_cleanup(vi->dev, chan->embedded.alloc_ctx,
+			&vi->vb2_dma_alloc_refcnt);
+ctx_alloc_error:
+#endif
+	media_entity_cleanup(&video->entity);
+
+	return ret;
+}
+
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan)
+{
+	struct video_device *video = chan->embedded.video;
+	struct vb2_queue *queue = &chan->embedded.queue;
+	struct device *vi_unit_dev = tegra_channel_get_vi_unit(chan);
+
+	if (!video)
+		return -EINVAL;
+
+	video_unregister_device(video);
+
+	/* release embedded data buffer */
+	if (chan->emb_buf_size > 0) {
+		dma_free_coherent(vi_unit_dev,
+				chan->emb_buf_size,
+				chan->emb_buf_addr, chan->emb_buf);
+		chan->emb_buf_size = 0;
+		vb2_queue_release(queue);
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+		tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+						&chan->vi->vb2_dma_alloc_refcnt);
+#endif
+	}
+
+	v4l2_ctrl_handler_free(&chan->embedded.ctrl_handler);
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&video->entity);
+#endif
+
+	video_device_release(video);
+
+	return 0;
+}
+
 int tegra_channel_init_video(struct tegra_channel *chan)
 {
 	struct tegra_mc_vi *vi = chan->vi;
@@ -2617,6 +3016,13 @@ int tegra_channel_cleanup(struct tegra_channel *chan)
 			chan->emb_buf_size,
 			chan->emb_buf_addr, chan->emb_buf);
 		chan->emb_buf_size = 0;
+		vb2_queue_release(&chan->embedded.queue);
+#if defined(CONFIG_VIDEOBUF2_DMA_CONTIG)
+               tegra_vb2_dma_cleanup(vi_unit_dev, chan->embedded.alloc_ctx,
+                               &chan->vi->vb2_dma_alloc_refcnt);
+               //vb2_dma_contig_cleanup_ctx(chan->embedded.alloc_ctx);
+#endif
+		media_entity_cleanup(&chan->embedded.video->entity);
 	}
 
 	tegra_channel_dealloc_buffer_queue(chan);
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c
index cb09744..5fd45cf 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/graph.c
@@ -373,6 +373,11 @@ static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
 	struct tegra_channel *chan =
 		container_of(notifier, struct tegra_channel, notifier);
 	struct tegra_vi_graph_entity *entity;
+	struct camera_common_data *s_data;
+	struct device_node *node;
+	struct sensor_mode_properties *sensor_mode = NULL;
+	int idx;
+
 	int ret;
 
 	dev_dbg(chan->vi->dev, "notify complete, all subdevs registered\n");
@@ -401,26 +406,60 @@ static int tegra_vi_graph_notify_complete(struct v4l2_async_notifier *notifier)
 		if (entity->entity != NULL) {
 			ret = tegra_vi_graph_build_one(chan, entity);
 			if (ret < 0)
-				goto graph_error;
+				goto link_error;
 		}
 	}
 
 	/* Create links for channels */
 	ret = tegra_vi_graph_build_links(chan);
 	if (ret < 0)
-		goto graph_error;
+		goto link_error;
+
+	/* Init embedded channel only if embedded is set in DT*/
+	s_data = to_camera_common_data(chan->subdev_on_csi->dev);
+	node = chan->subdev_on_csi->dev->of_node;
+	if (s_data && node) {
+		idx = s_data->mode_prop_idx;
+		if (idx < s_data->sensor_props.num_modes)
+			sensor_mode = &s_data->sensor_props.sensor_modes[idx];
+	}
+
+	if (sensor_mode &&
+		sensor_mode->image_properties.embedded_metadata_height > 0) {
+		ret = tegra_channel_init_video_embedded(chan);
+		if (ret < 0) {
+			dev_err(chan->vi->dev,
+					"failed to initialize embedded channel\n");
+			goto register_embedded_device_error;
+		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
+	ret = video_register_device(chan->embedded.video, VFL_TYPE_GRABBER, -1);
+#else
+	ret = video_register_device(chan->embedded.video, VFL_TYPE_VIDEO, -1);
+#endif
+		if (ret < 0) {
+			dev_err(&chan->video->dev, "failed to register embedded %s: %d\n",
+					chan->embedded.video->name, ret);
+			goto register_embedded_device_error;
+		}
+	}
+
 
 	ret = v4l2_device_register_subdev_nodes(&chan->vi->v4l2_dev);
 	if (ret < 0) {
 		dev_err(chan->vi->dev, "failed to register subdev nodes\n");
-		goto graph_error;
+		goto register_nodes_error;
 	}
 
 	chan->link_status++;
 
 	return 0;
 
-graph_error:
+register_nodes_error:
+	video_unregister_device(chan->embedded.video);
+register_embedded_device_error:
+	tegra_vi_graph_remove_links(chan);
+link_error:
 	video_unregister_device(chan->video);
 register_device_error:
 	video_device_release(chan->video);
@@ -482,6 +521,7 @@ static void tegra_vi_graph_notify_unbind(struct v4l2_async_notifier *notifier,
 
 	/* cleanup for complete */
 	if (chan->link_status) {
+		tegra_channel_cleanup_video_embedded(chan);
 		tegra_vi_graph_remove_links(chan);
 		tegra_channel_cleanup_video(chan);
 		chan->link_status--;
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c
index bed3e92..54b60f3 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/mc_common.c
@@ -24,6 +24,10 @@
 #include <media/vi.h>
 #include <media/vi2_registers.h>
 
+#include <media/gmsl-link.h>
+#include <media/max9296.h>
+#include <media/max9295.h>
+
 #include "dev.h"
 #include "host1x/host1x.h"
 
@@ -166,6 +170,11 @@ static int vi_parse_dt(struct tegra_mc_vi *vi, struct platform_device *dev)
 	int i;
 	struct tegra_channel *item;
 	struct device_node *node = dev->dev.of_node;
+	struct device_node *dser_node = NULL;
+	struct i2c_client *dser_i2c = NULL;
+	struct device_node *ser_node = NULL;
+	struct i2c_client *ser_i2c = NULL;
+	dev_info(&dev->dev, "%s, parse max9295/max9296\n", __func__);
 
 	err = of_property_read_u32(node, "num-channels", &num_channels);
 	if (err) {
@@ -173,6 +182,29 @@ static int vi_parse_dt(struct tegra_mc_vi *vi, struct platform_device *dev)
 			"Failed to find num of channels, set to 0\n");
 		num_channels = 0;
 	}
+
+	vi->dser_dev = NULL;
+	dser_node = of_parse_phandle(node, "nvidia,gmsl-dser-device", 0);
+	if (dser_node) {
+		dser_i2c = of_find_i2c_device_by_node(dser_node);
+		of_node_put(dser_node);
+		if (dser_i2c) {
+			dev_info(&dev->dev, "dser_i2c->addr 0x%x", dser_i2c->addr);
+			vi->dser_dev = &dser_i2c->dev;
+		}
+	}
+
+	vi->ser_dev = NULL;
+	ser_node = of_parse_phandle(node, "nvidia,gmsl-ser-device", 0);
+	if (ser_node) {
+		ser_i2c = of_find_i2c_device_by_node(ser_node);
+		of_node_put(ser_node);
+		if (ser_i2c) {
+			dev_info(&dev->dev, "ser_i2c->addr 0x%x", ser_i2c->addr);
+			vi->ser_dev = &ser_i2c->dev;
+		}
+	}
+
 	vi->num_channels = num_channels;
 	for (i = 0; i < num_channels; i++) {
 		item = devm_kzalloc(vi->dev, sizeof(*item), GFP_KERNEL);
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
index daeaf45..e137c8c 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
@@ -88,6 +88,9 @@ static const struct tegra_video_format vi4_video_formats[] = {
 	/* RAW 7: TODO */
 
 	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_L8,
+				RAW8, GREY, "Greyscale 8"),
+
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_L8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_L8,
@@ -127,22 +130,22 @@ static const struct tegra_video_format vi4_video_formats[] = {
 				RAW14, SBGGR14, "BGBG.. GRGR.."),
 
 	/* RGB888 */
-	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
-				RGB888, ABGR32, "BGRA-8-8-8-8"),
+	// TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+	// 			RGB888, ABGR32, "BGRA-8-8-8-8"),
 	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X32_PADHI, 4, 1, T_A8B8G8R8,
 				RGB888, RGB32, "RGB-8-8-8-8"),
 
 	/* YUV422 */
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
-				YUV422_8, UYVY, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
-				YUV422_8, VYUY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+	// 			YUV422_8, UYVY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+	// 			YUV422_8, VYUY, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
 				YUV422_8, YUYV, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
-				YUV422_8, NV16, "NV16"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+	// 			YUV422_8, NV16, "NV16"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
@@ -151,6 +154,19 @@ static const struct tegra_video_format vi4_video_formats[] = {
 				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, Z16, "Depth 16"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, Y8I, "Y8I 16"),
+	// TODO: RealSesne calibration format Y12I should be 3-byte,
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4]
+	// but, currently, it's 4-byte, one byte is added as alignment
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4] | ALIGN[7:0]
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+				RGB888, Y12I, "Y12I 24"),
+
+
 };
 
 #endif
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
index 467fbd3..e9540e2 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
@@ -333,7 +333,7 @@ static int tegra_channel_capture_setup(struct tegra_channel *chan, unsigned int
 
 	setup.queue_depth = chan->capture_queue_depth;
 
-	trace_tegra_channel_capture_setup(chan, 0);
+	trace_tegra_channel_capture_setup(chan, vi_port);
 
 	chan->request[vi_port] = dma_alloc_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
 					setup.queue_depth * setup.request_size,
@@ -438,12 +438,45 @@ static void vi5_release_buffer(struct tegra_channel *chan,
 	struct tegra_channel_buffer *buf)
 {
 	struct vb2_v4l2_buffer *vbuf = &buf->buf;
+	struct vb2_buffer *evb;
+	struct vb2_v4l2_buffer *evbuf;
 
 	vbuf->sequence = chan->sequence++;
 	vbuf->field = V4L2_FIELD_NONE;
 	vb2_set_plane_payload(&vbuf->vb2_buf, 0, chan->format.sizeimage);
 
+	evb = NULL;
+	if ((chan->embedded_data_height == 1)) {
+		void* frm_buffer;
+		spin_lock(&chan->embedded.spin_lock);
+		if (0 < chan->embedded.num_buffers ){
+			evb = chan->embedded.buffers[chan->embedded.tail];
+			chan->embedded.buffers[chan->embedded.tail] = NULL;
+			chan->embedded.tail++;
+			if (chan->embedded.tail > 15)
+					chan->embedded.tail = chan->embedded.tail - 16;
+			chan->embedded.num_buffers--;
+		}
+		spin_unlock(&chan->embedded.spin_lock);
+
+		if(evb) {
+			frm_buffer = vb2_plane_vaddr(evb, 0);
+			if (frm_buffer != NULL) {
+				memcpy(frm_buffer,chan->emb_buf_addr, 255);
+			}
+		}
+	}
+
 	vb2_buffer_done(&vbuf->vb2_buf, buf->vb2_state);
+	if (chan->embedded_data_height == 1 && evb) {
+		evbuf = to_vb2_v4l2_buffer(evb);
+		evbuf->sequence = vbuf->sequence;
+		/*FIXME: define 236 68 bytes metadata*/
+		vb2_set_plane_payload(evb, 0, 68);
+		evb->timestamp = vbuf->vb2_buf.timestamp;
+		vb2_buffer_done(evb, buf->vb2_state);
+	}
+
 }
 
 static void vi5_capture_enqueue(struct tegra_channel *chan,
@@ -495,6 +528,88 @@ uncorr_err:
 	spin_unlock_irqrestore(&chan->capture_state_lock, flags);
 }
 
+static inline int vi5_channel_error_recover_internal(struct tegra_channel *chan)
+{
+	int err = 0;
+	int vi_port = 0;
+	struct tegra_channel_buffer *buf;
+	struct v4l2_subdev *csi_subdev;
+	dev_dbg(chan->vi->dev, "%s() vc: %d\n", __func__, chan->virtual_channel);
+
+	/* stop vi channel */
+	for(vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+		if (err) {
+			dev_err(&chan->video->dev, "vi capture release failed\n");
+			goto done;
+		}
+		vi_channel_close_ex(chan->id, chan->tegra_vi_channel[vi_port]);
+		chan->tegra_vi_channel[vi_port] = NULL;
+	}
+
+	if (!list_empty(&chan->release)){
+			dev_warn(chan->vi->dev, "CHAN-RELEASE not EMPTY\n");
+	}
+	/* release all previously-enqueued capture buffers to temporary list */
+	while (!list_empty(&chan->capture)) {
+		buf = dequeue_buffer(chan, false);
+		if (!buf)
+			break;
+		spin_lock(&chan->release_lock);
+		list_add_tail(&buf->queue, &chan->release);
+		spin_unlock(&chan->release_lock);
+	}
+	while (!list_empty(&chan->dequeue)) {
+		buf = dequeue_dequeue_buffer(chan);
+		if (!buf)
+			break;
+		spin_lock(&chan->release_lock);
+		list_add_tail(&buf->queue, &chan->release);
+		spin_unlock(&chan->release_lock);
+	}
+
+	/* reset nvcsi stream */
+	csi_subdev = tegra_channel_find_linked_csi_subdev(chan);
+	if (!csi_subdev) {
+		dev_err(chan->vi->dev, "unable to find linked csi subdev\n");
+		err = -1;
+		goto done;
+	}
+
+	v4l2_subdev_call(csi_subdev, core, sync,
+		V4L2_SYNC_EVENT_SUBDEV_ERROR_RECOVER);
+
+	/* restart vi channel */
+	for(vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
+		chan->tegra_vi_channel[vi_port] = vi_channel_open_ex(chan->id + vi_port, false);
+		if (IS_ERR(chan->tegra_vi_channel[vi_port])) {
+			err = PTR_ERR(chan);
+			goto done;
+		}
+		err = tegra_channel_capture_setup(chan, vi_port);
+		if (err < 0)
+			goto done;
+	}
+
+	chan->sequence = 0;
+	tegra_channel_init_ring_buffer(chan);
+	chan->capture_reqs_enqueued = 0;
+
+	chan->capture_state = CAPTURE_IDLE;
+
+	while (!list_empty(&chan->release)) {
+		buf = list_entry(chan->release.next, struct tegra_channel_buffer,
+			queue);
+		list_del_init(&buf->queue);
+		buf->vb2_state = VB2_BUF_STATE_ACTIVE;
+		vi5_capture_enqueue(chan, buf);
+	}
+
+done:
+	return err;
+}
+
 static void vi5_capture_dequeue(struct tegra_channel *chan,
 	struct tegra_channel_buffer *buf)
 {
@@ -702,6 +817,9 @@ static int tegra_channel_kthread_capture_enqueue(void *data)
 		wait_event_interruptible(chan->start_wait,
 			(kthread_should_stop() || !list_empty(&chan->capture)));
 
+		dev_dbg(chan->vi->dev, "reqs:%d depth:%d\n",
+				chan->capture_reqs_enqueued, chan->capture_queue_depth);
+
 		while (!(kthread_should_stop() || list_empty(&chan->capture))) {
 			spin_lock_irqsave(&chan->capture_state_lock, flags);
 			if ((chan->capture_state == CAPTURE_ERROR)
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
index a2fefe0..3ebbc6d 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
@@ -88,6 +88,8 @@ static const struct tegra_video_format vi5_video_formats[] = {
 	/* RAW 7: TODO */
 
 	/* RAW 8 */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_R8,
+				RAW8, GREY, "Greyscale 8"),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_R8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SGRBG8_1X8, 1, 1, T_R8,
@@ -128,22 +130,22 @@ static const struct tegra_video_format vi5_video_formats[] = {
 				RAW12, SBGGR12, "BGBG.. GRGR.."),
 
 	/* RGB888 */
-	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
-				RGB888, RGBA32, "RGBA-8-8-8-8"),
+	// TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+	// 			RGB888, ABGR32, "BGRA-8-8-8-8"),
 	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X32_PADHI, 4, 1, T_A8B8G8R8,
 				RGB888, RGB32, "RGB-8-8-8-8"),
 
 	/* YUV422 */
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
-				YUV422_8, UYVY, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
-				YUV422_8, VYUY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+	// 			YUV422_8, UYVY, "YUV 4:2:2"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+	// 			YUV422_8, VYUY, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YUYV8_1X16, 2, 1, T_Y8_U8__Y8_V8,
 				YUV422_8, YUYV, "YUV 4:2:2"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_1X16, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2"),
-	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
-				YUV422_8, NV16, "NV16"),
+	// TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 1, 1, T_Y8__V8U8_N422,
+	// 			YUV422_8, NV16, "NV16"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_2X8, 2, 1, T_U8_Y8__V8_Y8,
 				YUV422_8, UYVY, "YUV 4:2:2 UYVY"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_2X8, 2, 1, T_V8_Y8__U8_Y8,
@@ -152,6 +154,18 @@ static const struct tegra_video_format vi5_video_formats[] = {
 				YUV422_8, YUYV, "YUV 4:2:2 YUYV"),
 	TEGRA_VIDEO_FORMAT(YUV422, 16, YVYU8_2X8, 2, 1, T_Y8_V8__Y8_U8,
 				YUV422_8, YVYU, "YUV 4:2:2 YVYU"),
+
+	TEGRA_VIDEO_FORMAT(YUV422, 16, UYVY8_1X16, 2, 1, T_U8_Y8__V8_Y8,
+				YUV422_8, Z16, "Depth 16"),
+	TEGRA_VIDEO_FORMAT(YUV422, 16, VYUY8_1X16, 2, 1, T_V8_Y8__U8_Y8,
+				YUV422_8, Y8I, "Y8I 16"),
+	// TODO: RealSesne calibration format Y12I should be 3-byte,
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4]
+	// but, currently, it's 4-byte, one byte is added as alignment
+	// R[7:3]R[3:0] | L[3:0]R[11:8] | L[11:8]L[7:4] | ALIGN[7:0]
+	TEGRA_VIDEO_FORMAT(RGB888, 24, RGB888_1X24, 4, 1, T_A8R8G8B8,
+				RGB888, Y12I, "Y12I 24"),
+
 };
 
 #endif
diff --git a/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c b/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c
index 78ad664..8795afe 100644
--- a/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c
+++ b/kernel/nvidia/drivers/video/tegra/camera/tegra_camera_platform.c
@@ -1162,6 +1162,11 @@ int tegra_camera_update_clknbw(void *priv, bool stream_on)
 	struct tegra_camera_info *info;
 	int ret = 0;
 
+	/* TODO: workarouud for Xavier */
+	if (NULL == tegra_camera_misc.parent) {
+		return 0;
+	}
+
 	info = dev_get_drvdata(tegra_camera_misc.parent);
 	if (!info)
 		return -EINVAL;
diff --git a/kernel/nvidia/include/media/gmsl-link.h b/kernel/nvidia/include/media/gmsl-link.h
index 1eab7ba..533f31e 100644
--- a/kernel/nvidia/include/media/gmsl-link.h
+++ b/kernel/nvidia/include/media/gmsl-link.h
@@ -53,6 +53,9 @@
 #define GMSL_CSI_DT_RAW_12 0x2C
 #define GMSL_CSI_DT_UED_U1 0x30
 #define GMSL_CSI_DT_EMBED 0x12
+#define GMSL_CSI_DT_YUV422_8 0x1E
+#define GMSL_CSI_DT_RGB_888 0x24
+#define GMSL_CSI_DT_RAW_8 0x2A
 
 #define GMSL_ST_ID_UNUSED 0xFF
 
diff --git a/kernel/nvidia/include/media/max9295.h b/kernel/nvidia/include/media/max9295.h
index cff6b86..bea15c4 100644
--- a/kernel/nvidia/include/media/max9295.h
+++ b/kernel/nvidia/include/media/max9295.h
@@ -25,6 +25,7 @@
 #ifndef __MAX9295_H__
 #define __MAX9295_H__
 
+#include <linux/types.h>
 #include <media/gmsl-link.h>
 /**
  * \defgroup max9295 MAX9295 serializer driver
@@ -35,6 +36,8 @@
  * @{
  */
 
+int max9295_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+		     u8 data_type2, u32 vc_id);
 
 /**
  * @brief  Powers on a serializer device and performs the I2C overrides
@@ -95,6 +98,7 @@ int max9295_sdev_unpair(struct device *dev, struct device *s_dev);
  */
 int max9295_setup_streaming(struct device *dev);
 
+int max9295_init_settings(struct device *dev);
 /** @} */
 
 #endif  /* __MAX9295_H__ */
diff --git a/kernel/nvidia/include/media/max9296.h b/kernel/nvidia/include/media/max9296.h
index 61435e2..20f3a66 100644
--- a/kernel/nvidia/include/media/max9296.h
+++ b/kernel/nvidia/include/media/max9296.h
@@ -25,6 +25,7 @@
 #ifndef __MAX9296_H__
 #define __MAX9296_H__
 
+#include <linux/types.h>
 #include <media/gmsl-link.h>
 /**
  * \defgroup max9296 MAX9296 deserializer driver
@@ -35,6 +36,12 @@
  * @{
  */
 
+int max9296_get_available_pipe_id(struct device *dev, int vc_id);
+int max9296_set_pipe(struct device *dev, int pipe_id, u8 data_type1,
+		     u8 data_type2, u32 vc_id);
+int max9296_release_pipe(struct device *dev, int pipe_id);
+void max9296_reset_oneshot(struct device *dev);
+
 /**
  * Puts a deserializer device in single exclusive link mode, so link-specific
  * I2C overrides can be performed for sensor and serializer devices.
@@ -159,6 +166,7 @@ int max9296_power_on(struct device *dev);
  */
 void max9296_power_off(struct device *dev);
 
+int max9296_init_settings(struct device *dev);
 /** @} */
 
 #endif  /* __MAX9296_H__ */
diff --git a/kernel/nvidia/include/media/mc_common.h b/kernel/nvidia/include/media/mc_common.h
index 2ac69d0..b03108c 100644
--- a/kernel/nvidia/include/media/mc_common.h
+++ b/kernel/nvidia/include/media/mc_common.h
@@ -43,6 +43,7 @@
 #define	ENABLE		1
 #define	DISABLE		0
 #define MAX_SYNCPT_PER_CHANNEL	3
+#define MAX_CHANNELS 6
 
 #define CAPTURE_MIN_BUFFERS	1U
 #define CAPTURE_MAX_BUFFERS	240U
@@ -233,6 +234,23 @@ struct tegra_channel {
 	unsigned int embedded_data_width;
 	unsigned int embedded_data_height;
 
+	struct {
+		struct video_device *video;
+		struct mutex lock;
+		spinlock_t spin_lock;
+		struct vb2_queue queue;
+		/*FIXME: 16 is max queued metadata buffers
+		* define 16
+		*/
+		struct vb2_buffer *buffers[16];
+		unsigned int head;
+		unsigned int tail;
+		unsigned int num_buffers;
+		void *alloc_ctx;
+		struct media_pad pad;
+		struct v4l2_ctrl_handler ctrl_handler;
+	} embedded;
+
 	DECLARE_BITMAP(fmts_bitmap, MAX_FORMAT_NUM);
 	atomic_t power_on_refcnt;
 	struct v4l2_fh *fh;
@@ -312,6 +330,9 @@ struct tegra_mc_vi {
 	unsigned int num_channels;
 	unsigned int num_subdevs;
 
+	struct device *dser_dev;
+	struct device *ser_dev;
+
 	struct tegra_csi_device *csi;
 	struct list_head vi_chans;
 	struct tegra_channel *tpg_start;
@@ -416,7 +437,9 @@ struct tegra_channel_buffer *dequeue_inflight(struct tegra_channel *chan);
 int tegra_channel_set_power(struct tegra_channel *chan, bool on);
 
 int tegra_channel_init_video(struct tegra_channel *chan);
+int tegra_channel_init_video_embedded(struct tegra_channel *chan);
 int tegra_channel_cleanup_video(struct tegra_channel *chan);
+int tegra_channel_cleanup_video_embedded(struct tegra_channel *chan);
 
 struct tegra_vi_fops {
 	int (*vi_power_on)(struct tegra_channel *chan);
diff --git a/kernel/nvidia/include/media/tegra_camera_core.h b/kernel/nvidia/include/media/tegra_camera_core.h
index 788cf77..1f57648 100644
--- a/kernel/nvidia/include/media/tegra_camera_core.h
+++ b/kernel/nvidia/include/media/tegra_camera_core.h
@@ -23,7 +23,7 @@
 /* Width alignment */
 #define TEGRA_WIDTH_ALIGNMENT	1
 /* Stride alignment */
-#define TEGRA_STRIDE_ALIGNMENT	1
+#define TEGRA_STRIDE_ALIGNMENT	64
 /* Height alignment */
 #define TEGRA_HEIGHT_ALIGNMENT	1
 /* Size alignment */
@@ -37,6 +37,8 @@
 #define TEGRA_IMAGE_FORMAT_DEF	32
 
 enum tegra_image_dt {
+	TEGRA_IMAGE_DT_EMBEDDED_8 = 18,
+
 	TEGRA_IMAGE_DT_YUV420_8 = 24,
 	TEGRA_IMAGE_DT_YUV420_10,
 
@@ -56,6 +58,12 @@ enum tegra_image_dt {
 	TEGRA_IMAGE_DT_RAW10,
 	TEGRA_IMAGE_DT_RAW12,
 	TEGRA_IMAGE_DT_RAW14,
+
+	TEGRA_IMAGE_DT_USER_1 = 48,
+	TEGRA_IMAGE_DT_USER_2,
+	TEGRA_IMAGE_DT_USER_3,
+	TEGRA_IMAGE_DT_USER_4,
+
 };
 
 /* Supported CSI to VI Data Formats */
-- 
2.46.1

