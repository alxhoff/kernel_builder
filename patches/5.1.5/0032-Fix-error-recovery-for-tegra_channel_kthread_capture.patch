From b96386b47a7e23e8049638eb82a6b0440662a6ef Mon Sep 17 00:00:00 2001
From: Brian Silverman <brian.silverman@bluerivert.com>
Date: Mon, 23 Dec 2019 12:52:45 -0800
Subject: [PATCH 32/33] Fix error recovery for
 tegra_channel_kthread_capture_dequeue

Previously, it allowed the main application thread to sneak in the
middle of its error recovery. This led to double-frees and other forms
of corrupted state.

Also, as documented at https://lore.kernel.org/patchwork/patch/589697/,
if you're going to call kthread_stop, the kthread needs to wait until
kthread_should_stop returns 1 before returning. Otherwise, there's a
race condition leading to double-frees and NULL dereferences.
---
 .../media/platform/tegra/camera/vi/vi5_fops.c | 118 ++++++++++--------
 1 file changed, 68 insertions(+), 50 deletions(-)

diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
index 175aa937a..6d42330f5 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_fops.c
@@ -674,15 +674,17 @@ static int vi5_channel_error_recover(struct tegra_channel *chan,
 
 	/* stop vi channel */
 	for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-		err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-			CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
-		if (err)
-			dev_err(&chan->video->dev, "vi capture release failed\n");
-		vi_channel_close_ex(chan->vi_channel_id[vi_port],
-					chan->tegra_vi_channel[vi_port]);
-		chan->tegra_vi_channel[vi_port] = NULL;
-		if (err)
-			goto done;
+		if (chan->tegra_vi_channel[vi_port]) {
+			err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+				CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+			if (err) {
+				dev_err(&chan->video->dev, "vi capture release failed\n");
+				goto done;
+			}
+			vi_channel_close_ex(chan->vi_channel_id[vi_port],
+						chan->tegra_vi_channel[vi_port]);
+			chan->tegra_vi_channel[vi_port] = NULL;
+		}
 	}
 
 
@@ -788,6 +790,7 @@ static int tegra_channel_kthread_capture_dequeue(void *data)
 	unsigned long flags;
 	struct tegra_channel *chan = data;
 	struct tegra_channel_buffer *buf;
+	enum channel_capture_state capture_state;
 
 	set_freezable();
 
@@ -809,25 +812,35 @@ static int tegra_channel_kthread_capture_dequeue(void *data)
 			vi5_capture_dequeue(chan, buf);
 		}
 
-		spin_lock_irqsave(&chan->capture_state_lock, flags);
-		if (chan->capture_state == CAPTURE_ERROR_TIMEOUT) {
-			spin_unlock_irqrestore(&chan->capture_state_lock,
-				flags);
+		if (kthread_should_stop())
 			break;
-		}
 
-		if (chan->capture_state == CAPTURE_ERROR) {
-			spin_unlock_irqrestore(&chan->capture_state_lock,
-				flags);
-			err = tegra_channel_error_recover(chan, false);
-			if (err) {
+		spin_lock_irqsave(&chan->capture_state_lock, flags);
+		capture_state = chan->capture_state;
+		spin_unlock_irqrestore(&chan->capture_state_lock, flags);
+		if (capture_state == CAPTURE_ERROR) {
+			/* We deliberately keep this lock held even across
+			 * msleep calls so that no other context can observe
+			 * the invalid state produced by failed error_recover
+			 * calls. */
+			mutex_lock(&chan->video_lock);
+			while (!kthread_should_stop()) {
+				err = tegra_channel_error_recover(chan, false);
+				if (!err) {
+					break;
+				}
 				dev_err(chan->vi->dev,
-					"fatal: error recovery failed\n");
-				break;
+					"fatal: error recovery failed: %d\n",
+					err);
+				if (kthread_should_stop()) {
+					break;
+				}
+				/* kthread_stop won't interrupt this, but it's
+				 * pretty short so it's fine */
+				msleep(300);
 			}
-		} else
-			spin_unlock_irqrestore(&chan->capture_state_lock,
-				flags);
+			mutex_unlock(&chan->video_lock);
+		}
 		if (kthread_should_stop())
 			break;
 	}
@@ -876,6 +889,7 @@ done:
 static void vi5_channel_stop_kthreads(struct tegra_channel *chan)
 {
 	mutex_lock(&chan->stop_kthread_lock);
+	mutex_unlock(&chan->video_lock);
 
 	/* Stop the kthread for capture enqueue */
 	if (chan->kthread_capture_start) {
@@ -890,6 +904,7 @@ static void vi5_channel_stop_kthreads(struct tegra_channel *chan)
 		chan->kthread_capture_dequeue = NULL;
 	}
 
+	mutex_lock(&chan->video_lock);
 	mutex_unlock(&chan->stop_kthread_lock);
 }
 
@@ -1041,6 +1056,7 @@ static int vi5_channel_stop_streaming(struct vb2_queue *vq)
 {
 	struct tegra_channel *chan = vb2_get_drv_priv(vq);
 	int vi_port = 0;
+	uint8_t err;
 	if (!chan->bypass)
 		vi5_channel_stop_kthreads(chan);
 
@@ -1049,34 +1065,36 @@ static int vi5_channel_stop_streaming(struct vb2_queue *vq)
 
 	if (!chan->bypass) {
 		for (vi_port = 0; vi_port < chan->valid_ports; vi_port++) {
-            err = vi_capture_release(chan->tegra_vi_channel[vi_port],
-                CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
-
-            if (err)
-                dev_err(&chan->video->dev,
-                    "vi capture release failed\n");
-
-			/* Release capture requests */
-			if (chan->request[vi_port] != NULL) {
-					dma_free_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
-					chan->capture_queue_depth * sizeof(struct capture_descriptor),
-					chan->request[vi_port], chan->request_iova[vi_port]);
-			}
-			chan->request[vi_port] = NULL;
+			if (chan->tegra_vi_channel[vi_port]) {
+				err = vi_capture_release(chan->tegra_vi_channel[vi_port],
+					CAPTURE_CHANNEL_RESET_FLAG_IMMEDIATE);
+
+				if (err)
+					dev_err(&chan->video->dev,
+						"vi capture release failed\n");
+
+				/* Release capture requests */
+				if (chan->request[vi_port] != NULL) {
+						dma_free_coherent(chan->tegra_vi_channel[vi_port]->rtcpu_dev,
+						chan->capture_queue_depth * sizeof(struct capture_descriptor),
+						chan->request[vi_port], chan->request_iova[vi_port]);
+				}
+				chan->request[vi_port] = NULL;
+
+				/* Release emd data buffers */
+				if (chan->emb_buf_size > 0) {
+						struct device *vi_unit_dev;
+						vi5_unit_get_device_handle(chan->vi->ndev, chan->port[0],\
+																		&vi_unit_dev);
+						dma_free_coherent(vi_unit_dev, chan->emb_buf_size,
+														chan->emb_buf_addr, chan->emb_buf);
+						chan->emb_buf_size = 0;
+				}
 
-			/* Release emd data buffers */
-			if (chan->emb_buf_size > 0) {
-					struct device *vi_unit_dev;
-					vi5_unit_get_device_handle(chan->vi->ndev, chan->port[0],\
-																	&vi_unit_dev);
-					dma_free_coherent(vi_unit_dev, chan->emb_buf_size,
-													chan->emb_buf_addr, chan->emb_buf);
-					chan->emb_buf_size = 0;
+				vi_channel_close_ex(chan->vi_channel_id[vi_port],
+							chan->tegra_vi_channel[vi_port]);
+				chan->tegra_vi_channel[vi_port] = NULL;
 			}
-
-            vi_channel_close_ex(chan->vi_channel_id[vi_port],
-                        chan->tegra_vi_channel[vi_port]);
-            chan->tegra_vi_channel[vi_port] = NULL;
 		}
 
 		/* release all remaining buffers to v4l2 */
-- 
2.52.0

